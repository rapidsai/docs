

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; cudf 0.7.1+0.g7ee0348.dirty documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10 Minutes to cuDF" href="10min.html" />
    <link rel="prev" title="Welcome to cuDF’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cudf
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dataframe">DataFrame</a></li>
<li class="toctree-l2"><a class="reference internal" href="#series">Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#groupby">Groupby</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cudf.io.csv">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpuarrowreader">GpuArrowReader</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="10min.html">10 Minutes to cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="dask-cudf.html">Multi-GPU with Dask-cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="dask-xgb-10min.html">10 Minutes to Dask-XGBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer.html">Developer Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cudf</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="dataframe">
<h2>DataFrame<a class="headerlink" href="#dataframe" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.dataframe.DataFrame">
<em class="property">class </em><code class="descclassname">cudf.dataframe.</code><code class="descname">DataFrame</code><span class="sig-paren">(</span><em>name_series=None</em>, <em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>A GPU Dataframe object.</p>
<p class="rubric">Examples</p>
<p>Build dataframe with <cite>__setitem__</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
<p>Build dataframe with initializer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Create some datetime data</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t0</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-07 12:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datetimes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">datetimes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create the GPU DataFrame</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">ids</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;datetimes&#39;</span><span class="p">,</span> <span class="n">dts</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">    id                datetimes</span>
<span class="go">0    0  2018-10-07T12:00:00.000</span>
<span class="go">1    1  2018-10-07T12:00:01.000</span>
<span class="go">2    2  2018-10-07T12:00:02.000</span>
<span class="go">3    3  2018-10-07T12:00:03.000</span>
<span class="go">4    4  2018-10-07T12:00:04.000</span>
</pre></div>
</div>
<p>Convert from a Pandas DataFrame:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  a b</span>
<span class="go">0 0 0.1</span>
<span class="go">1 1 0.2</span>
<span class="go">2 2 nan</span>
<span class="go">3 3 0.3</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>T</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.columns" title="cudf.dataframe.DataFrame.columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">columns</span></code></a></dt><dd><p>Returns a tuple of columns</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.dtypes" title="cudf.dataframe.DataFrame.dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtypes</span></code></a></dt><dd><p>Return the dtypes in this object.</p>
</dd>
<dt><strong>empty</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.iloc" title="cudf.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt><dd><p>Returns a integer-location based indexer for selection by position.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.index" title="cudf.dataframe.DataFrame.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt><dd><p>Returns the index of the DataFrame</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.loc" title="cudf.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt><dd><p>Returns a label-based indexer for row-slicing and column selection.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.ndim" title="cudf.dataframe.DataFrame.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>Dimension of the data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.shape" title="cudf.dataframe.DataFrame.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.add_column" title="cudf.dataframe.DataFrame.add_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_column</span></code></a>(self, name, data[, forceindex])</p></td>
<td><p>Add a column</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_chunks" title="cudf.dataframe.DataFrame.apply_chunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_chunks</span></code></a>(self, func, incols, outcols[, …])</p></td>
<td><p>Transform user-specified chunks using the user-provided function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_rows" title="cudf.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_rows</span></code></a>(self, func, incols, outcols, kwargs)</p></td>
<td><p>Apply a row-wise user defined function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.as_gpu_matrix" title="cudf.dataframe.DataFrame.as_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_gpu_matrix</span></code></a>(self[, columns, order])</p></td>
<td><p>Convert to a matrix in device memory.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.as_matrix" title="cudf.dataframe.DataFrame.as_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_matrix</span></code></a>(self[, columns])</p></td>
<td><p>Convert to a matrix in host memory.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.assign" title="cudf.dataframe.DataFrame.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Assign columns to DataFrame from keyword arguments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.copy" title="cudf.dataframe.DataFrame.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(self[, deep])</p></td>
<td><p>Returns a copy of this dataframe</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code>(self)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.describe" title="cudf.dataframe.DataFrame.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">describe</span></code></a>(self[, percentiles, include, exclude])</p></td>
<td><p>Compute summary statistics of a DataFrame’s columns.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.drop" title="cudf.dataframe.DataFrame.drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop</span></code></a>(self, labels[, axis])</p></td>
<td><p>Drop column(s)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.drop_column" title="cudf.dataframe.DataFrame.drop_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_column</span></code></a>(self, name)</p></td>
<td><p>Drop a column by <em>name</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.fillna" title="cudf.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(self, value[, method, axis, inplace, …])</p></td>
<td><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.from_arrow" title="cudf.dataframe.DataFrame.from_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_arrow</span></code></a>(table)</p></td>
<td><p>Convert from a PyArrow Table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.from_gpu_matrix" title="cudf.dataframe.DataFrame.from_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_gpu_matrix</span></code></a>(data[, index, columns, …])</p></td>
<td><p>Convert from a numba gpu ndarray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.from_pandas" title="cudf.dataframe.DataFrame.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(dataframe[, nan_as_null])</p></td>
<td><p>Convert from a Pandas DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.from_records" title="cudf.dataframe.DataFrame.from_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_records</span></code></a>(data[, index, columns, nan_as_null])</p></td>
<td><p>Convert from a numpy recarray or structured array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.groupby" title="cudf.dataframe.DataFrame.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a>(self[, by, sort, as_index, method, …])</p></td>
<td><p>Groupby</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.hash_columns" title="cudf.dataframe.DataFrame.hash_columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_columns</span></code></a>(self[, columns])</p></td>
<td><p>Hash the given <em>columns</em> and return a new Series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.head" title="cudf.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">head</span></code></a>(self[, n])</p></td>
<td><p>Returns the first n rows as a new DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.iteritems" title="cudf.dataframe.DataFrame.iteritems"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iteritems</span></code></a>(self)</p></td>
<td><p>Iterate over column names and series pairs</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.join" title="cudf.dataframe.DataFrame.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(self, other[, on, how, lsuffix, …])</p></td>
<td><p>Join columns with other DataFrame on index or on a key column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.label_encoding" title="cudf.dataframe.DataFrame.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(self, column, prefix, cats[, …])</p></td>
<td><p>Encode labels in a column with label encoding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.mean" title="cudf.dataframe.DataFrame.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Return the mean of the values for the requested axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.melt" title="cudf.dataframe.DataFrame.melt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">melt</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Unpivots a DataFrame from wide format to long format, optionally leaving identifier variables set.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.merge" title="cudf.dataframe.DataFrame.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code></a>(self, right[, on, how, left_on, …])</p></td>
<td><p>Merge GPU DataFrame objects by performing a database-style join operation by columns or indexes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.nlargest" title="cudf.dataframe.DataFrame.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(self, n, columns[, keep])</p></td>
<td><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.nsmallest" title="cudf.dataframe.DataFrame.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(self, n, columns[, keep])</p></td>
<td><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.one_hot_encoding" title="cudf.dataframe.DataFrame.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(self, column, prefix, cats)</p></td>
<td><p>Expand a column with one-hot-encoding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.partition_by_hash" title="cudf.dataframe.DataFrame.partition_by_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_by_hash</span></code></a>(self, columns, nparts)</p></td>
<td><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.pop" title="cudf.dataframe.DataFrame.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code></a>(self, item)</p></td>
<td><p>Return a column and drop it from the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.quantile" title="cudf.dataframe.DataFrame.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(self[, q, interpolation, columns, …])</p></td>
<td><p>Return values at the given quantile.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.query" title="cudf.dataframe.DataFrame.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query</span></code></a>(self, expr[, local_dict])</p></td>
<td><p>Query with a boolean expression using Numba to compile a GPU kernel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.rename" title="cudf.dataframe.DataFrame.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(self[, mapper, columns, copy, inplace])</p></td>
<td><p>Alter column labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.replace" title="cudf.dataframe.DataFrame.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(self, to_replace, value)</p></td>
<td><p>Replace values given in <em>to_replace</em> with <em>value</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.select_dtypes" title="cudf.dataframe.DataFrame.select_dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_dtypes</span></code></a>(self[, include, exclude])</p></td>
<td><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.set_index" title="cudf.dataframe.DataFrame.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(self, index)</p></td>
<td><p>Return a new DataFrame with a new index</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.sort_index" title="cudf.dataframe.DataFrame.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>(self[, ascending])</p></td>
<td><p>Sort by the index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.sort_values" title="cudf.dataframe.DataFrame.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(self, by[, ascending, na_position])</p></td>
<td><p>Sort by the values row-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.tail" title="cudf.dataframe.DataFrame.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>(self[, n])</p></td>
<td><p>Returns the last n rows as a new DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_arrow" title="cudf.dataframe.DataFrame.to_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_arrow</span></code></a>(self[, preserve_index])</p></td>
<td><p>Convert to a PyArrow Table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_dlpack" title="cudf.dataframe.DataFrame.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>(self)</p></td>
<td><p>Converts a cuDF object into a DLPack tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_feather" title="cudf.dataframe.DataFrame.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_feather</span></code></a>(self, path, \*args, \*\*kwargs)</p></td>
<td><p>Write a DataFrame to the feather format.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_gpu_matrix" title="cudf.dataframe.DataFrame.to_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_matrix</span></code></a>(self)</p></td>
<td><p>Convert to a numba gpu ndarray</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_hdf" title="cudf.dataframe.DataFrame.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(self, path_or_buf, key, \*args, …)</p></td>
<td><p>Write the contained data to an HDF5 file using HDFStore.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_json" title="cudf.dataframe.DataFrame.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>(self[, path_or_buf])</p></td>
<td><p>Convert the cuDF object to a JSON string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_pandas" title="cudf.dataframe.DataFrame.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self)</p></td>
<td><p>Convert to a Pandas DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_parquet" title="cudf.dataframe.DataFrame.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a>(self, path, \*args, \*\*kwargs)</p></td>
<td><p>Write a DataFrame to the parquet format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_records" title="cudf.dataframe.DataFrame.to_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_records</span></code></a>(self[, index])</p></td>
<td><p>Convert to a numpy recarray</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.to_string" title="cudf.dataframe.DataFrame.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>(self[, nrows, ncols])</p></td>
<td><p>Convert to string</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.DataFrame.transpose" title="cudf.dataframe.DataFrame.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(self)</p></td>
<td><p>Transpose index and columns.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>acos</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>argsort</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>asin</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>atan</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>cos</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>cummax</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>cummin</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>cumprod</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>cumsum</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>deserialize</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>equals</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>exp</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>log</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>mask</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>max</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>min</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>product</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>reset_index</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>serialize</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>sin</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>sqrt</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>std</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>sum</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>take</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>tan</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>var</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.dataframe.DataFrame.add_column">
<code class="descname">add_column</code><span class="sig-paren">(</span><em>self</em>, <em>name</em>, <em>data</em>, <em>forceindex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.add_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of column to be added.</p>
</dd>
<dt><strong>data</strong><span class="classifier">Series, array-like</span></dt><dd><p>Values to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.apply_chunks">
<code class="descname">apply_chunks</code><span class="sig-paren">(</span><em>self</em>, <em>func</em>, <em>incols</em>, <em>outcols</em>, <em>kwargs={}</em>, <em>chunks=None</em>, <em>tpb=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.apply_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform user-specified chunks using the user-provided function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt><dd><p>A list of names of input columns.</p>
</dd>
<dt><strong>outcols: dict</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">int or Series-like</span></dt><dd><p>If it is an <code class="docutils literal notranslate"><span class="pre">int</span></code>, it is the chunksize.
If it is an array, it contains integer offset for the start of
each chunk.  The span of a chunk for chunk i-th is
<code class="docutils literal notranslate"><span class="pre">data[chunks[i]</span> <span class="pre">:</span> <span class="pre">chunks[i</span> <span class="pre">+</span> <span class="pre">1]]</span></code> for any
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">chunks.size</span></code>; or, <code class="docutils literal notranslate"><span class="pre">data[chunks[i]:]</span></code> for the
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">len(chunks)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>tpb</strong><span class="classifier">int; optional</span></dt><dd><p>It is the thread-per-block for the underlying kernel.
The default uses 1 thread to emulate serial execution for
each chunk.  It is a good starting point but inefficient.
Its maximum possible value is limited by the available CUDA GPU
resources.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_rows" title="cudf.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply_rows</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>For <code class="docutils literal notranslate"><span class="pre">tpb</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">func</span></code> is executed by <code class="docutils literal notranslate"><span class="pre">tpb</span></code> number of threads
concurrently.  To access the thread id and count,
use <code class="docutils literal notranslate"><span class="pre">numba.cuda.threadIdx.x</span></code> and <code class="docutils literal notranslate"><span class="pre">numba.cuda.blockDim.x</span></code>,
respectively (See <a class="reference external" href="http://numba.pydata.org/numba-doc/latest/cuda/kernels.html">numba CUDA kernel documentation</a>).</p>
<p>In the example below, the <em>kernel</em> is invoked concurrently on each
specified chunk. The <em>kernel</em> computes the corresponding output
for the chunk.</p>
<p>By looping over the range
<code class="docutils literal notranslate"><span class="pre">range(cuda.threadIdx.x,</span> <span class="pre">in1.size,</span> <span class="pre">cuda.blockDim.x)</span></code>, the <em>kernel</em>
function can be used with any <em>tpb</em> in a efficient manner.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">cuda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@cuda</span><span class="o">.</span><span class="n">jit</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">):</span>
<span class="gp">... </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>         <span class="n">x</span> <span class="o">=</span> <span class="n">in1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">y</span> <span class="o">=</span> <span class="n">in2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">z</span> <span class="o">=</span> <span class="n">in3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.apply_rows">
<code class="descname">apply_rows</code><span class="sig-paren">(</span><em>self</em>, <em>func</em>, <em>incols</em>, <em>outcols</em>, <em>kwargs</em>, <em>cache_key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.apply_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a row-wise user defined function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt><dd><p>A list of names of input columns.</p>
</dd>
<dt><strong>outcols: dict</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The user function should loop over the columns and set the output for
each row. Loop execution order is arbitrary, so each iteration of
the loop <strong>MUST</strong> be independent of each other.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">func</span></code> is invoked, the array args corresponding to the
input/output are strided so as to improve GPU parallelism.
The loop in the function resembles serial code, but executes
concurrently in multiple threads.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nelem</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
</pre></div>
</div>
<p>Define input columns for the kernel</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">in1</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in3</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">,</span> <span class="n">kwarg1</span><span class="p">,</span> <span class="n">kwarg2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">)):</span>
<span class="gp">... </span>        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwarg2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">... </span>        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">z</span>
</pre></div>
</div>
<p>Call <code class="docutils literal notranslate"><span class="pre">.apply_rows</span></code> with the name of the input columns, the name and
dtype of the output columns, and, optionally, a dict of extra
arguments.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">apply_rows</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">,</span> <span class="s1">&#39;in2&#39;</span><span class="p">,</span> <span class="s1">&#39;in3&#39;</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">outcols</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">out2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwarg1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">kwarg2</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">   in1  in2  in3 out1 out2</span>
<span class="go">0    0    0    0  0.0  0.0</span>
<span class="go">1    1    1    1  1.0 -2.0</span>
<span class="go">2    2    2    2  2.0 -4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.as_gpu_matrix">
<code class="descname">as_gpu_matrix</code><span class="sig-paren">(</span><em>self</em>, <em>columns=None</em>, <em>order='F'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.as_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in device memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
<dt><strong>order</strong><span class="classifier">‘F’ or ‘C’</span></dt><dd><p>Optional argument to determine whether to return a column major
(Fortran) matrix or a row major (C) matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A (nrow x ncol) numpy ndarray in “F” order.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.as_matrix">
<code class="descname">as_matrix</code><span class="sig-paren">(</span><em>self</em>, <em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.as_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in host memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A (nrow x ncol) numpy ndarray in “F” order.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>self</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign columns to DataFrame from keyword arguments.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">0  0  3</span>
<span class="go">1  1  4</span>
<span class="go">2  2  5</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.columns">
<code class="descname">columns</code><a class="headerlink" href="#cudf.dataframe.DataFrame.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of columns</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>self</em>, <em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this dataframe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep: bool</strong></dt><dd><p>Make a full copy of Series columns and Index at the GPU level, or
create a new allocation with references.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.describe">
<code class="descname">describe</code><span class="sig-paren">(</span><em>self</em>, <em>percentiles=None</em>, <em>include=None</em>, <em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute summary statistics of a DataFrame’s columns. For numeric
data, the output includes the minimum, maximum, mean, median,
standard deviation, and various quantiles. For object data, the output
includes the count, number of unique values, the most common value, and
the number of occurrences of the most common value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like, optional</span></dt><dd><p>The percentiles used to generate the output summary statistics.
If None, the default percentiles used are the 25th, 50th and 75th.
Values should be within the interval [0, 1].</p>
</dd>
<dt><strong>include: str, list-like, optional</strong></dt><dd><p>The dtypes to be included in the output summary statistics. Columns
of dtypes not included in this list will not be part of the output.
If include=’all’, all dtypes are included. Default of None includes
all numeric columns.</p>
</dd>
<dt><strong>exclude: str, list-like, optional</strong></dt><dd><p>The dtypes to be excluded from the output summary statistics.
Columns of dtypes included in this list will not be part of the
output. Default of None excludes no columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output_frame</strong><span class="classifier">DataFrame</span></dt><dd><p>Summary statistics of relevant columns in the original dataframe.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">Series</span></code> containing numeric values.
&gt;&gt;&gt; import cudf
&gt;&gt;&gt; s = cudf.Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
&gt;&gt;&gt; print(s.describe())</p>
<blockquote>
<div><p>stats   values</p>
</div></blockquote>
<p>0  count     10.0
1   mean      5.5
2    std  3.02765
3    min      1.0
4    25%      2.5
5    50%      5.5
6    75%      7.5
7    max     10.0</p>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. By default all numeric fields
are returned.
&gt;&gt;&gt; gdf = cudf.DataFrame()
&gt;&gt;&gt; gdf[‘a’] = [1,2,3]
&gt;&gt;&gt; gdf[‘b’] = [1.0, 2.0, 3.0]
&gt;&gt;&gt; gdf[‘c’] = [‘x’, ‘y’, ‘z’]
&gt;&gt;&gt; gdf[‘d’] = [1.0, 2.0, 3.0]
&gt;&gt;&gt; gdf[‘d’] = gdf[‘d’].astype(‘float32’)
&gt;&gt;&gt; print(gdf.describe())</p>
<blockquote>
<div><p>stats    a    b    d</p>
</div></blockquote>
<p>0  count  3.0  3.0  3.0
1   mean  2.0  2.0  2.0
2    std  1.0  1.0  1.0
3    min  1.0  1.0  1.0
4    25%  1.5  1.5  1.5
5    50%  1.5  1.5  1.5
6    75%  2.5  2.5  2.5
7    max  3.0  3.0  3.0</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">include</span></code> keyword to describe only specific dtypes.
&gt;&gt;&gt; gdf = cudf.DataFrame()
&gt;&gt;&gt; gdf[‘a’] = [1,2,3]
&gt;&gt;&gt; gdf[‘b’] = [1.0, 2.0, 3.0]
&gt;&gt;&gt; gdf[‘c’] = [‘x’, ‘y’, ‘z’]
&gt;&gt;&gt; print(gdf.describe(include=’int’))</p>
<blockquote>
<div><p>stats    a</p>
</div></blockquote>
<p>0  count  3.0
1   mean  2.0
2    std  1.0
3    min  1.0
4    25%  1.5
5    50%  1.5
6    75%  2.5
7    max  3.0</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>self</em>, <em>labels</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop column(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">str or sequence of strings</span></dt><dd><p>Name of column(s) to be dropped.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A dataframe without dropped column(s)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_new</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;val&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_new</span><span class="p">)</span>
<span class="go">   key</span>
<span class="go">0    0</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.drop_column">
<code class="descname">drop_column</code><span class="sig-paren">(</span><em>self</em>, <em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.drop_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop a column by <em>name</em></p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.dtypes">
<code class="descname">dtypes</code><a class="headerlink" href="#cudf.dataframe.DataFrame.dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dtypes in this object.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.fillna">
<code class="descname">fillna</code><span class="sig-paren">(</span><em>self</em>, <em>value</em>, <em>method=None</em>, <em>axis=None</em>, <em>inplace=False</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar, Series-like or dict</span></dt><dd><p>Value to use to fill nulls. If Series-like, null values
are filled with values in corresponding indices.
A dict can be used to provide different values to fill nulls
in different columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd><p>Copy with nulls filled.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  4  5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  3  5</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_arrow">
<em class="property">classmethod </em><code class="descname">from_arrow</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a PyArrow Table.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
<dt><strong>Notes</strong></dt><dd></dd>
<dt>Does not support automatically setting index column(s) similar to how</dt><dd></dd>
<dt><code class="docutils literal notranslate"><span class="pre">to_pandas</span></code> works for PyArrow Tables.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">,</span> <span class="s1">&#39;f1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_batches</span><span class="p">([</span><span class="n">batch</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_arrow</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
<span class="go">&lt;cudf.DataFrame ncols=2 nrows=3 &gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_gpu_matrix">
<em class="property">classmethod </em><code class="descname">from_gpu_matrix</code><span class="sig-paren">(</span><em>data</em>, <em>index=None</em>, <em>columns=None</em>, <em>nan_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numba gpu ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numba gpu ndarray</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">str</span></dt><dd><p>The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_pandas">
<em class="property">classmethod </em><code class="descname">from_pandas</code><span class="sig-paren">(</span><em>dataframe</em>, <em>nan_as_null=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a Pandas DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="go">&lt;cudf.DataFrame ncols=2 nrows=3 &gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_records">
<em class="property">classmethod </em><code class="descname">from_records</code><span class="sig-paren">(</span><em>data</em>, <em>index=None</em>, <em>columns=None</em>, <em>nan_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numpy recarray or structured array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy structured dtype or recarray of ndim=2</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">str</span></dt><dd><p>The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.groupby">
<code class="descname">groupby</code><span class="sig-paren">(</span><em>self</em>, <em>by=None</em>, <em>sort=False</em>, <em>as_index=True</em>, <em>method='hash'</em>, <em>level=None</em>, <em>group_keys=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">list-of-str or str</span></dt><dd><p>Column name(s) to form that groups by.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool</span></dt><dd><p>Force sorting group keys.
Depends on the underlying algorithm.</p>
</dd>
<dt><strong>as_index</strong><span class="classifier">bool; defaults to False</span></dt><dd><p>Must be False.  Provided to be API compatible with pandas.
The keys are always left as regular columns in the result.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>A string indicating the method to use to perform the group by.
Valid values are “hash” or “cudf”.
“cudf” method may be deprecated in the future, but is currently
the only method supporting group UDFs via the <cite>apply</cite> function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The groupby object</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Unlike pandas, this groupby operation behaves like a SQL groupby.
No empty rows are returned.  (For categorical keys, pandas returns
rows for all categories even if they are no corresponding values.)</p>
<p>Only a minimal number of operations is implemented so far.</p>
<ul class="simple">
<li><p>Only <em>by</em> argument is supported.</p></li>
<li><p>Since we don’t support multiindex, the <em>by</em> columns are stored
as regular columns.</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.hash_columns">
<code class="descname">hash_columns</code><span class="sig-paren">(</span><em>self</em>, <em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.hash_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the given <em>columns</em> and return a new Series</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">sequence of str; optional</span></dt><dd><p>Sequence of column names. If columns is <em>None</em> (unspecified),
all columns in the frame are used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.head">
<code class="descname">head</code><span class="sig-paren">(</span><em>self</em>, <em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.iloc">
<code class="descname">iloc</code><a class="headerlink" href="#cudf.dataframe.DataFrame.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a  integer-location based indexer for selection by position.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># get the row from index 1st</span>
<span class="go">a    1</span>
<span class="go">b    1</span>
<span class="go">c    1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">18</span><span class="p">]]</span>  <span class="c1"># get the rows from indices 0,2,9 and 18.</span>
<span class="go">      a    b    c</span>
<span class="go"> 0    0    0    0</span>
<span class="go"> 2    2    2    2</span>
<span class="go"> 9    9    9    9</span>
<span class="go">18   18   18   18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># get the rows using slice indices</span>
<span class="go">     a    b    c</span>
<span class="go">3    3    3    3</span>
<span class="go">5    5    5    5</span>
<span class="go">7    7    7    7</span>
<span class="go">9    9    9    9</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.index">
<code class="descname">index</code><a class="headerlink" href="#cudf.dataframe.DataFrame.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the DataFrame</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.iteritems">
<code class="descname">iteritems</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over column names and series pairs</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>self</em>, <em>other</em>, <em>on=None</em>, <em>how='left'</em>, <em>lsuffix=''</em>, <em>rsuffix=''</em>, <em>sort=False</em>, <em>type=''</em>, <em>method='hash'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join columns with other DataFrame on index or on a key column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>how</strong><span class="classifier">str</span></dt><dd><p>Only accepts “left”, “right”, “inner”, “outer”</p>
</dd>
<dt><strong>lsuffix, rsuffix</strong><span class="classifier">str</span></dt><dd><p>The suffices to add to the left (<em>lsuffix</em>) and right (<em>rsuffix</em>)
column names when avoiding conflicts.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool</span></dt><dd><p>Set to True to ensure sorted ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>joined</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Difference from pandas:</p>
<ul class="simple">
<li><p><em>other</em> must be a single DataFrame for now.</p></li>
<li><p><em>on</em> is not supported yet due to lack of multi-index support.</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.label_encoding">
<code class="descname">label_encoding</code><span class="sig-paren">(</span><em>self</em>, <em>column</em>, <em>prefix</em>, <em>cats</em>, <em>prefix_sep='_'</em>, <em>dtype=None</em>, <em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode labels in a column with label encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">str</span></dt><dd><p>the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>the new column name prefix.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">sequence of ints</span></dt><dd><p>the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str</span></dt><dd><p>the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt><dd><p>the dtype for the outputs; see Series.label_encoding</p>
</dd>
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>a new dataframe with a new column append for the coded values.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.loc">
<code class="descname">loc</code><a class="headerlink" href="#cudf.dataframe.DataFrame.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a label-based indexer for row-slicing and column selection.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))])</span>
</pre></div>
</div>
<p>Get the row by index label from ‘a’ and ‘b’ columns</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]</span>
<span class="go">a    0</span>
<span class="go">b    0</span>
</pre></div>
</div>
<p>Get rows from index 2 to index 5 from ‘a’ and ‘b’ columns.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]</span>
<span class="go">   a  b</span>
<span class="go">2  2  2</span>
<span class="go">3  3  3</span>
<span class="go">4  4  4</span>
<span class="go">5  5  5</span>
</pre></div>
</div>
<p>Get the every 3rd rows from index 2 to 10 from ‘a’ and ‘b’</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]</span>
<span class="go">    a    b</span>
<span class="go">2   2    2</span>
<span class="go">5   5    5</span>
<span class="go">8   8    8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>skipna=None</em>, <em>level=None</em>, <em>numeric_only=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the values for the requested axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{index (0), columns (1)}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to
use everything, then use only numeric data. Not implemented for
Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mean</strong><span class="classifier">Series or DataFrame (if level specified)</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.melt">
<code class="descname">melt</code><span class="sig-paren">(</span><em>self</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.
default: None</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot.
default: all columns that are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the <cite>variable</cite> column.
default: frame.columns.name or ‘variable’</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">str</span></dt><dd><p>Name to use for the <cite>value</cite> column.
default: ‘value’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>Melted result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>self</em>, <em>right</em>, <em>on=None</em>, <em>how='inner'</em>, <em>left_on=None</em>, <em>right_on=None</em>, <em>left_index=False</em>, <em>right_index=False</em>, <em>lsuffix=None</em>, <em>rsuffix=None</em>, <em>type=''</em>, <em>method='hash'</em>, <em>indicator=False</em>, <em>suffixes=('_x'</em>, <em>'_y')</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge GPU DataFrame objects by performing a database-style join
operation by columns or indexes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>right</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>on</strong><span class="classifier">label or list; defaults to None</span></dt><dd><p>Column or index level names to join on. These must be found in
both DataFrames.</p>
<p>If on is None and not merging on indexes then
this defaults to the intersection of the columns
in both DataFrames.</p>
</dd>
<dt><strong>left_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the left DataFrame.
Can also be an array or list of arrays of the length of the
left DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>right_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the right DataFrame.
Can also be an array or list of arrays of the length of the
right DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>left_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the left DataFrame as the join key(s).</p>
</dd>
<dt><strong>right_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the right DataFrame as the join key.</p>
</dd>
<dt><strong>how</strong><span class="classifier">str, defaults to ‘left’</span></dt><dd><p>Only accepts ‘left’
left: use only keys from left frame, similar to
a SQL left outer join; preserve key order</p>
</dd>
<dt><strong>suffixes: Tuple[str, str], defaults to (‘_x’, ‘_y’)</strong></dt><dd><p>Suffixes applied to overlapping column names on the left and right
sides</p>
</dd>
<dt><strong>type</strong><span class="classifier">str, defaults to ‘hash’</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>merged</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">&#39;vals_a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;vals_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span> <span class="o">=</span> <span class="n">df_a</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_b</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">   key  vals_a  vals_b</span>
<span class="go">3    0    10.0</span>
<span class="go">0    1    11.0    10.0</span>
<span class="go">1    2    12.0    11.0</span>
<span class="go">4    3    13.0</span>
<span class="go">2    4    14.0    12.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#cudf.dataframe.DataFrame.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the data. DataFrame ndim is always 2.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.nlargest">
<code class="descname">nlargest</code><span class="sig-paren">(</span><em>self</em>, <em>n</em>, <em>columns</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p>
<p class="rubric">Notes</p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.nsmallest">
<code class="descname">nsmallest</code><span class="sig-paren">(</span><em>self</em>, <em>n</em>, <em>columns</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.one_hot_encoding">
<code class="descname">one_hot_encoding</code><span class="sig-paren">(</span><em>self</em>, <em>column</em>, <em>prefix</em>, <em>cats</em>, <em>prefix_sep='_'</em>, <em>dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a column with one-hot-encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">str</span></dt><dd><p>the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>the new column name prefix.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">sequence of ints</span></dt><dd><p>the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str</span></dt><dd><p>the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt><dd><p>the dtype for the outputs; defaults to float64.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a new dataframe with new columns append for each category.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_owner</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;pet_owner&#39;</span><span class="p">:</span> <span class="n">pet_owner</span><span class="p">,</span> <span class="s1">&#39;pet_type&#39;</span><span class="p">:</span> <span class="n">pet_type</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">pet_type</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a column with numerically encoded category values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Create the list of category codes to use in the encoding</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">pet_codes</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">one_hot_encoding</span><span class="p">(</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">,</span> <span class="s1">&#39;pet_dummy&#39;</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">  pet_owner  pet_type  pet_codes  pet_dummy_0  pet_dummy_1  pet_dummy_2</span>
<span class="go">0         1      fish          2          0.0          0.0          1.0</span>
<span class="go">1         2       dog          1          0.0          1.0          0.0</span>
<span class="go">2         3      fish          2          0.0          0.0          1.0</span>
<span class="go">3         4      bird          0          1.0          0.0          0.0</span>
<span class="go">4         5      fish          2          0.0          0.0          1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.partition_by_hash">
<code class="descname">partition_by_hash</code><span class="sig-paren">(</span><em>self</em>, <em>columns</em>, <em>nparts</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.partition_by_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>The names of the columns to be hashed.
Must have at least one name.</p>
</dd>
<dt><strong>nparts</strong><span class="classifier">int</span></dt><dd><p>Number of output partitions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>partitioned: list of DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>self</em>, <em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a column and drop it from the DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>self</em>, <em>q=0.5</em>, <em>interpolation='linear'</em>, <em>columns=None</em>, <em>exact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>q</strong><span class="classifier">float or array-like</span></dt><dd><p>0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{<cite>linear</cite>, <cite>lower</cite>, <cite>higher</cite>, <cite>midpoint</cite>, <cite>nearest</cite>}</span></dt><dd><p>This  parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j.
Default ‘linear’.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use approximate or exact quantile algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.query">
<code class="descname">query</code><span class="sig-paren">(</span><em>self</em>, <em>expr</em>, <em>local_dict={}</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Query with a boolean expression using Numba to compile a GPU kernel.</p>
<p>See pandas.DataFrame.query.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>expr</strong><span class="classifier">str</span></dt><dd><p>A boolean expression. Names in expression refer to columns.</p>
<p>Names starting with <cite>&#64;</cite> refer to Python variables</p>
</dd>
<dt><strong>local_dict</strong><span class="classifier">dict</span></dt><dd><p>Containing the local variable to be used in query.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;(a == 2 and b == 4) or (b == 3)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
</pre></div>
</div>
<p>DateTime conditionals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;2018-10-07&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-10-08&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetimes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-08&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;datetimes==@search_date&#39;</span><span class="p">))</span>
<span class="go">                datetimes</span>
<span class="go">1 2018-10-08T00:00:00.000</span>
</pre></div>
</div>
<p>Using local_dict:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;2018-10-07&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-10-08&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetimes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_date2</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-08&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;datetimes==@search_date&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">local_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;search_date&#39;</span><span class="p">:</span><span class="n">search_date2</span><span class="p">}))</span>
<span class="go">                datetimes</span>
<span class="go">1 2018-10-08T00:00:00.000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.rename">
<code class="descname">rename</code><span class="sig-paren">(</span><em>self</em>, <em>mapper=None</em>, <em>columns=None</em>, <em>copy=True</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter column labels.</p>
<p>Function / dict values must be unique (1-to-1). Labels not contained in
a dict / Series will be left as-is. Extra labels listed don’t throw an
error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapper, columns</strong><span class="classifier">dict-like or function, optional</span></dt><dd><p>dict-like or functions transformations to apply to
the column axis’ values.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd><p>Also copy underlying data</p>
</dd>
<dt><strong>inplace: boolean, default False</strong></dt><dd><p>Retrun new DataFrame.  If True, assign columns without copy</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Support axis=’columns’ only.</p></li>
<li><p>Not supporting: index, level</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>self</em>, <em>to_replace</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <em>to_replace</em> with <em>value</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>to_replace</strong><span class="classifier">numeric, str, list-like or dict</span></dt><dd><p>Value(s) to replace.</p>
<ul>
<li><p>numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>values equal to <em>to_replace</em> will be replaced
with <em>value</em></p></li>
</ul>
</div></blockquote>
</li>
<li><p>list of numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <em>value</em> is also list-like,
<em>to_replace</em> and <em>value</em> must be of same length.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>dict:</p>
<blockquote>
<div><ul class="simple">
<li><p>Dicts can be used to replace different values in different
columns. For example, <cite>{‘a’: 1, ‘z’: 2}</cite> specifies that the
value 1 in column <cite>a</cite> and the value 2 in column <cite>z</cite> should be
replaced with value*.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>value</strong><span class="classifier">numeric, str, list-like, or dict</span></dt><dd><p>Value(s) to replace <cite>to_replace</cite> with. If a dict is provided, then
its keys must match the keys in <em>to_replace</em>, and correponding
values must be compatible (e.g., if they are lists, then they must
match in length).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd><p>DataFrame after replacement.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.select_dtypes">
<code class="descname">select_dtypes</code><span class="sig-paren">(</span><em>self</em>, <em>include=None</em>, <em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.select_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>include</strong><span class="classifier">str or list</span></dt><dd><p>which columns to include based on dtypes</p>
</dd>
<dt><strong>exclude</strong><span class="classifier">str or list</span></dt><dd><p>which columns to exclude based on dtypes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.set_index">
<code class="descname">set_index</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame with a new index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible, or str</span></dt><dd><p>Index : the new index.
Series-convertible : values for the new index.
str : name of column to be used as series</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.shape">
<code class="descname">shape</code><a class="headerlink" href="#cudf.dataframe.DataFrame.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.sort_index">
<code class="descname">sort_index</code><span class="sig-paren">(</span><em>self</em>, <em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.sort_values">
<code class="descname">sort_values</code><span class="sig-paren">(</span><em>self</em>, <em>by</em>, <em>ascending=True</em>, <em>na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values row-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">str or list of str</span></dt><dd><p>Name or list of names to sort by.</p>
</dd>
<dt><strong>ascending</strong><span class="classifier">bool or list of bool, default True</span></dt><dd><p>Sort ascending vs. descending. Specify list for multiple sort
orders. If this is a list of bools, must match the length of the
by.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>sorted_obj</strong><span class="classifier">cuDF DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Support axis=’index’ only.</p></li>
<li><p>Not supporting: inplace, kind</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  0 -3</span>
<span class="go">2  2  0</span>
<span class="go">1  1  2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.tail">
<code class="descname">tail</code><span class="sig-paren">(</span><em>self</em>, <em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_arrow">
<code class="descname">to_arrow</code><span class="sig-paren">(</span><em>self</em>, <em>preserve_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a PyArrow Table.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span>
<span class="go">pyarrow.Table</span>
<span class="go">None: int64</span>
<span class="go">a: int64</span>
<span class="go">b: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_dlpack">
<code class="descname">to_dlpack</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_feather">
<code class="descname">to_feather</code><span class="sig-paren">(</span><em>self</em>, <em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_gpu_matrix">
<code class="descname">to_gpu_matrix</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numba gpu ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numba gpu ndarray</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_hdf">
<code class="descname">to_hdf</code><span class="sig-paren">(</span><em>self</em>, <em>path_or_buf</em>, <em>key</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,</p></li>
</ul>
<p>nor searchable.
- ‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather..to_feather</span></code></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><em>self</em>, <em>path_or_buf=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.
* Series</p>
<blockquote>
<div><ul class="simple">
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>DataFrame</dt><dd><ul class="simple">
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:</p></li>
</ul>
<p>{‘split’,’records’,’index’,’columns’,’values’,’table’}</p>
</dd>
</dl>
</li>
<li><dl>
<dt>The format of the JSON string</dt><dd><ul class="simple">
<li><p>‘split’ : dict like {‘index’ -&gt; [index],</p></li>
</ul>
<p>‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}
- ‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]
- ‘index’ : dict like {index -&gt; {column -&gt; value}}
- ‘columns’ : dict like {column -&gt; {index -&gt; value}}
- ‘values’ : just the values array
- ‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
<dt><strong>See Also</strong></dt><dd></dd>
<dt><strong>——–</strong></dt><dd></dd>
<dt><strong>.cudf.io.json.read_json</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_pandas">
<code class="descname">to_pandas</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas DataFrame.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_parquet">
<code class="descname">to_parquet</code><span class="sig-paren">(</span><em>self</em>, <em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt><dd><p>Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong><span class="classifier">list, optional, default None</span></dt><dd><p>Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_records">
<code class="descname">to_records</code><span class="sig-paren">(</span><em>self</em>, <em>index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numpy recarray</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool</span></dt><dd><p>Whether to include the index in the output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy recarray</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>self</em>, <em>nrows=NOTSET</em>, <em>ncols=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nrows</strong><span class="classifier">int</span></dt><dd><p>Maximum number of rows to show.
If it is None, all rows are shown.</p>
</dd>
<dt><strong>ncols</strong><span class="classifier">int</span></dt><dd><p>Maximum number of columns to show.
If it is None, all columns are shown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
<span class="go">&#39;   key   val\n0    0  10.0\n1    1  11.0\n2    2  12.0&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose index and columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>a new (ncol x nrow) dataframe. self is (nrow x ncol)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Difference from pandas:
Not supporting <em>copy</em> because default and only behaviour is copy=True</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cudf.multi"></span><dl class="function">
<dt id="cudf.multi.concat">
<code class="descclassname">cudf.multi.</code><code class="descname">concat</code><span class="sig-paren">(</span><em>objs</em>, <em>axis=0</em>, <em>ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.multi.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate DataFrames, Series, or Indices row-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>objs</strong><span class="classifier">list of DataFrame, Series, or Index</span></dt><dd></dd>
<dt><strong>axis</strong><span class="classifier">concatenation axis, 0 - index, 1 - columns</span></dt><dd></dd>
<dt><strong>ignore_index</strong><span class="classifier">bool</span></dt><dd><p>Set True to ignore the index of the <em>objs</em> and provide a
default range index instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new object of like type with rows from each object in <code class="docutils literal notranslate"><span class="pre">objs</span></code>.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cudf.reshape.general"></span><dl class="function">
<dt id="cudf.reshape.general.melt">
<code class="descclassname">cudf.reshape.general.</code><code class="descname">melt</code><span class="sig-paren">(</span><em>frame</em>, <em>id_vars=None</em>, <em>value_vars=None</em>, <em>var_name=None</em>, <em>value_name='value'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.
default: None</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot.
default: all columns that are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the <cite>variable</cite> column.
default: frame.columns.name or ‘variable’</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">str</span></dt><dd><p>Name to use for the <cite>value</cite> column.
default: ‘value’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>Melted result</p>
</dd>
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Does not support ‘col_level’ because cuDF does not have multi-index</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="n">value_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="go">     A    B variable value</span>
<span class="go">0    1    1        C   1.0</span>
<span class="go">1    1    3        C</span>
<span class="go">2    5    6        C   4.0</span>
<span class="go">3    1    1        D   2.0</span>
<span class="go">4    1    3        D   5.0</span>
<span class="go">5    5    6        D   6.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.dataframe.series.Series">
<em class="property">class </em><code class="descclassname">cudf.dataframe.series.</code><code class="descname">Series</code><span class="sig-paren">(</span><em>data=None</em>, <em>index=None</em>, <em>name=None</em>, <em>nan_as_null=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series" title="Permalink to this definition">¶</a></dt>
<dd><p>Data and null-masks.</p>
<p><code class="docutils literal notranslate"><span class="pre">Series</span></code> objects are used as columns of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cat</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.data" title="cudf.dataframe.series.Series.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a></dt><dd><p>The gpu buffer for the data</p>
</dd>
<dt><strong>dt</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.dtype" title="cudf.dataframe.series.Series.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p>dtype of the Series</p>
</dd>
<dt><strong>empty</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.has_null_mask" title="cudf.dataframe.series.Series.has_null_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_null_mask</span></code></a></dt><dd><p>A boolean indicating whether a null-mask is needed</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.iloc" title="cudf.dataframe.series.Series.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt><dd><p>For integer-location based selection.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.index" title="cudf.dataframe.series.Series.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt><dd><p>The index object</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.ndim" title="cudf.dataframe.series.Series.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>Dimension of the data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.null_count" title="cudf.dataframe.series.Series.null_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">null_count</span></code></a></dt><dd><p>Number of null values</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.nullmask" title="cudf.dataframe.series.Series.nullmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nullmask</span></code></a></dt><dd><p>The gpu buffer for the null-mask</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.shape" title="cudf.dataframe.series.Series.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd>
<dt><strong>str</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.valid_count" title="cudf.dataframe.series.Series.valid_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">valid_count</span></code></a></dt><dd><p>Number of non-null values</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.abs" title="cudf.dataframe.series.Series.abs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a>(self)</p></td>
<td><p>Absolute value of each element of the series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.append" title="cudf.dataframe.series.Series.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(self, arbitrary)</p></td>
<td><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.applymap" title="cudf.dataframe.series.Series.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">applymap</span></code></a>(self, udf[, out_dtype])</p></td>
<td><p>Apply a elemenwise function to transform the values in the Column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.argsort" title="cudf.dataframe.series.Series.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>(self[, ascending, na_position])</p></td>
<td><p>Returns a Series of int64 index that will sort the series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.as_mask" title="cudf.dataframe.series.Series.as_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_mask</span></code></a>(self)</p></td>
<td><p>Convert booleans to bitmask</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.astype" title="cudf.dataframe.series.Series.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(self, dtype)</p></td>
<td><p>Convert to the given <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.ceil" title="cudf.dataframe.series.Series.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>(self)</p></td>
<td><p>Rounds each value upward to the smallest integral value not less than the original.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.count" title="cudf.dataframe.series.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(self[, axis, skipna])</p></td>
<td><p>The number of non-null values</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.cummax" title="cudf.dataframe.series.Series.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummax</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative maximum of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.cummin" title="cudf.dataframe.series.Series.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummin</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative minimum of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.cumprod" title="cudf.dataframe.series.Series.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative product of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.cumsum" title="cudf.dataframe.series.Series.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative sum of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.describe" title="cudf.dataframe.series.Series.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">describe</span></code></a>(self[, percentiles, include, exclude])</p></td>
<td><p>Compute summary statistics of a Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.diff" title="cudf.dataframe.series.Series.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>(self[, periods])</p></td>
<td><p>Calculate the difference between values at positions i and i - N in an array and store the output in a new array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.digitize" title="cudf.dataframe.series.Series.digitize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">digitize</span></code></a>(self, bins[, right])</p></td>
<td><p>Return the indices of the bins to which each value in series belongs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.factorize" title="cudf.dataframe.series.Series.factorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorize</span></code></a>(self[, na_sentinel])</p></td>
<td><p>Encode the input values as integer labels</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.fillna" title="cudf.dataframe.series.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(self, value[, method, axis, inplace, …])</p></td>
<td><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.find_first_value" title="cudf.dataframe.series.Series.find_first_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_first_value</span></code></a>(self, value)</p></td>
<td><p>Returns offset of first value that matches</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.find_last_value" title="cudf.dataframe.series.Series.find_last_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_last_value</span></code></a>(self, value)</p></td>
<td><p>Returns offset of last value that matches</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.floor" title="cudf.dataframe.series.Series.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>(self)</p></td>
<td><p>Rounds each value downward to the largest integral value not greater than the original.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.from_categorical" title="cudf.dataframe.series.Series.from_categorical"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_categorical</span></code></a>(categorical[, codes])</p></td>
<td><p>Creates from a pandas.Categorical</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.from_masked_array" title="cudf.dataframe.series.Series.from_masked_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_masked_array</span></code></a>(data, mask[, null_count])</p></td>
<td><p>Create a Series with null-mask.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.hash_encode" title="cudf.dataframe.series.Series.hash_encode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_encode</span></code></a>(self, stop[, use_name])</p></td>
<td><p>Encode column values as ints in [0, stop) using hash function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.hash_values" title="cudf.dataframe.series.Series.hash_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_values</span></code></a>(self)</p></td>
<td><p>Compute the hash of values in this column.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.isna" title="cudf.dataframe.series.Series.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isna</span></code></a>(self)</p></td>
<td><p>Identify missing values in a Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.isnull" title="cudf.dataframe.series.Series.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnull</span></code></a>(self)</p></td>
<td><p>Identify missing values in a Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.label_encoding" title="cudf.dataframe.series.Series.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(self, cats[, dtype, na_sentinel])</p></td>
<td><p>Perform label encoding</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.masked_assign" title="cudf.dataframe.series.Series.masked_assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_assign</span></code></a>(self, value, mask)</p></td>
<td><p>Assign a scalar value to a series using a boolean mask df[df &lt; 0] = 0</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.max" title="cudf.dataframe.series.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the max of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.mean" title="cudf.dataframe.series.Series.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the mean of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.mean_var" title="cudf.dataframe.series.Series.mean_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_var</span></code></a>(self[, ddof])</p></td>
<td><p>Compute mean and variance at the same time.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.min" title="cudf.dataframe.series.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the min of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.nlargest" title="cudf.dataframe.series.Series.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(self[, n, keep])</p></td>
<td><p>Returns a new Series of the <em>n</em> largest element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.notna" title="cudf.dataframe.series.Series.notna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">notna</span></code></a>(self)</p></td>
<td><p>Identify non-missing values in a Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.nsmallest" title="cudf.dataframe.series.Series.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(self[, n, keep])</p></td>
<td><p>Returns a new Series of the <em>n</em> smallest element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.nunique" title="cudf.dataframe.series.Series.nunique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nunique</span></code></a>(self[, method, dropna])</p></td>
<td><p>Returns the number of unique values of the Series: approximate version, and exact version to be moved to libgdf</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.one_hot_encoding" title="cudf.dataframe.series.Series.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(self, cats[, dtype])</p></td>
<td><p>Perform one-hot-encoding</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.product" title="cudf.dataframe.series.Series.product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">product</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the product of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.quantile" title="cudf.dataframe.series.Series.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(self, q[, interpolation, exact, …])</p></td>
<td><p>Return values at the given quantile.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.rename" title="cudf.dataframe.series.Series.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(self[, index, copy])</p></td>
<td><p>Alter Series name.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.replace" title="cudf.dataframe.series.Series.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(self, to_replace, value)</p></td>
<td><p>Replace values given in <em>to_replace</em> with <em>value</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.reset_index" title="cudf.dataframe.series.Series.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_index</span></code></a>(self[, drop])</p></td>
<td><p>Reset index to RangeIndex</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.reverse" title="cudf.dataframe.series.Series.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>(self)</p></td>
<td><p>Reverse the Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.scale" title="cudf.dataframe.series.Series.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a>(self)</p></td>
<td><p>Scale values to [0, 1] in float64</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.set_index" title="cudf.dataframe.series.Series.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(self, index)</p></td>
<td><p>Returns a new Series with a different index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.set_mask" title="cudf.dataframe.series.Series.set_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_mask</span></code></a>(self, mask[, null_count])</p></td>
<td><p>Create new Series by setting a mask array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.shift" title="cudf.dataframe.series.Series.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shift</span></code></a>(self[, periods, freq, axis, fill_value])</p></td>
<td><p>Shift values of an input array by periods positions and store the output in a new array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.sort_index" title="cudf.dataframe.series.Series.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>(self[, ascending])</p></td>
<td><p>Sort by the index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.sort_values" title="cudf.dataframe.series.Series.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(self[, ascending, na_position])</p></td>
<td><p>Sort by the values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.std" title="cudf.dataframe.series.Series.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>(self[, ddof, axis, skipna])</p></td>
<td><p>Compute the standard deviation of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.sum" title="cudf.dataframe.series.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the sum of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.tail" title="cudf.dataframe.series.Series.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>(self[, n])</p></td>
<td><p>Returns the last n rows as a new Series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.take" title="cudf.dataframe.series.Series.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(self, indices[, ignore_index])</p></td>
<td><p>Return Series by taking values from the corresponding <em>indices</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.to_array" title="cudf.dataframe.series.Series.to_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numpy array for the data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.to_dlpack" title="cudf.dataframe.series.Series.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>(self)</p></td>
<td><p>Converts a cuDF object into a DLPack tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.to_frame" title="cudf.dataframe.series.Series.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_frame</span></code></a>(self[, name])</p></td>
<td><p>Convert Series into a DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.to_gpu_array" title="cudf.dataframe.series.Series.to_gpu_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numba device array for the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.to_hdf" title="cudf.dataframe.series.Series.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(self, path_or_buf, key, \*args, …)</p></td>
<td><p>Write the contained data to an HDF5 file using HDFStore.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.to_json" title="cudf.dataframe.series.Series.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>(self[, path_or_buf])</p></td>
<td><p>Convert the cuDF object to a JSON string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.to_string" title="cudf.dataframe.series.Series.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>(self[, nrows])</p></td>
<td><p>Convert to string</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.unique" title="cudf.dataframe.series.Series.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>(self[, method, sort])</p></td>
<td><p>Returns unique values of this Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.value_counts" title="cudf.dataframe.series.Series.value_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">value_counts</span></code></a>(self[, method, sort])</p></td>
<td><p>Returns unique values of this Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.values_to_string" title="cudf.dataframe.series.Series.values_to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values_to_string</span></code></a>(self[, nrows])</p></td>
<td><p>Returns a list of string for each element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.dataframe.series.Series.var" title="cudf.dataframe.series.Series.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>(self[, ddof, axis, skipna])</p></td>
<td><p>Compute the variance of the series</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 64%" />
<col style="width: 36%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>acos</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>as_index</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>asin</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>atan</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>copy</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>cos</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>deserialize</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>equals</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>exp</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>from_arrow</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>from_pandas</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>groupby</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>head</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>log</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>serialize</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>sin</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>sqrt</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>sum_of_squares</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>tan</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_arrow</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>to_pandas</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>unique_k</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.dataframe.series.Series.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute value of each element of the series.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>self</em>, <em>arbitrary</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.
Returns a new copy with the index resetted.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.applymap">
<code class="descname">applymap</code><span class="sig-paren">(</span><em>self</em>, <em>udf</em>, <em>out_dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.applymap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a elemenwise function to transform the values in the Column.</p>
<p>The user function is expected to take one argument and return the
result, which will be stored to the output Series.  The function
cannot reference globals except for other simple scalar objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>udf</strong><span class="classifier">function</span></dt><dd><p>Wrapped by <code class="docutils literal notranslate"><span class="pre">numba.cuda.jit</span></code> for call on the GPU as a device
function.</p>
</dd>
<dt><strong>out_dtype</strong><span class="classifier">numpy.dtype; optional</span></dt><dd><p>The dtype for use in the output.
By default, the result will have the same dtype as the source.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>The mask and index are preserved.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><em>self</em>, <em>ascending=True</em>, <em>na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Series of int64 index that will sort the series.</p>
<p>Uses Thrust sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>result: Series</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.as_mask">
<code class="descname">as_mask</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.as_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert booleans to bitmask</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>device array</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>self</em>, <em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to the given <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>If the dtype changed, a new <code class="docutils literal notranslate"><span class="pre">Series</span></code> is returned by casting each</dt><dd></dd>
<dt>values to the given dtype.</dt><dd></dd>
<dt>If the dtype is not changed, <code class="docutils literal notranslate"><span class="pre">self</span></code> is returned.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.ceil">
<code class="descname">ceil</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value upward to the smallest integral value not less
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of non-null values</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.cummax">
<code class="descname">cummax</code><span class="sig-paren">(</span><em>self</em>, <em>axis=0</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.cummax" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative maximum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.cummin">
<code class="descname">cummin</code><span class="sig-paren">(</span><em>self</em>, <em>axis=0</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.cummin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative minimum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.cumprod">
<code class="descname">cumprod</code><span class="sig-paren">(</span><em>self</em>, <em>axis=0</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative product of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.cumsum">
<code class="descname">cumsum</code><span class="sig-paren">(</span><em>self</em>, <em>axis=0</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative sum of the series</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.data">
<code class="descname">data</code><a class="headerlink" href="#cudf.dataframe.series.Series.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the data</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.describe">
<code class="descname">describe</code><span class="sig-paren">(</span><em>self</em>, <em>percentiles=None</em>, <em>include=None</em>, <em>exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute summary statistics of a Series. For numeric
data, the output includes the minimum, maximum, mean, median,
standard deviation, and various quantiles. For object data, the output
includes the count, number of unique values, the most common value, and
the number of occurrences of the most common value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like, optional</span></dt><dd><p>The percentiles used to generate the output summary statistics.
If None, the default percentiles used are the 25th, 50th and 75th.
Values should be within the interval [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A DataFrame containing summary statistics of relevant columns from</dt><dd></dd>
<dt>the input DataFrame.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">Series</span></code> containing numeric values.
&gt;&gt;&gt; import cudf
&gt;&gt;&gt; s = cudf.Series([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
&gt;&gt;&gt; print(s.describe())</p>
<blockquote>
<div><p>stats   values</p>
</div></blockquote>
<p>0  count     10.0
1   mean      5.5
2    std  3.02765
3    min      1.0
4    25%      2.5
5    50%      5.5
6    75%      7.5
7    max     10.0</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.diff">
<code class="descname">diff</code><span class="sig-paren">(</span><em>self</em>, <em>periods=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between values at positions i and i - N in
an array and store the output in a new array.
Notes
—–
Diff currently only supports float and integer dtype columns with
no null values.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.digitize">
<code class="descname">digitize</code><span class="sig-paren">(</span><em>self</em>, <em>bins</em>, <em>right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.digitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the bins to which each value in series belongs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bins</strong><span class="classifier">np.array</span></dt><dd><p>1-D monotonically, increasing array with same type as this series.</p>
</dd>
<dt><strong>right</strong><span class="classifier">bool</span></dt><dd><p>Indicates whether interval contains the right or left bin edge.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new Series containing the indices.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Monotonicity of bins is assumed and not checked.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#cudf.dataframe.series.Series.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>dtype of the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.factorize">
<code class="descname">factorize</code><span class="sig-paren">(</span><em>self</em>, <em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.factorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the input values as integer labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(labels, cats)</strong><span class="classifier">(Series, Series)</span></dt><dd><ul class="simple">
<li><p><em>labels</em> contains the encoded values</p></li>
<li><p><em>cats</em> contains the categories in order that the N-th
item corresponds to the (N-1) code.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.fillna">
<code class="descname">fillna</code><span class="sig-paren">(</span><em>self</em>, <em>value</em>, <em>method=None</em>, <em>axis=None</em>, <em>inplace=False</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar or Series-like</span></dt><dd><p>Value to use to fill nulls. If Series-like, null values
are filled with the values in corresponding indices of the
given Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>Copy with nulls filled.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.find_first_value">
<code class="descname">find_first_value</code><span class="sig-paren">(</span><em>self</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.find_first_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of first value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.find_last_value">
<code class="descname">find_last_value</code><span class="sig-paren">(</span><em>self</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.find_last_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of last value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.floor">
<code class="descname">floor</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value downward to the largest integral value not greater
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.series.Series.from_categorical">
<em class="property">classmethod </em><code class="descname">from_categorical</code><span class="sig-paren">(</span><em>categorical</em>, <em>codes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.from_categorical" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates from a pandas.Categorical</p>
<p>If <code class="docutils literal notranslate"><span class="pre">codes</span></code> is defined, use it instead of <code class="docutils literal notranslate"><span class="pre">categorical.codes</span></code></p>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.series.Series.from_masked_array">
<em class="property">classmethod </em><code class="descname">from_masked_array</code><span class="sig-paren">(</span><em>data</em>, <em>mask</em>, <em>null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.from_masked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Series with null-mask.
This is equivalent to:</p>
<blockquote>
<div><p>Series(data).set_mask(mask, null_count=null_count)</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">1D array-like</span></dt><dd><p>The values.  Null values must not be skipped.  They can appear
as garbage values.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">1D array-like of numpy.uint8</span></dt><dd><p>The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong><span class="classifier">int, optional</span></dt><dd><p>The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.has_null_mask">
<code class="descname">has_null_mask</code><a class="headerlink" href="#cudf.dataframe.series.Series.has_null_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean indicating whether a null-mask is needed</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.hash_encode">
<code class="descname">hash_encode</code><span class="sig-paren">(</span><em>self</em>, <em>stop</em>, <em>use_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.hash_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode column values as ints in [0, stop) using hash function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stop</strong><span class="classifier">int</span></dt><dd><p>The upper bound on the encoding range.</p>
</dd>
<dt><strong>use_name</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> then combine hashed column values
with hashed column name. This is useful for when the same
values in different columns should be encoded
with different hashed values.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>result: Series</strong></dt><dd><p>The encoded Series.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.hash_values">
<code class="descname">hash_values</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.hash_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hash of values in this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.iloc">
<code class="descname">iloc</code><a class="headerlink" href="#cudf.dataframe.series.Series.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>For integer-location based selection.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series containing the elements corresponding to the indices</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span>
</pre></div>
</div>
<p>Get the value from 1st index</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Get the values from 0,2,9 and 18th index</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
<span class="go"> 0    0</span>
<span class="go"> 2    2</span>
<span class="go"> 9    9</span>
<span class="go">18   18</span>
</pre></div>
</div>
<p>Get the values using slice indices</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">3    3</span>
<span class="go">5    5</span>
<span class="go">7    7</span>
<span class="go">9    9</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.index">
<code class="descname">index</code><a class="headerlink" href="#cudf.dataframe.series.Series.index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index object</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.isna">
<code class="descname">isna</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.isna" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify missing values in a Series. Alias for isnull.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.isnull">
<code class="descname">isnull</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.isnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify missing values in a Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.label_encoding">
<code class="descname">label_encoding</code><span class="sig-paren">(</span><em>self</em>, <em>cats</em>, <em>dtype=None</em>, <em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform label encoding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">sequence of input values</span></dt><dd></dd>
<dt><strong>dtype: numpy.dtype; optional</strong></dt><dd><p>Specifies the output dtype.  If <cite>None</cite> is given, the
smallest possible integer dtype (starting with np.int32)
is used.</p>
</dd>
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>A sequence of encoded labels with value between 0 and n-1 classes(cats)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.masked_assign">
<code class="descname">masked_assign</code><span class="sig-paren">(</span><em>self</em>, <em>value</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.masked_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign a scalar value to a series using a boolean mask
df[df &lt; 0] = 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar</span></dt><dd><p>scalar value for assignment</p>
</dd>
<dt><strong>mask</strong><span class="classifier">cudf Series</span></dt><dd><p>Boolean Series</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>cudf Series</dt><dd><p>cudf series with new value set to where mask is True</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>skipna=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>skipna=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.mean_var">
<code class="descname">mean_var</code><span class="sig-paren">(</span><em>self</em>, <em>ddof=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.mean_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance at the same time.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>skipna=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the min of the series</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#cudf.dataframe.series.Series.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the data. Series ndim is always 1.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.nlargest">
<code class="descname">nlargest</code><span class="sig-paren">(</span><em>self</em>, <em>n=5</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> largest element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.notna">
<code class="descname">notna</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.notna" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify non-missing values in a Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.nsmallest">
<code class="descname">nsmallest</code><span class="sig-paren">(</span><em>self</em>, <em>n=5</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> smallest element.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.null_count">
<code class="descname">null_count</code><a class="headerlink" href="#cudf.dataframe.series.Series.null_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of null values</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.nullmask">
<code class="descname">nullmask</code><a class="headerlink" href="#cudf.dataframe.series.Series.nullmask" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the null-mask</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.nunique">
<code class="descname">nunique</code><span class="sig-paren">(</span><em>self</em>, <em>method='sort'</em>, <em>dropna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.nunique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of unique values of the Series: approximate version,
and exact version to be moved to libgdf</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.one_hot_encoding">
<code class="descname">one_hot_encoding</code><span class="sig-paren">(</span><em>self</em>, <em>cats</em>, <em>dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one-hot-encoding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cats</strong><span class="classifier">sequence of values</span></dt><dd><p>values representing each category.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy.dtype</span></dt><dd><p>specifies the output dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A sequence of new series for each category.  Its length is determined</dt><dd></dd>
<dt>by the length of <code class="docutils literal notranslate"><span class="pre">cats</span></code>.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.product">
<code class="descname">product</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>skipna=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the product of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>self</em>, <em>q</em>, <em>interpolation='linear'</em>, <em>exact=True</em>, <em>quant_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">float or array-like, default 0.5 (50% quantile)</span></dt><dd><p>0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{’linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt><dd><p>This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j:</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use approximate or exact quantile algorithm.</p>
</dd>
<dt><strong>quant_index</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use the list of quantiles as index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.rename">
<code class="descname">rename</code><span class="sig-paren">(</span><em>self</em>, <em>index=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter Series name.</p>
<p>Change Series.name with a scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Scalar, optional</span></dt><dd><p>Scalar to alter the Series.name attribute</p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd><p>Also copy underlying data</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Supports scalar values only for changing name attribute</p></li>
<li><p>Not supporting: inplace, level</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>self</em>, <em>to_replace</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <em>to_replace</em> with <em>value</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>to_replace</strong><span class="classifier">numeric, str or list-like</span></dt><dd><p>Value(s) to replace.</p>
<ul>
<li><p>numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>values equal to <em>to_replace</em> will be replaced with <em>value</em></p></li>
</ul>
</div></blockquote>
</li>
<li><p>list of numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <em>value</em> is also list-like, <em>to_replace</em> and <em>value</em> must</p></li>
</ul>
<p>be of same length.</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>value</strong><span class="classifier">numeric, str, list-like, or dict</span></dt><dd><p>Value(s) to replace <cite>to_replace</cite> with.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>Series after replacement. The mask and index are preserved.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.dataframe.series.Series.fillna" title="cudf.dataframe.series.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.fillna</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.reset_index">
<code class="descname">reset_index</code><span class="sig-paren">(</span><em>self</em>, <em>drop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset index to RangeIndex</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale values to [0, 1] in float64</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.set_index">
<code class="descname">set_index</code><span class="sig-paren">(</span><em>self</em>, <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series with a different index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible</span></dt><dd><p>the new index or values for the new index</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.set_mask">
<code class="descname">set_mask</code><span class="sig-paren">(</span><em>self</em>, <em>mask</em>, <em>null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new Series by setting a mask array.</p>
<p>This will override the existing mask.  The returned Series will
reference the same data buffer as this Series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">1D array-like of numpy.uint8</span></dt><dd><p>The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong><span class="classifier">int, optional</span></dt><dd><p>The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.shape">
<code class="descname">shape</code><a class="headerlink" href="#cudf.dataframe.series.Series.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>self</em>, <em>periods=1</em>, <em>freq=None</em>, <em>axis=0</em>, <em>fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift values of an input array by periods positions and store the
output in a new array.</p>
<p class="rubric">Notes</p>
<p>Shift currently only supports float and integer dtype columns with
no null values.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.sort_index">
<code class="descname">sort_index</code><span class="sig-paren">(</span><em>self</em>, <em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.sort_values">
<code class="descname">sort_values</code><span class="sig-paren">(</span><em>self</em>, <em>ascending=True</em>, <em>na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values.</p>
<p>Sort a Series in ascending or descending order by some criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ascending</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, sort values in ascending order, otherwise descending.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>sorted_obj</strong><span class="classifier">cuDF Series</span></dt><dd></dd>
<dt><strong>Difference from pandas:</strong></dt><dd><ul class="simple">
<li><p>Not supporting: inplace, kind</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">2    2</span>
<span class="go">4    3</span>
<span class="go">3    4</span>
<span class="go">1    5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.std">
<code class="descname">std</code><span class="sig-paren">(</span><em>self</em>, <em>ddof=1</em>, <em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>self</em>, <em>axis=None</em>, <em>skipna=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.tail">
<code class="descname">tail</code><span class="sig-paren">(</span><em>self</em>, <em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new Series</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">3    1</span>
<span class="go">4    0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.take">
<code class="descname">take</code><span class="sig-paren">(</span><em>self</em>, <em>indices</em>, <em>ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series by taking values from the corresponding <em>indices</em>.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.to_array">
<code class="descname">to_array</code><span class="sig-paren">(</span><em>self</em>, <em>fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numpy array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>Defaults to None, which will skip null values.
If it equals “pandas”, null values are filled with NaNs.
Non integral dtype is promoted to np.float64.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.to_dlpack">
<code class="descname">to_dlpack</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.to_frame">
<code class="descname">to_frame</code><span class="sig-paren">(</span><em>self</em>, <em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str, default None</span></dt><dd><p>Name to be used for the column</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>cudf DataFrame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.to_gpu_array">
<code class="descname">to_gpu_array</code><span class="sig-paren">(</span><em>self</em>, <em>fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.to_gpu_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numba device array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>See <em>fillna</em> in <code class="docutils literal notranslate"><span class="pre">.to_array</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.to_hdf">
<code class="descname">to_hdf</code><span class="sig-paren">(</span><em>self</em>, <em>path_or_buf</em>, <em>key</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a href="#id2"><span class="problematic" id="id3">:ref:`user guide
&lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables&gt;`_</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:
- ‘w’: write, a new file is created (an existing file with</p>
<blockquote>
<div><p>the same name would be deleted).</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>‘a’: append, an existing file is opened for reading and</dt><dd><p>writing, and if the file does not exist it is created.</p>
</dd>
</dl>
</li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:
- ‘fixed’: Fixed format. Fast writing/reading. Not-appendable,</p>
<blockquote>
<div><p>nor searchable.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>‘table’: Table format. Write as a PyTables Table structure</dt><dd><p>which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">See Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><em>self</em>, <em>path_or_buf=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.
Parameters
———-
path_or_buf : string or file handle, optional</p>
<blockquote>
<div><p>File path or object. If not specified, the result is returned as
a string.</p>
</div></blockquote>
<dl>
<dt>orient<span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.
* Series</p>
<blockquote>
<div><ul class="simple">
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>DataFrame</dt><dd><ul class="simple">
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:</p></li>
</ul>
<p>{‘split’,’records’,’index’,’columns’,’values’,’table’}</p>
</dd>
</dl>
</li>
<li><dl>
<dt>The format of the JSON string</dt><dd><ul class="simple">
<li><p>‘split’ : dict like {‘index’ -&gt; [index],</p></li>
</ul>
<p>‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}
- ‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]
- ‘index’ : dict like {index -&gt; {column -&gt; value}}
- ‘columns’ : dict like {column -&gt; {index -&gt; value}}
- ‘values’ : just the values array
- ‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>date_format<span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt>double_precision<span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt>force_ascii<span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt>date_unit<span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt>default_handler<span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt>lines<span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt>compression<span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt>index<span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>self</em>, <em>nrows=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nrows</strong><span class="classifier">int</span></dt><dd><p>Maximum number of rows to show.
If it is None, all rows are shown.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.unique">
<code class="descname">unique</code><span class="sig-paren">(</span><em>self</em>, <em>method='sort'</em>, <em>sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.
default=’sort’ will be changed to ‘hash’ when implemented.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.series.Series.valid_count">
<code class="descname">valid_count</code><a class="headerlink" href="#cudf.dataframe.series.Series.valid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-null values</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.value_counts">
<code class="descname">value_counts</code><span class="sig-paren">(</span><em>self</em>, <em>method='sort'</em>, <em>sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.value_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.values_to_string">
<code class="descname">values_to_string</code><span class="sig-paren">(</span><em>self</em>, <em>nrows=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.values_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of string for each element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.series.Series.var">
<code class="descname">var</code><span class="sig-paren">(</span><em>self</em>, <em>ddof=1</em>, <em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.series.Series.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance of the series</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="groupby">
<h2>Groupby<a class="headerlink" href="#groupby" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.groupby.groupby.Groupby">
<em class="property">class </em><code class="descclassname">cudf.groupby.groupby.</code><code class="descname">Groupby</code><span class="sig-paren">(</span><em>df</em>, <em>by</em>, <em>method='hash'</em>, <em>as_index=True</em>, <em>level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.groupby.Groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby object returned by cudf.DataFrame.groupby().</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.groupby.groupby.Groupby.agg" title="cudf.groupby.groupby.Groupby.agg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">agg</span></code></a>(self, args)</p></td>
<td><p>Invoke aggregation functions on the groups.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-center">
<colgroup>
<col style="width: 78%" />
<col style="width: 22%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>apply_multicolumn</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>apply_multicolumn_mapped</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>apply_multiindex_or_single_index</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>copy</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>count</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>deepcopy</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>max</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>mean</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>min</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>sum</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.groupby.groupby.Groupby.agg">
<code class="descname">agg</code><span class="sig-paren">(</span><em>self</em>, <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.groupby.Groupby.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke aggregation functions on the groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args</strong><span class="classifier">dict, list, str, callable</span></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>str</dt><dd><p>The aggregate function name.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>list</dt><dd><p>List of <em>str</em> of the aggregate function.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>dict</dt><dd><p>key-value pairs of source column name and list of
aggregate functions as <em>str</em>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Since multi-indexes aren’t supported aggregation results are returned
in columns using the naming scheme of <cite>aggregation_columnname</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.apply">
<code class="descclassname">Groupby.</code><code class="descname">apply</code><span class="sig-paren">(</span><em>self</em>, <em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a python transformation function over the grouped chunk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The python transformation function that will be applied
on the grouped chunk.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="c1"># Define a function to apply to each row in a group</span>
<span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
  <span class="n">df</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">df</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span>  <span class="n">out</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.apply_grouped">
<code class="descclassname">Groupby.</code><code class="descname">apply_grouped</code><span class="sig-paren">(</span><em>self</em>, <em>function</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.apply_grouped" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation function over the grouped chunk.</p>
<p>This uses numba’s CUDA JIT compiler to convert the Python
transformation function into a CUDA kernel, thus will have a
compilation overhead during the first run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt><dd><p>A list of names of input columns.</p>
</dd>
<dt><strong>outcols: list</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>name-value of extra arguments. These values are passed directly into
the function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="c1"># Define a function to apply to each group</span>
<span class="k">def</span> <span class="nf">mult_add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply_grouped</span><span class="p">(</span><span class="n">mult_add</span><span class="p">,</span>
                              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">],</span>
                              <span class="n">outcols</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;out1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                                       <span class="s1">&#39;out2&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">},</span>
                              <span class="c1"># threads per block</span>
                              <span class="n">tpb</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span> <span class="n">out1</span> <span class="n">out2</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">3</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>    <span class="mi">4</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>    <span class="mi">6</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>    <span class="mi">7</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>    <span class="mi">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.as_df">
<code class="descclassname">Groupby.</code><code class="descname">as_df</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.as_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the intermediate dataframe after shuffling the rows into
groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>(df, segs)</strong><span class="classifier">namedtuple</span></dt><dd><ul class="simple">
<li><p>df : DataFrame</p></li>
<li><dl class="simple">
<dt>segs<span class="classifier">Series</span></dt><dd><p>Beginning offsets of each group.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="n">df_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">as_df</span><span class="p">()</span>

<span class="c1"># DataFrame indexes of group starts</span>
<span class="k">print</span><span class="p">(</span><span class="n">df_groups</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># DataFrame itself</span>
<span class="k">print</span><span class="p">(</span><span class="n">df_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># DataFrame indexes of group starts</span>
<span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">2</span>
<span class="mi">2</span>    <span class="mi">4</span>

<span class="c1"># DataFrame itself</span>
   <span class="n">key</span>  <span class="n">val</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.std">
<code class="descclassname">Groupby.</code><code class="descname">std</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.var">
<code class="descclassname">Groupby.</code><code class="descname">var</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the var of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.sum_of_squares">
<code class="descclassname">Groupby.</code><code class="descname">sum_of_squares</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.sum_of_squares" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum_of_squares of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-cudf.io.csv">
<span id="io"></span><h2>IO<a class="headerlink" href="#module-cudf.io.csv" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cudf.io.csv.read_csv">
<code class="descclassname">cudf.io.csv.</code><code class="descname">read_csv</code><span class="sig-paren">(</span><em>filepath_or_buffer</em>, <em>lineterminator='n'</em>, <em>quotechar='&quot;'</em>, <em>quoting=0</em>, <em>doublequote=True</em>, <em>header='infer'</em>, <em>mangle_dupe_cols=True</em>, <em>usecols=None</em>, <em>sep='</em>, <em>'</em>, <em>delimiter=None</em>, <em>delim_whitespace=False</em>, <em>skipinitialspace=False</em>, <em>names=None</em>, <em>dtype=None</em>, <em>skipfooter=0</em>, <em>skiprows=0</em>, <em>dayfirst=False</em>, <em>compression='infer'</em>, <em>thousands=None</em>, <em>decimal='.'</em>, <em>true_values=None</em>, <em>false_values=None</em>, <em>nrows=None</em>, <em>byte_range=None</em>, <em>skip_blank_lines=True</em>, <em>comment=None</em>, <em>na_values=None</em>, <em>keep_default_na=True</em>, <em>na_filter=True</em>, <em>prefix=None</em>, <em>index_col=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.read_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Load and parse a CSV file into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str</span></dt><dd><p>Path of file to be read or a file-like object containing the file.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">char, default ‘,’</span></dt><dd><p>Delimiter to be used.</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">char, default None</span></dt><dd><p>Alternative argument name for sep.</p>
</dd>
<dt><strong>delim_whitespace</strong><span class="classifier">bool, default False</span></dt><dd><p>Determines whether to use whitespace as delimiter.</p>
</dd>
<dt><strong>lineterminator</strong><span class="classifier">char, default ‘\n’</span></dt><dd><p>Character to indicate end of line.</p>
</dd>
<dt><strong>skipinitialspace</strong><span class="classifier">bool, default False</span></dt><dd><p>Skip spaces after delimiter.</p>
</dd>
<dt><strong>names</strong><span class="classifier">list of str, default None</span></dt><dd><p>List of column names to be used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">list of str or dict of {col: dtype}, default None</span></dt><dd><p>List of data types in the same order of the column names
or a dictionary with column_name:dtype (pandas style).</p>
</dd>
<dt><strong>quotechar</strong><span class="classifier">char, default ‘”’</span></dt><dd><p>Character to indicate start and end of quote item.</p>
</dd>
<dt><strong>quoting</strong><span class="classifier">str or int, default 0</span></dt><dd><p>Controls quoting behavior. Set to one of
0 (csv.QUOTE_MINIMAL), 1 (csv.QUOTE_ALL),
2 (csv.QUOTE_NONNUMERIC) or 3 (csv.QUOTE_NONE).
Quoting is enabled with all values except 3.</p>
</dd>
<dt><strong>doublequote</strong><span class="classifier">bool, default True</span></dt><dd><p>When quoting is enabled, indicates whether to interpret two
consecutive quotechar inside fields as single quotechar</p>
</dd>
<dt><strong>header</strong><span class="classifier">int, default ‘infer’</span></dt><dd><p>Row number to use as the column names. Default behavior is to infer
the column names: if no names are passed, header=0;
if column names are passed explicitly, header=None.</p>
</dd>
<dt><strong>usecols</strong><span class="classifier">list of int or str, default None</span></dt><dd><p>Returns subset of the columns given in the list. All elements must be
either integer indices (column number) or strings that correspond to
column names</p>
</dd>
<dt><strong>mangle_dupe_cols</strong><span class="classifier">boolean, default True</span></dt><dd><p>Duplicate columns will be specified as ‘X’,’X.1’,…’X.N’.</p>
</dd>
<dt><strong>skiprows</strong><span class="classifier">int, default 0</span></dt><dd><p>Number of rows to be skipped from the start of file.</p>
</dd>
<dt><strong>skipfooter</strong><span class="classifier">int, default 0</span></dt><dd><p>Number of rows to be skipped at the bottom of file.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘zip’, None}, default ‘infer’</span></dt><dd><p>For on-the-fly decompression of on-disk data. If ‘infer’, then detect
compression from the following extensions: ‘.gz’,‘.zip’ (otherwise no
decompression). If using ‘zip’, the ZIP file must contain only one
data file to be read in, otherwise the first non-zero-sized file will
be used. Set to None for no decompression.</p>
</dd>
<dt><strong>decimal</strong><span class="classifier">char, default ‘.’</span></dt><dd><p>Character used as a decimal point.</p>
</dd>
<dt><strong>thousands</strong><span class="classifier">char, default None</span></dt><dd><p>Character used as a thousands delimiter.</p>
</dd>
<dt><strong>true_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as boolean True</p>
</dd>
<dt><strong>false_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as boolean False</p>
</dd>
<dt><strong>nrows</strong><span class="classifier">int, default None</span></dt><dd><p>If specified, maximum number of rows to read</p>
</dd>
<dt><strong>byte_range</strong><span class="classifier">list or tuple, default None</span></dt><dd><p>Byte range within the input file to be read. The first number is the
offset in bytes, the second number is the range size in bytes. Set the
size to zero to read all data after the offset location. Reads the row
that starts before or at the end of the range, even if it ends after
the end of the range.</p>
</dd>
<dt><strong>skip_blank_lines</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, discard and do not parse empty lines
If False, interpret empty lines as NaN values</p>
</dd>
<dt><strong>comment</strong><span class="classifier">char, default None</span></dt><dd><p>Character used as a comments indicator. If found at the beginning of a
line, the line will be ignored altogether.</p>
</dd>
<dt><strong>na_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as invalid</p>
</dd>
<dt><strong>keep_default_na</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether or not to include the default NA values when parsing the data.</p>
</dd>
<dt><strong>na_filter</strong><span class="classifier">bool, default True</span></dt><dd><p>Detect missing values (empty strings and the values in na_values).
Passing False can improve performance.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str, default None</span></dt><dd><p>Prefix to add to column numbers when parsing without a header row</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">int or string, default None</span></dt><dd><p>Column to use as the row labels</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>GPU <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Create a test csv file</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foo.csv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>  <span class="s2">&quot;num1,datetime,text&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;123,2018-11-13T12:00:00,abc&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;456,2018-11-14T12:35:01,def&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;789,2018-11-15T18:02:59,ghi&quot;</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Read the file with <code class="docutils literal notranslate"><span class="pre">cudf.read_csv</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.parquet"></span><dl class="function">
<dt id="cudf.io.parquet.read_parquet">
<code class="descclassname">cudf.io.parquet.</code><code class="descname">read_parquet</code><span class="sig-paren">(</span><em>path</em>, <em>engine='cudf'</em>, <em>columns=None</em>, <em>row_group=None</em>, <em>skip_rows=None</em>, <em>num_rows=None</em>, <em>strings_to_categorical=False</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.read_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a Parquet file into DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string or path object</span></dt><dd><p>Path of file to be read</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘pyarrow’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read.</p>
</dd>
<dt><strong>row_group</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, only the row group with the specified index will be read.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the nunber of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet_metadata" title="cudf.io.parquet.read_parquet_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet_metadata</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.parquet.read_parquet_metadata">
<code class="descclassname">cudf.io.parquet.</code><code class="descname">read_parquet_metadata</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.read_parquet_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a Parquet file’s metadata and schema</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string or path object</span></dt><dd><p>Path of file to be read</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Total number of rows</dt><dd></dd>
<dt>Number of row groups</dt><dd></dd>
<dt>List of column names</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_row_groups</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet_metadata</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">row_group</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_groups</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.parquet.to_parquet">
<code class="descclassname">cudf.io.parquet.</code><code class="descname">to_parquet</code><span class="sig-paren">(</span><em>df</em>, <em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt><dd><p>Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong><span class="classifier">list, optional, default None</span></dt><dd><p>Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.orc"></span><dl class="function">
<dt id="cudf.io.orc.read_orc">
<code class="descclassname">cudf.io.orc.</code><code class="descname">read_orc</code><span class="sig-paren">(</span><em>path</em>, <em>engine='cudf'</em>, <em>columns=None</em>, <em>skip_rows=None</em>, <em>num_rows=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.read_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an ORC object from the file path, returning a DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string</span></dt><dd><p>File path</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘pyarrow’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read from the file.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the number of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
<dt><strong>kwargs are passed to the engine</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_orc</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.json"></span><dl class="function">
<dt id="cudf.io.json.read_json">
<code class="descclassname">cudf.io.json.</code><code class="descname">read_json</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.read_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a JSON string to a cuDF object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">a valid JSON string or file-like, default: None</span></dt><dd><p>The string could be a URL. Valid URL schemes include http, ftp, s3,
gcs, and file. For file URLs, a host is expected. For instance, a local
file could be <code class="docutils literal notranslate"><span class="pre">file://localhost/path/to/table.json</span></code></p>
</dd>
<dt><strong>orient</strong><span class="classifier">string,</span></dt><dd><p>Indication of expected JSON string format.
Compatible JSON strings can be produced by <code class="docutils literal notranslate"><span class="pre">to_json()</span></code> with a
corresponding orient value.
The set of possible orients is:
- <code class="docutils literal notranslate"><span class="pre">'split'</span></code> : dict like</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">[index],</span> <span class="pre">columns</span> <span class="pre">-&gt;</span> <span class="pre">[columns],</span> <span class="pre">data</span> <span class="pre">-&gt;</span> <span class="pre">[values]}</span></code></p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'records'</span></code> : list like
<code class="docutils literal notranslate"><span class="pre">[{column</span> <span class="pre">-&gt;</span> <span class="pre">value},</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'index'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'columns'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'values'</span></code> : just the values array</p></li>
</ul>
<p>The allowed and default values depend on the value
of the <cite>typ</cite> parameter.
* when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'series'</span></code>,</p>
<blockquote>
<div><ul class="simple">
<li><p>allowed orients are <code class="docutils literal notranslate"><span class="pre">{'split','records','index'}</span></code></p></li>
<li><p>default is <code class="docutils literal notranslate"><span class="pre">'index'</span></code></p></li>
<li><p>The Series index must be unique for orient <code class="docutils literal notranslate"><span class="pre">'index'</span></code>.</p></li>
</ul>
</div></blockquote>
<ul>
<li><p>when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'frame'</span></code>,
- allowed orients are <a href="#id4"><span class="problematic" id="id5">``</span></a>{‘split’,’records’,’index’,</p>
<blockquote>
<div><p>‘columns’,’values’, ‘table’}``</p>
</div></blockquote>
<ul class="simple">
<li><p>default is <code class="docutils literal notranslate"><span class="pre">'columns'</span></code></p></li>
<li><p>The DataFrame index must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>.</p></li>
<li><p>The DataFrame columns must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'records'</span></code>.</p></li>
</ul>
<blockquote>
<div><p>‘table’ as an allowed value for the <code class="docutils literal notranslate"><span class="pre">orient</span></code> argument</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>typ</strong><span class="classifier">type of object to recover (series or frame), default ‘frame’</span></dt><dd></dd>
<dt><strong>dtype</strong><span class="classifier">boolean or dict, default True</span></dt><dd><p>If True, infer dtypes, if a dict of column to dtype, then use those,
if False, then don’t infer dtypes at all, applies only to the data.</p>
</dd>
<dt><strong>convert_axes</strong><span class="classifier">boolean, default True</span></dt><dd><p>Try to convert the axes to the proper dtypes.</p>
</dd>
<dt><strong>convert_dates</strong><span class="classifier">boolean, default True</span></dt><dd><p>List of columns to parse for dates; If True, then try to parse
datelike columns default is True; a column label is datelike if
* it ends with <code class="docutils literal notranslate"><span class="pre">'_at'</span></code>,
* it ends with <code class="docutils literal notranslate"><span class="pre">'_time'</span></code>,
* it begins with <code class="docutils literal notranslate"><span class="pre">'timestamp'</span></code>,
* it is <code class="docutils literal notranslate"><span class="pre">'modified'</span></code>, or
* it is <code class="docutils literal notranslate"><span class="pre">'date'</span></code></p>
</dd>
<dt><strong>keep_default_dates</strong><span class="classifier">boolean, default True</span></dt><dd><p>If parsing dates, then parse the default datelike columns</p>
</dd>
<dt><strong>numpy</strong><span class="classifier">boolean, default False</span></dt><dd><p>Direct decoding to numpy arrays. Supports numeric data only, but
non-numeric column and index labels are supported. Note also that the
JSON ordering MUST be the same for each term if numpy=True.</p>
</dd>
<dt><strong>precise_float</strong><span class="classifier">boolean, default False</span></dt><dd><p>Set to enable usage of higher precision (strtod) function when
decoding string to double values. Default (False) is to use fast but
less precise builtin functionality</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default None</span></dt><dd><p>The timestamp unit to detect if converting dates. The default behaviour
is to try and detect the correct precision, but if this is not desired
then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force parsing only seconds,
milliseconds, microseconds or nanoseconds respectively.</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">str, default is ‘utf-8’</span></dt><dd><p>The encoding to use to decode py3 bytes.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">boolean, default False</span></dt><dd><p>Read the file as a json object per line.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">integer, default None</span></dt><dd><p>Return JsonReader object for iteration.
See the <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-jsonl">line-delimted json docs</a>
for more information on <code class="docutils literal notranslate"><span class="pre">chunksize</span></code>.
This can only be passed if <cite>lines=True</cite>.
If this is None, the file will be read into memory all at once.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}, default ‘infer’</span></dt><dd><p>For on-the-fly decompression of on-disk data. If ‘infer’, then use
gzip, bz2, zip or xz if path_or_buf is a string ending in
‘.gz’, ‘.bz2’, ‘.zip’, or ‘xz’, respectively, and no decompression
otherwise. If using ‘zip’, the ZIP file must contain only one data
file to be read in. Set to None for no decompression.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">Series or DataFrame, depending on the value of <cite>typ</cite>.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.to_json" title="cudf.io.json.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.to_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.json.to_json">
<code class="descclassname">cudf.io.json.</code><code class="descname">to_json</code><span class="sig-paren">(</span><em>cudf_val</em>, <em>path_or_buf=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.
* Series</p>
<blockquote>
<div><ul class="simple">
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>DataFrame</dt><dd><ul class="simple">
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:</p></li>
</ul>
<p>{‘split’,’records’,’index’,’columns’,’values’,’table’}</p>
</dd>
</dl>
</li>
<li><dl>
<dt>The format of the JSON string</dt><dd><ul class="simple">
<li><p>‘split’ : dict like {‘index’ -&gt; [index],</p></li>
</ul>
<p>‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}
- ‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]
- ‘index’ : dict like {index -&gt; {column -&gt; value}}
- ‘columns’ : dict like {column -&gt; {index -&gt; value}}
- ‘values’ : just the values array
- ‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
<dt><strong>See Also</strong></dt><dd></dd>
<dt><strong>——–</strong></dt><dd></dd>
<dt><strong>.cudf.io.json.read_json</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cudf.io.feather"></span><dl class="function">
<dt id="cudf.io.feather.read_feather">
<code class="descclassname">cudf.io.feather.</code><code class="descname">read_feather</code><span class="sig-paren">(</span><em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.read_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an feather object from the file path, returning a DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string</span></dt><dd><p>File path</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default=None</span></dt><dd><p>If not None, only these columns will be read from the file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_feather</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.feather.to_feather">
<code class="descclassname">cudf.io.feather.</code><code class="descname">to_feather</code><span class="sig-paren">(</span><em>df</em>, <em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.hdf"></span><dl class="function">
<dt id="cudf.io.hdf.read_hdf">
<code class="descclassname">cudf.io.hdf.</code><code class="descname">read_hdf</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.read_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the store, close it if we opened it.</p>
<p>Retrieve pandas object stored in file, optionally based on where
criteria</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string, buffer or path object</span></dt><dd><p>Path to the file to open, or an open <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">HDFStore</a>.
object.
Supports any object implementing the <code class="docutils literal notranslate"><span class="pre">__fspath__</span></code> protocol.
This includes <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> and py._path.local.LocalPath
objects.</p>
</dd>
<dt><strong>key</strong><span class="classifier">object, optional</span></dt><dd><p>The group identifier in the store. Can be omitted if the HDF file
contains a single pandas object.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘r’, ‘r+’, ‘a’}, optional</span></dt><dd><p>Mode to use when opening the file. Ignored if path_or_buf is a
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">Pandas HDFS</a>.
Default is ‘r’.</p>
</dd>
<dt><strong>where</strong><span class="classifier">list, optional</span></dt><dd><p>A list of Term (or convertible) objects.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int, optional</span></dt><dd><p>Row number to start selection.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int, optional</span></dt><dd><p>Row number to stop selection.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, optional</span></dt><dd><p>A list of columns names to return.</p>
</dd>
<dt><strong>iterator</strong><span class="classifier">bool, optional</span></dt><dd><p>Return an iterator object.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rows to include in an iteration when using an iterator.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments passed to HDFStore.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>item</strong><span class="classifier">object</span></dt><dd><p>The selected object. Return type depends on the object stored.</p>
</dd>
<dt>See Also</dt><dd></dd>
</dl>
<blockquote>
<div></div></blockquote>
<dl class="simple">
<dt><strong>cudf.io.hdf.to_hdf</strong><span class="classifier">Write a HDF file from a DataFrame.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cudf.io.hdf.to_hdf">
<code class="descclassname">cudf.io.hdf.</code><code class="descname">to_hdf</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>key</em>, <em>value</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,</p></li>
</ul>
<p>nor searchable.
- ‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather..to_feather</span></code></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="gpuarrowreader">
<h2>GpuArrowReader<a class="headerlink" href="#gpuarrowreader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.comm.gpuarrow.GpuArrowReader">
<em class="property">class </em><code class="descclassname">cudf.comm.gpuarrow.</code><code class="descname">GpuArrowReader</code><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-center">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="cudf.comm.gpuarrow.GpuArrowReader.to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code></a>(self)</p></td>
<td><p>Return a dictionary of Series object</p></td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="cudf.comm.gpuarrow.GpuArrowReader.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of Series object</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="10min.html" class="btn btn-neutral float-right" title="10 Minutes to cuDF" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to cuDF’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>