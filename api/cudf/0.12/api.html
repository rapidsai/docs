

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; cudf 0.12.0b+2032.gab97331fe documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/params.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10 Minutes to cuDF and Dask-cuDF" href="10min.html" />
    <link rel="prev" title="Welcome to cuDF’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cudf
          

          
          </a>

          
            
            
              <div class="version">
                0.12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dataframe">DataFrame</a></li>
<li class="toctree-l2"><a class="reference internal" href="#series">Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#groupby">Groupby</a></li>
<li class="toctree-l2"><a class="reference internal" href="#legacy-groupby">Legacy Groupby</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cudf.io.csv">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpuarrowreader">GpuArrowReader</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="10min.html">10 Minutes to cuDF and Dask-cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="dask-cudf.html">Multi-GPU with Dask-cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="dask-xgb-10min.html">10 Minutes to Dask-XGBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="10min-cudf-cupy.html">10 Minutes to cuDF and CuPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="guide-to-udfs.html">Overview of User Defined Functions with cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer.html">Developer Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cudf</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="dataframe">
<h2>DataFrame<a class="headerlink" href="#dataframe" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.core.dataframe.DataFrame">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.dataframe.</code><code class="sig-name descname">DataFrame</code><span class="sig-paren">(</span><em class="sig-param">data=None</em>, <em class="sig-param">index=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>A GPU Dataframe object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">data-type to coerce. Infers date format if to date.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Build dataframe with <cite>__setitem__</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
<p>Build DataFrame via dict of columns:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t0</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-07 12:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s1">&#39;datetimes&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">t0</span><span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">    id                datetimes</span>
<span class="go">0    0  2018-10-07T12:00:00.000</span>
<span class="go">1    1  2018-10-07T12:00:01.000</span>
<span class="go">2    2  2018-10-07T12:00:02.000</span>
<span class="go">3    3  2018-10-07T12:00:03.000</span>
<span class="go">4    4  2018-10-07T12:00:04.000</span>
</pre></div>
</div>
<p>Build DataFrame via list of rows as tuples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span>
<span class="go">    (5, &quot;cats&quot;, &quot;jump&quot;, np.nan),</span>
<span class="go">    (2, &quot;dogs&quot;, &quot;dig&quot;, 7.5),</span>
<span class="go">    (3, &quot;cows&quot;, &quot;moo&quot;, -2.1, &quot;occasionally&quot;),</span>
<span class="go">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">0     1     2     3             4</span>
<span class="go">0  5  cats  jump  null          None</span>
<span class="go">1  2  dogs   dig   7.5          None</span>
<span class="go">2  3  cows   moo  -2.1  occasionally</span>
</pre></div>
</div>
<p>Convert from a Pandas DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  a b</span>
<span class="go">0 0 0.1</span>
<span class="go">1 1 0.2</span>
<span class="go">2 2 nan</span>
<span class="go">3 3 0.3</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>T</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.columns" title="cudf.core.dataframe.DataFrame.columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">columns</span></code></a></dt><dd><p>Returns a tuple of columns</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.dtypes" title="cudf.core.dataframe.DataFrame.dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtypes</span></code></a></dt><dd><p>Return the dtypes in this object.</p>
</dd>
<dt><strong>empty</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iloc" title="cudf.core.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt><dd><p>Selecting rows and column by position.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.index" title="cudf.core.dataframe.DataFrame.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt><dd><p>Returns the index of the DataFrame</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.loc" title="cudf.core.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt><dd><p>Selecting rows and columns by label or boolean mask.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.ndim" title="cudf.core.dataframe.DataFrame.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>Dimension of the data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.shape" title="cudf.core.dataframe.DataFrame.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd>
<dt><strong>values</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.add_column" title="cudf.core.dataframe.DataFrame.add_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_column</span></code></a>(self, name, data[, forceindex])</p></td>
<td><p>Add a column</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.apply_chunks" title="cudf.core.dataframe.DataFrame.apply_chunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_chunks</span></code></a>(self, func, incols, outcols[, …])</p></td>
<td><p>Transform user-specified chunks using the user-provided function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.apply_rows" title="cudf.core.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_rows</span></code></a>(self, func, incols, outcols, kwargs)</p></td>
<td><p>Apply a row-wise user defined function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.as_gpu_matrix" title="cudf.core.dataframe.DataFrame.as_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_gpu_matrix</span></code></a>(self[, columns, order])</p></td>
<td><p>Convert to a matrix in device memory.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.as_matrix" title="cudf.core.dataframe.DataFrame.as_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_matrix</span></code></a>(self[, columns])</p></td>
<td><p>Convert to a matrix in host memory.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.assign" title="cudf.core.dataframe.DataFrame.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Assign columns to DataFrame from keyword arguments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.at" title="cudf.core.dataframe.DataFrame.at"><code class="xref py py-obj docutils literal notranslate"><span class="pre">at</span></code></a>(self)</p></td>
<td><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.loc</span></code>; provided for compatibility with Pandas.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.clean_renderable_dataframe" title="cudf.core.dataframe.DataFrame.clean_renderable_dataframe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clean_renderable_dataframe</span></code></a>(self, output)</p></td>
<td><p>the below is permissible: null in a datetime to_pandas() becomes NaT, which is then replaced with null in this processing step.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.copy" title="cudf.core.dataframe.DataFrame.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(self[, deep])</p></td>
<td><p>Returns a copy of this dataframe</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.cov" title="cudf.core.dataframe.DataFrame.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cov</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Compute the covariance matrix of a DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.describe" title="cudf.core.dataframe.DataFrame.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">describe</span></code></a>(self[, percentiles, include, exclude])</p></td>
<td><p>Compute summary statistics of a DataFrame’s columns.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.drop" title="cudf.core.dataframe.DataFrame.drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop</span></code></a>(self[, labels, axis, columns, errors, …])</p></td>
<td><p>Drop column(s)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.drop_column" title="cudf.core.dataframe.DataFrame.drop_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_column</span></code></a>(self, name)</p></td>
<td><p>Drop a column by <em>name</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.drop_duplicates" title="cudf.core.dataframe.DataFrame.drop_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_duplicates</span></code></a>(self[, subset, keep, inplace])</p></td>
<td><p>Return DataFrame with duplicate rows removed, optionally only considering certain subset of columns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.dropna" title="cudf.core.dataframe.DataFrame.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dropna</span></code></a>(self[, axis, how, subset, thresh])</p></td>
<td><p>Drops rows (or columns) containing nulls from a Column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.fillna" title="cudf.core.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(self, value[, method, axis, inplace, …])</p></td>
<td><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_arrow" title="cudf.core.dataframe.DataFrame.from_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_arrow</span></code></a>(table)</p></td>
<td><p>Convert from a PyArrow Table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_gpu_matrix" title="cudf.core.dataframe.DataFrame.from_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_gpu_matrix</span></code></a>(data[, index, columns, …])</p></td>
<td><p>Convert from a numba gpu ndarray.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_pandas" title="cudf.core.dataframe.DataFrame.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(dataframe[, nan_as_null])</p></td>
<td><p>Convert from a Pandas DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_records" title="cudf.core.dataframe.DataFrame.from_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_records</span></code></a>(data[, index, columns, nan_as_null])</p></td>
<td><p>Convert from a numpy recarray or structured array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.get_renderable_dataframe" title="cudf.core.dataframe.DataFrame.get_renderable_dataframe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_renderable_dataframe</span></code></a>(self)</p></td>
<td><p>takes rows and columns from pandas settings or estimation from size.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.groupby" title="cudf.core.dataframe.DataFrame.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a>(self[, by, sort, as_index, method, …])</p></td>
<td><p>Groupby</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.hash_columns" title="cudf.core.dataframe.DataFrame.hash_columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_columns</span></code></a>(self[, columns])</p></td>
<td><p>Hash the given <em>columns</em> and return a new device array</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.head" title="cudf.core.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">head</span></code></a>(self[, n])</p></td>
<td><p>Returns the first n rows as a new DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iat" title="cudf.core.dataframe.DataFrame.iat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iat</span></code></a>(self)</p></td>
<td><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code>; provided for compatibility with Pandas.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.insert" title="cudf.core.dataframe.DataFrame.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(self, loc, name, value)</p></td>
<td><p>Add a column to DataFrame at the index specified by loc.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.isna" title="cudf.core.dataframe.DataFrame.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isna</span></code></a>(self)</p></td>
<td><p>Identify missing values in a DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.isnull" title="cudf.core.dataframe.DataFrame.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnull</span></code></a>(self)</p></td>
<td><p>Identify missing values in a DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iteritems" title="cudf.core.dataframe.DataFrame.iteritems"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iteritems</span></code></a>(self)</p></td>
<td><p>Iterate over column names and series pairs</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.join" title="cudf.core.dataframe.DataFrame.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(self, other[, on, how, lsuffix, …])</p></td>
<td><p>Join columns with other DataFrame on index or on a key column.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.label_encoding" title="cudf.core.dataframe.DataFrame.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(self, column, prefix, cats[, …])</p></td>
<td><p>Encode labels in a column with label encoding.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.mean" title="cudf.core.dataframe.DataFrame.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(self[, axis, numeric_only])</p></td>
<td><p>Return the mean of the values for the requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.melt" title="cudf.core.dataframe.DataFrame.melt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">melt</span></code></a>(self, \*\*kwargs)</p></td>
<td><p>Unpivots a DataFrame from wide format to long format, optionally leaving identifier variables set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.merge" title="cudf.core.dataframe.DataFrame.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code></a>(self, right[, on, how, left_on, …])</p></td>
<td><p>Merge GPU DataFrame objects by performing a database-style join operation by columns or indexes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.nans_to_nulls" title="cudf.core.dataframe.DataFrame.nans_to_nulls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nans_to_nulls</span></code></a>(self)</p></td>
<td><p>Convert nans (if any) to nulls.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.nlargest" title="cudf.core.dataframe.DataFrame.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(self, n, columns[, keep])</p></td>
<td><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.notna" title="cudf.core.dataframe.DataFrame.notna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">notna</span></code></a>(self)</p></td>
<td><p>Identify non-missing values in a DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.notnull" title="cudf.core.dataframe.DataFrame.notnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">notnull</span></code></a>(self)</p></td>
<td><p>Identify non-missing values in a DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.nsmallest" title="cudf.core.dataframe.DataFrame.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(self, n, columns[, keep])</p></td>
<td><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.one_hot_encoding" title="cudf.core.dataframe.DataFrame.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(self, column, prefix, cats)</p></td>
<td><p>Expand a column with one-hot-encoding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.partition_by_hash" title="cudf.core.dataframe.DataFrame.partition_by_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_by_hash</span></code></a>(self, columns, nparts)</p></td>
<td><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.pop" title="cudf.core.dataframe.DataFrame.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code></a>(self, item)</p></td>
<td><p>Return a column and drop it from the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.prod" title="cudf.core.dataframe.DataFrame.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code></a>(self[, axis])</p></td>
<td><p>Alias for product.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.quantile" title="cudf.core.dataframe.DataFrame.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(self[, q, axis, numeric_only, …])</p></td>
<td><p>Return values at the given quantile.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.query" title="cudf.core.dataframe.DataFrame.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query</span></code></a>(self, expr[, local_dict])</p></td>
<td><p>Query with a boolean expression using Numba to compile a GPU kernel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.reindex" title="cudf.core.dataframe.DataFrame.reindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></a>(self[, labels, axis, index, …])</p></td>
<td><p>Return a new DataFrame whose axes conform to a new index</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rename" title="cudf.core.dataframe.DataFrame.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(self[, mapper, columns, copy, inplace])</p></td>
<td><p>Alter column labels.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.replace" title="cudf.core.dataframe.DataFrame.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(self, to_replace, replacement)</p></td>
<td><p>Replace values given in <em>to_replace</em> with <em>replacement</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rolling" title="cudf.core.dataframe.DataFrame.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling</span></code></a>(self, window[, min_periods, center, …])</p></td>
<td><p>Rolling window calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.scatter_by_map" title="cudf.core.dataframe.DataFrame.scatter_by_map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scatter_by_map</span></code></a>(self, map_index[, map_size, …])</p></td>
<td><p>Scatter to a list of dataframes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.select_dtypes" title="cudf.core.dataframe.DataFrame.select_dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_dtypes</span></code></a>(self[, include, exclude])</p></td>
<td><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.set_index" title="cudf.core.dataframe.DataFrame.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(self, index[, drop])</p></td>
<td><p>Return a new DataFrame with a new index</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.sort_index" title="cudf.core.dataframe.DataFrame.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>(self[, ascending])</p></td>
<td><p>Sort by the index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.sort_values" title="cudf.core.dataframe.DataFrame.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(self, by[, ascending, na_position])</p></td>
<td><p>Sort by the values row-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.stack" title="cudf.core.dataframe.DataFrame.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a>(self[, level, dropna])</p></td>
<td><p>Stack the prescribed level(s) from columns to index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.tail" title="cudf.core.dataframe.DataFrame.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>(self[, n])</p></td>
<td><p>Returns the last n rows as a new DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.tile" title="cudf.core.dataframe.DataFrame.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(self, reps)</p></td>
<td><p>Construct a DataFrame by repeating this DataFrame the number of times given by reps</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_arrow" title="cudf.core.dataframe.DataFrame.to_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_arrow</span></code></a>(self[, preserve_index])</p></td>
<td><p>Convert to a PyArrow Table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_csv" title="cudf.core.dataframe.DataFrame.to_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_csv</span></code></a>(self[, path, sep, na_rep, columns, …])</p></td>
<td><p>Write a dataframe to csv file format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_dlpack" title="cudf.core.dataframe.DataFrame.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>(self)</p></td>
<td><p>Converts a cuDF object into a DLPack tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_feather" title="cudf.core.dataframe.DataFrame.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_feather</span></code></a>(self, path, \*args, \*\*kwargs)</p></td>
<td><p>Write a DataFrame to the feather format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_gpu_matrix" title="cudf.core.dataframe.DataFrame.to_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_matrix</span></code></a>(self)</p></td>
<td><p>Convert to a numba gpu ndarray</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_hdf" title="cudf.core.dataframe.DataFrame.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(self, path_or_buf, key, \*args, …)</p></td>
<td><p>Write the contained data to an HDF5 file using HDFStore.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_json" title="cudf.core.dataframe.DataFrame.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>(self[, path_or_buf])</p></td>
<td><p>Convert the cuDF object to a JSON string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_orc" title="cudf.core.dataframe.DataFrame.to_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_orc</span></code></a>(self, fname[, compression])</p></td>
<td><p>Write a DataFrame to the ORC format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_pandas" title="cudf.core.dataframe.DataFrame.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self)</p></td>
<td><p>Convert to a Pandas DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_parquet" title="cudf.core.dataframe.DataFrame.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a>(self, path, \*args, \*\*kwargs)</p></td>
<td><p>Write a DataFrame to the parquet format.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_records" title="cudf.core.dataframe.DataFrame.to_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_records</span></code></a>(self[, index])</p></td>
<td><p>Convert to a numpy recarray</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_string" title="cudf.core.dataframe.DataFrame.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>(self)</p></td>
<td><p>Convert to string</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.transpose" title="cudf.core.dataframe.DataFrame.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(self)</p></td>
<td><p>Transpose index and columns.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>add</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>all</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>any</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>argsort</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>astype</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>count</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>cummax</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>cummin</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>cumprod</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>cumsum</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>deserialize</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>equals</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>floordiv</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>kurtosis</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>mask</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>max</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>memory_usage</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>min</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>mod</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>mul</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>pow</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>product</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>radd</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>repeat</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>reset_index</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>rfloordiv</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>rmod</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>rmul</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>rpow</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>rsub</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>rtruediv</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>serialize</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>skew</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>std</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>sub</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>sum</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>take</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>truediv</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>var</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.add_column">
<code class="sig-name descname">add_column</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">data</em>, <em class="sig-param">forceindex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.add_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of column to be added.</p>
</dd>
<dt><strong>data</strong><span class="classifier">Series, array-like</span></dt><dd><p>Values to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.apply_chunks">
<code class="sig-name descname">apply_chunks</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">func</em>, <em class="sig-param">incols</em>, <em class="sig-param">outcols</em>, <em class="sig-param">kwargs={}</em>, <em class="sig-param">pessimistic_nulls=True</em>, <em class="sig-param">chunks=None</em>, <em class="sig-param">blkct=None</em>, <em class="sig-param">tpb=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.apply_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform user-specified chunks using the user-provided function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>The source dataframe.</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list or dict</strong></dt><dd><p>A list of names of input columns that match the function arguments.
Or, a dictionary mapping input column names to their corresponding
function arguments such as {‘col1’: ‘arg1’}.</p>
</dd>
<dt><strong>outcols: dict</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
<dt><strong>pessimistic_nulls</strong><span class="classifier">bool</span></dt><dd><p>Whether or not apply_rows output should be null when any corresponding
input is null. If False, all outputs will be non-null, but will be the
result of applying func against the underlying column data, which
may be garbage.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">int or Series-like</span></dt><dd><p>If it is an <code class="docutils literal notranslate"><span class="pre">int</span></code>, it is the chunksize.
If it is an array, it contains integer offset for the start of each chunk.
The span of a chunk for chunk i-th is <code class="docutils literal notranslate"><span class="pre">data[chunks[i]</span> <span class="pre">:</span> <span class="pre">chunks[i</span> <span class="pre">+</span> <span class="pre">1]]</span></code>
for any <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">chunks.size</span></code>; or, <code class="docutils literal notranslate"><span class="pre">data[chunks[i]:]</span></code> for the
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">len(chunks)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>tpb</strong><span class="classifier">int; optional</span></dt><dd><p>The threads-per-block for the underlying kernel.
If not specified (Default), uses Numba <code class="docutils literal notranslate"><span class="pre">.forall(...)</span></code> built-in to query
the CUDA Driver API to determine optimal kernel launch configuration.
Specify 1 to emulate serial execution for each chunk.  It is a good
starting point but inefficient.
Its maximum possible value is limited by the available CUDA GPU resources.</p>
</dd>
<dt><strong>blkct</strong><span class="classifier">int; optional</span></dt><dd><p>The number of blocks for the underlying kernel.
If not specified (Default) and <code class="docutils literal notranslate"><span class="pre">tpb</span></code> is not specified (Default), uses
Numba <code class="docutils literal notranslate"><span class="pre">.forall(...)</span></code> built-in to query the CUDA Driver API to determine
optimal kernel launch configuration.
If not specified (Default) and <code class="docutils literal notranslate"><span class="pre">tpb</span></code> is specified, uses <code class="docutils literal notranslate"><span class="pre">chunks</span></code> as the
number of blocks.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.apply_rows" title="cudf.core.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply_rows</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>For <code class="docutils literal notranslate"><span class="pre">tpb</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">func</span></code> is executed by <code class="docutils literal notranslate"><span class="pre">tpb</span></code> number of threads
concurrently.  To access the thread id and count,
use <code class="docutils literal notranslate"><span class="pre">numba.cuda.threadIdx.x</span></code> and <code class="docutils literal notranslate"><span class="pre">numba.cuda.blockDim.x</span></code>,
respectively (See <a class="reference external" href="http://numba.pydata.org/numba-doc/latest/cuda/kernels.html">numba CUDA kernel documentation</a>).</p>
<p>In the example below, the <em>kernel</em> is invoked concurrently on each
specified chunk. The <em>kernel</em> computes the corresponding output
for the chunk.</p>
<p>By looping over the range
<code class="docutils literal notranslate"><span class="pre">range(cuda.threadIdx.x,</span> <span class="pre">in1.size,</span> <span class="pre">cuda.blockDim.x)</span></code>, the <em>kernel</em>
function can be used with any <em>tpb</em> in a efficient manner.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@cuda</span><span class="o">.</span><span class="n">jit</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">):</span>
<span class="gp">... </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>         <span class="n">x</span> <span class="o">=</span> <span class="n">in1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">y</span> <span class="o">=</span> <span class="n">in2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">z</span> <span class="o">=</span> <span class="n">in3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.apply_rows">
<code class="sig-name descname">apply_rows</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">func</em>, <em class="sig-param">incols</em>, <em class="sig-param">outcols</em>, <em class="sig-param">kwargs</em>, <em class="sig-param">pessimistic_nulls=True</em>, <em class="sig-param">cache_key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.apply_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a row-wise user defined function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>The source dataframe.</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list or dict</strong></dt><dd><p>A list of names of input columns that match the function arguments.
Or, a dictionary mapping input column names to their corresponding
function arguments such as {‘col1’: ‘arg1’}.</p>
</dd>
<dt><strong>outcols: dict</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
<dt><strong>pessimistic_nulls</strong><span class="classifier">bool</span></dt><dd><p>Whether or not apply_rows output should be null when any corresponding
input is null. If False, all outputs will be non-null, but will be the
result of applying func against the underlying column data, which
may be garbage.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The user function should loop over the columns and set the output for
each row. Loop execution order is arbitrary, so each iteration of
the loop <strong>MUST</strong> be independent of each other.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">func</span></code> is invoked, the array args corresponding to the
input/output are strided so as to improve GPU parallelism.
The loop in the function resembles serial code, but executes
concurrently in multiple threads.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nelem</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
</pre></div>
</div>
<p>Define input columns for the kernel</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">in1</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in3</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">,</span> <span class="n">kwarg1</span><span class="p">,</span> <span class="n">kwarg2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">)):</span>
<span class="gp">... </span>        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwarg2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">... </span>        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">z</span>
</pre></div>
</div>
<p>Call <code class="docutils literal notranslate"><span class="pre">.apply_rows</span></code> with the name of the input columns, the name and
dtype of the output columns, and, optionally, a dict of extra
arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">apply_rows</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">,</span> <span class="s1">&#39;in2&#39;</span><span class="p">,</span> <span class="s1">&#39;in3&#39;</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">outcols</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">out2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwarg1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">kwarg2</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">   in1  in2  in3 out1 out2</span>
<span class="go">0    0    0    0  0.0  0.0</span>
<span class="go">1    1    1    1  1.0 -2.0</span>
<span class="go">2    2    2    2  2.0 -4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.as_gpu_matrix">
<code class="sig-name descname">as_gpu_matrix</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">order='F'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.as_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in device memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
<dt><strong>order</strong><span class="classifier">‘F’ or ‘C’</span></dt><dd><p>Optional argument to determine whether to return a column major
(Fortran) matrix or a row major (C) matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A (nrow x ncol) numpy ndarray in “F” order.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.as_matrix">
<code class="sig-name descname">as_matrix</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.as_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in host memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A (nrow x ncol) numpy ndarray in “F” order.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.assign">
<code class="sig-name descname">assign</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign columns to DataFrame from keyword arguments.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">0  0  3</span>
<span class="go">1  1  4</span>
<span class="go">2  2  5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.at">
<code class="sig-name descname">at</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.loc</span></code>; provided for compatibility with Pandas.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.clean_renderable_dataframe">
<code class="sig-name descname">clean_renderable_dataframe</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">output</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.clean_renderable_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>the below is permissible: null in a datetime to_pandas() becomes
NaT, which is then replaced with null in this processing step.
It is not possible to have a mix of nulls and NaTs in datetime
columns because we do not support NaT - pyarrow as_column
preprocessing converts NaT input values from numpy or pandas into
null.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.columns">
<em class="property">property </em><code class="sig-name descname">columns</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of columns</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this dataframe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep: bool</strong></dt><dd><p>Make a full copy of Series columns and Index at the GPU level, or
create a new allocation with references.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the covariance matrix of a DataFrame.
Parameters
———-
<a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs</p>
<blockquote>
<div><p>Keyword arguments to be passed to cupy.cov</p>
</div></blockquote>
<p>cov : DataFrame</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.describe">
<code class="sig-name descname">describe</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">percentiles=None</em>, <em class="sig-param">include=None</em>, <em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute summary statistics of a DataFrame’s columns. For numeric
data, the output includes the minimum, maximum, mean, median,
standard deviation, and various quantiles. For object data, the output
includes the count, number of unique values, the most common value, and
the number of occurrences of the most common value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like, optional</span></dt><dd><p>The percentiles used to generate the output summary statistics.
If None, the default percentiles used are the 25th, 50th and 75th.
Values should be within the interval [0, 1].</p>
</dd>
<dt><strong>include: str, list-like, optional</strong></dt><dd><p>The dtypes to be included in the output summary statistics. Columns
of dtypes not included in this list will not be part of the output.
If include=’all’, all dtypes are included. Default of None includes
all numeric columns.</p>
</dd>
<dt><strong>exclude: str, list-like, optional</strong></dt><dd><p>The dtypes to be excluded from the output summary statistics.
Columns of dtypes included in this list will not be part of the
output. Default of None excludes no columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output_frame</strong><span class="classifier">DataFrame</span></dt><dd><p>Summary statistics of relevant columns in the original dataframe.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">Series</span></code> containing numeric values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">   stats   values</span>
<span class="go">0  count     10.0</span>
<span class="go">1   mean      5.5</span>
<span class="go">2    std  3.02765</span>
<span class="go">3    min      1.0</span>
<span class="go">4    25%      2.5</span>
<span class="go">5    50%      5.5</span>
<span class="go">6    75%      7.5</span>
<span class="go">7    max     10.0</span>
</pre></div>
</div>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. By default all numeric fields
are returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">   stats    a    b    d</span>
<span class="go">0  count  3.0  3.0  3.0</span>
<span class="go">1   mean  2.0  2.0  2.0</span>
<span class="go">2    std  1.0  1.0  1.0</span>
<span class="go">3    min  1.0  1.0  1.0</span>
<span class="go">4    25%  1.5  1.5  1.5</span>
<span class="go">5    50%  1.5  1.5  1.5</span>
<span class="go">6    75%  2.5  2.5  2.5</span>
<span class="go">7    max  3.0  3.0  3.0</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">include</span></code> keyword to describe only specific dtypes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
<span class="go">   stats    a</span>
<span class="go">0  count  3.0</span>
<span class="go">1   mean  2.0</span>
<span class="go">2    std  1.0</span>
<span class="go">3    min  1.0</span>
<span class="go">4    25%  1.5</span>
<span class="go">5    50%  1.5</span>
<span class="go">6    75%  2.5</span>
<span class="go">7    max  3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.drop">
<code class="sig-name descname">drop</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">labels=None</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">errors='raise'</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop column(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">str or sequence of strings</span></dt><dd><p>Name of column(s) to be dropped.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>Only axis=1 is currently supported.</p>
</dd>
<dt><strong>columns: array of column names, the same as using labels and axis=1</strong></dt><dd></dd>
<dt><strong>errors</strong><span class="classifier">{‘ignore’, ‘raise’}, default ‘raise’</span></dt><dd><p>This parameter is currently ignored.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, do operation inplace and return <cite>self</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A dataframe without dropped column(s)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_new</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;val&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_new</span><span class="p">)</span>
<span class="go">   key</span>
<span class="go">0    0</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.drop_column">
<code class="sig-name descname">drop_column</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.drop_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop a column by <em>name</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.drop_duplicates">
<code class="sig-name descname">drop_duplicates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">keep='first'</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.drop_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return DataFrame with duplicate rows removed, optionally only
considering certain subset of columns.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.dropna">
<code class="sig-name descname">dropna</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">how='any'</em>, <em class="sig-param">subset=None</em>, <em class="sig-param">thresh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.dropna" title="Permalink to this definition">¶</a></dt>
<dd><p>Drops rows (or columns) containing nulls from a Column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0, 1}, optional</span></dt><dd><p>Whether to drop rows (axis=0, default) or columns (axis=1)
containing nulls.</p>
</dd>
<dt><strong>how</strong><span class="classifier">{“any”, “all”}, optional</span></dt><dd><p>Specifies how to decide whether to drop a row (or column).
any (default) drops rows (or columns) containing at least
one null value. all drops only rows (or columns) containing
<em>all</em> null values.</p>
</dd>
<dt><strong>subset</strong><span class="classifier">list, optional</span></dt><dd><p>List of columns to consider when dropping rows (all columns
are considered by default). Alternatively, when dropping
columns, subset is a list of rows to consider.</p>
</dd>
<dt><strong>thresh: int, optional</strong></dt><dd><p>If specified, then drops every row (or column) containing
less than <cite>thresh</cite> non-null values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Copy of the DataFrame with rows/columns containing nulls dropped.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.dtypes">
<em class="property">property </em><code class="sig-name descname">dtypes</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dtypes in this object.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.fillna">
<code class="sig-name descname">fillna</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">value</em>, <em class="sig-param">method=None</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar, Series-like or dict</span></dt><dd><p>Value to use to fill nulls. If Series-like, null values
are filled with values in corresponding indices.
A dict can be used to provide different values to fill nulls
in different columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd><p>Copy with nulls filled.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  4  5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  3  5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.from_arrow">
<em class="property">classmethod </em><code class="sig-name descname">from_arrow</code><span class="sig-paren">(</span><em class="sig-param">table</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a PyArrow Table.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
<dt><strong>Notes</strong></dt><dd></dd>
<dt>Does not support automatically setting index column(s) similar to how</dt><dd></dd>
<dt><code class="docutils literal notranslate"><span class="pre">to_pandas</span></code> works for PyArrow Tables.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">,</span> <span class="s1">&#39;f1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_batches</span><span class="p">([</span><span class="n">batch</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_arrow</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
<span class="go">&lt;cudf.DataFrame ncols=2 nrows=3 &gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.from_gpu_matrix">
<em class="property">classmethod </em><code class="sig-name descname">from_gpu_matrix</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">index=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">nan_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numba gpu ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numba gpu ndarray</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">str</span></dt><dd><p>The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.from_pandas">
<em class="property">classmethod </em><code class="sig-name descname">from_pandas</code><span class="sig-paren">(</span><em class="sig-param">dataframe</em>, <em class="sig-param">nan_as_null=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a Pandas DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="go">&lt;cudf.DataFrame ncols=2 nrows=3 &gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.from_records">
<em class="property">classmethod </em><code class="sig-name descname">from_records</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">index=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">nan_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numpy recarray or structured array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy structured dtype or recarray of ndim=2</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">str</span></dt><dd><p>The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.get_renderable_dataframe">
<code class="sig-name descname">get_renderable_dataframe</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.get_renderable_dataframe" title="Permalink to this definition">¶</a></dt>
<dd><p>takes rows and columns from pandas settings or estimation from size.
pulls quadrents based off of some known parameters then style for
multiindex as well producing an efficient representative string
for printing with the dataframe.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.groupby">
<code class="sig-name descname">groupby</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">by=None</em>, <em class="sig-param">sort=True</em>, <em class="sig-param">as_index=True</em>, <em class="sig-param">method='hash'</em>, <em class="sig-param">level=None</em>, <em class="sig-param">group_keys=True</em>, <em class="sig-param">dropna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">list-of-str or str</span></dt><dd><p>Column name(s) to form that groups by.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default True</span></dt><dd><p>Force sorting group keys.</p>
</dd>
<dt><strong>as_index</strong><span class="classifier">bool, default True</span></dt><dd><p>Indicates whether the grouped by columns become the index
of the returned DataFrame</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>A string indicating the method to use to perform the group by.
Valid values are “hash” or “cudf”.
“cudf” method may be deprecated in the future, but is currently
the only method supporting group UDFs via the <cite>apply</cite> function.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), drop null keys.
If False, perform grouping by keys containing null(s).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The groupby object</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>No empty rows are returned.  (For categorical keys, pandas returns
rows for all categories even if they are no corresponding values.)</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.hash_columns">
<code class="sig-name descname">hash_columns</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.hash_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the given <em>columns</em> and return a new device array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">sequence of str; optional</span></dt><dd><p>Sequence of column names. If columns is <em>None</em> (unspecified),
all columns in the frame are used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.iat">
<code class="sig-name descname">iat</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.iat" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code>; provided for compatibility with Pandas.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.iloc">
<em class="property">property </em><code class="sig-name descname">iloc</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Selecting rows and column by position.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.loc" title="cudf.core.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.loc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))])</span>
</pre></div>
</div>
<p>Select a single row using an integer index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">a    1</span>
<span class="go">b    1</span>
<span class="go">c    1</span>
</pre></div>
</div>
<p>Select multiple rows using a list of integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">18</span><span class="p">]])</span>
<span class="go">      a    b    c</span>
<span class="go"> 0    0    0    0</span>
<span class="go"> 2    2    2    2</span>
<span class="go"> 9    9    9    9</span>
<span class="go">18   18   18   18</span>
</pre></div>
</div>
<p>Select rows using a slice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
<span class="go">     a    b    c</span>
<span class="go">3    3    3    3</span>
<span class="go">5    5    5    5</span>
<span class="go">7    7    7    7</span>
<span class="go">9    9    9    9</span>
</pre></div>
</div>
<p>Select both rows and columns.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">1    1</span>
<span class="go">3    3</span>
<span class="go">5    5</span>
<span class="go">7    7</span>
<span class="go">Name: c, dtype: int64</span>
</pre></div>
</div>
<p>Setting values in a column using iloc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b  c</span>
<span class="go">0  0  0  0</span>
<span class="go">1  0  0  0</span>
<span class="go">2  0  0  0</span>
<span class="go">3  0  0  0</span>
<span class="go">4  4  4  4</span>
<span class="go">5  5  5  5</span>
<span class="go">6  6  6  6</span>
<span class="go">7  7  7  7</span>
<span class="go">8  8  8  8</span>
<span class="go">9  9  9  9</span>
<span class="go">[10 more rows]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the DataFrame</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">loc</em>, <em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column to DataFrame at the index specified by loc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>loc</strong><span class="classifier">int</span></dt><dd><p>location to insert by index, cannot be greater then num columns + 1</p>
</dd>
<dt><strong>name</strong><span class="classifier">number or string</span></dt><dd><p>name or label of column to be inserted</p>
</dd>
<dt><strong>value</strong><span class="classifier">Series or array-like</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.isna">
<code class="sig-name descname">isna</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.isna" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify missing values in a DataFrame. Alias for isnull.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.isnull">
<code class="sig-name descname">isnull</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.isnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify missing values in a DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.iteritems">
<code class="sig-name descname">iteritems</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over column names and series pairs</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">on=None</em>, <em class="sig-param">how='left'</em>, <em class="sig-param">lsuffix=''</em>, <em class="sig-param">rsuffix=''</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">type=''</em>, <em class="sig-param">method='hash'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join columns with other DataFrame on index or on a key column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>how</strong><span class="classifier">str</span></dt><dd><p>Only accepts “left”, “right”, “inner”, “outer”</p>
</dd>
<dt><strong>lsuffix, rsuffix</strong><span class="classifier">str</span></dt><dd><p>The suffices to add to the left (<em>lsuffix</em>) and right (<em>rsuffix</em>)
column names when avoiding conflicts.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool</span></dt><dd><p>Set to True to ensure sorted ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>joined</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Difference from pandas:</p>
<ul class="simple">
<li><p><em>other</em> must be a single DataFrame for now.</p></li>
<li><p><em>on</em> is not supported yet due to lack of multi-index support.</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.label_encoding">
<code class="sig-name descname">label_encoding</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">column</em>, <em class="sig-param">prefix</em>, <em class="sig-param">cats</em>, <em class="sig-param">prefix_sep='_'</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode labels in a column with label encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">str</span></dt><dd><p>the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>the new column name prefix.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">sequence of ints</span></dt><dd><p>the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str</span></dt><dd><p>the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt><dd><p>the dtype for the outputs; see Series.label_encoding</p>
</dd>
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>a new dataframe with a new column append for the coded values.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.loc">
<em class="property">property </em><code class="sig-name descname">loc</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Selecting rows and columns by label or boolean mask.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iloc" title="cudf.core.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>DataFrame with string index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">a  0  5</span>
<span class="go">b  1  6</span>
<span class="go">c  2  7</span>
<span class="go">d  3  8</span>
<span class="go">e  4  9</span>
</pre></div>
</div>
<p>Select a single row by label.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
<span class="go">a    0</span>
<span class="go">b    5</span>
<span class="go">Name: a, dtype: int64</span>
</pre></div>
</div>
<p>Select multiple rows and a single column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="go">a    5</span>
<span class="go">c    7</span>
<span class="go">e    9</span>
<span class="go">Name: b, dtype: int64</span>
</pre></div>
</div>
<p>Selection by boolean mask.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">   a  b</span>
<span class="go">d  3  8</span>
<span class="go">e  4  9</span>
</pre></div>
</div>
<p>Setting values using loc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">a  0  5</span>
<span class="go">b  1  6</span>
<span class="go">c  0  7</span>
<span class="go">d  3  8</span>
<span class="go">e  0  9</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">numeric_only=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the values for the requested axis.
Parameters
———-
axis : {index (0), columns (1)}</p>
<blockquote>
<div><p>Axis for the function to be applied on.</p>
</div></blockquote>
<dl class="simple">
<dt>skipna<span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt>level<span class="classifier">int or level name, default None</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt>numeric_only<span class="classifier">bool, default None</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to
use everything, then use only numeric data. Not implemented for
Series.</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs</dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
<p>mean : Series or DataFrame (if level specified)</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.melt">
<code class="sig-name descname">melt</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.
default: None</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot.
default: all columns that are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the <cite>variable</cite> column.
default: frame.columns.name or ‘variable’</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">str</span></dt><dd><p>Name to use for the <cite>value</cite> column.
default: ‘value’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>Melted result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.merge">
<code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">right</em>, <em class="sig-param">on=None</em>, <em class="sig-param">how='inner'</em>, <em class="sig-param">left_on=None</em>, <em class="sig-param">right_on=None</em>, <em class="sig-param">left_index=False</em>, <em class="sig-param">right_index=False</em>, <em class="sig-param">sort=False</em>, <em class="sig-param">lsuffix=None</em>, <em class="sig-param">rsuffix=None</em>, <em class="sig-param">type=''</em>, <em class="sig-param">method='hash'</em>, <em class="sig-param">indicator=False</em>, <em class="sig-param">suffixes=('_x'</em>, <em class="sig-param">'_y')</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge GPU DataFrame objects by performing a database-style join
operation by columns or indexes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>right</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>on</strong><span class="classifier">label or list; defaults to None</span></dt><dd><p>Column or index level names to join on. These must be found in
both DataFrames.</p>
<p>If on is None and not merging on indexes then
this defaults to the intersection of the columns
in both DataFrames.</p>
</dd>
<dt><strong>how</strong><span class="classifier">{‘left’, ‘outer’, ‘inner’}, default ‘inner’</span></dt><dd><p>Type of merge to be performed.</p>
<ul class="simple">
<li><p>left : use only keys from left frame, similar to a SQL left
outer join; preserve key order.</p></li>
<li><p>right : not supported.</p></li>
<li><p>outer : use union of keys from both frames, similar to a SQL
full outer join; sort keys lexicographically.</p></li>
<li><p>inner: use intersection of keys from both frames, similar to
a SQL inner join; preserve the order of the left keys.</p></li>
</ul>
</dd>
<dt><strong>left_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the left DataFrame.
Can also be an array or list of arrays of the length of the
left DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>right_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the right DataFrame.
Can also be an array or list of arrays of the length of the
right DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>left_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the left DataFrame as the join key(s).</p>
</dd>
<dt><strong>right_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the right DataFrame as the join key.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default False</span></dt><dd><p>Sort the join keys lexicographically in the result DataFrame.
If False, the order of the join keys depends on the join type
(see the <cite>how</cite> keyword).</p>
</dd>
<dt><strong>suffixes: Tuple[str, str], defaults to (‘_x’, ‘_y’)</strong></dt><dd><p>Suffixes applied to overlapping column names on the left and right
sides</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘hash’, ‘sort’}, default ‘hash’</span></dt><dd><p>The implementation method to be used for the operation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>merged</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">&#39;vals_a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;vals_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span> <span class="o">=</span> <span class="n">df_a</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_b</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>  
<span class="go">   key  vals_a  vals_b</span>
<span class="go">3    0    10.0</span>
<span class="go">0    1    11.0    10.0</span>
<span class="go">1    2    12.0    11.0</span>
<span class="go">4    3    13.0</span>
<span class="go">2    4    14.0    12.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.nans_to_nulls">
<code class="sig-name descname">nans_to_nulls</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.nans_to_nulls" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert nans (if any) to nulls.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the data. DataFrame ndim is always 2.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.nlargest">
<code class="sig-name descname">nlargest</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">columns</em>, <em class="sig-param">keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p>
<p class="rubric">Notes</p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.notna">
<code class="sig-name descname">notna</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.notna" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify non-missing values in a DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.notnull">
<code class="sig-name descname">notnull</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.notnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify non-missing values in a DataFrame. Alias for notna.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.nsmallest">
<code class="sig-name descname">nsmallest</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n</em>, <em class="sig-param">columns</em>, <em class="sig-param">keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.one_hot_encoding">
<code class="sig-name descname">one_hot_encoding</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">column</em>, <em class="sig-param">prefix</em>, <em class="sig-param">cats</em>, <em class="sig-param">prefix_sep='_'</em>, <em class="sig-param">dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a column with one-hot-encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">str</span></dt><dd><p>the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>the new column name prefix.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">sequence of ints</span></dt><dd><p>the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str</span></dt><dd><p>the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt><dd><p>the dtype for the outputs; defaults to float64.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a new dataframe with new columns append for each category.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_owner</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;pet_owner&#39;</span><span class="p">:</span> <span class="n">pet_owner</span><span class="p">,</span> <span class="s1">&#39;pet_type&#39;</span><span class="p">:</span> <span class="n">pet_type</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">pet_type</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a column with numerically encoded category values</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Create the list of category codes to use in the encoding</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">pet_codes</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">one_hot_encoding</span><span class="p">(</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">,</span> <span class="s1">&#39;pet_dummy&#39;</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">  pet_owner  pet_type  pet_codes  pet_dummy_0  pet_dummy_1  pet_dummy_2</span>
<span class="go">0         1      fish          2          0.0          0.0          1.0</span>
<span class="go">1         2       dog          1          0.0          1.0          0.0</span>
<span class="go">2         3      fish          2          0.0          0.0          1.0</span>
<span class="go">3         4      bird          0          1.0          0.0          0.0</span>
<span class="go">4         5      fish          2          0.0          0.0          1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.partition_by_hash">
<code class="sig-name descname">partition_by_hash</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">columns</em>, <em class="sig-param">nparts</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.partition_by_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>The names of the columns to be hashed.
Must have at least one name.</p>
</dd>
<dt><strong>nparts</strong><span class="classifier">int</span></dt><dd><p>Number of output partitions</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>partitioned: list of DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">item</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a column and drop it from the DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for product.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">q=0.5</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">numeric_only=True</em>, <em class="sig-param">interpolation='linear'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">exact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>q</strong><span class="classifier">float or array-like</span></dt><dd><p>0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>axis is a NON-FUNCTIONAL parameter</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">boolean</span></dt><dd><p>numeric_only is a NON-FUNCTIONAL parameter</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{<cite>linear</cite>, <cite>lower</cite>, <cite>higher</cite>, <cite>midpoint</cite>, <cite>nearest</cite>}</span></dt><dd><p>This  parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j.
Default ‘linear’.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use approximate or exact quantile algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.query">
<code class="sig-name descname">query</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">expr</em>, <em class="sig-param">local_dict={}</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Query with a boolean expression using Numba to compile a GPU kernel.</p>
<p>See pandas.DataFrame.query.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>expr</strong><span class="classifier">str</span></dt><dd><p>A boolean expression. Names in expression refer to columns.</p>
<p>Names starting with <cite>&#64;</cite> refer to Python variables.</p>
<p>An output value will be <cite>null</cite> if any of the input values are
<cite>null</cite> regardless of expression.</p>
</dd>
<dt><strong>local_dict</strong><span class="classifier">dict</span></dt><dd><p>Containing the local variable to be used in query.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;(a == 2 and b == 4) or (b == 3)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
</pre></div>
</div>
<p>DateTime conditionals:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;2018-10-07&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-10-08&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetimes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-08&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;datetimes==@search_date&#39;</span><span class="p">))</span>
<span class="go">                datetimes</span>
<span class="go">1 2018-10-08T00:00:00.000</span>
</pre></div>
</div>
<p>Using local_dict:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;2018-10-07&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-10-08&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetimes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_date2</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-08&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;datetimes==@search_date&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">local_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;search_date&#39;</span><span class="p">:</span><span class="n">search_date2</span><span class="p">}))</span>
<span class="go">                datetimes</span>
<span class="go">1 2018-10-08T00:00:00.000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">labels=None</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">index=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame whose axes conform to a new index</p>
<p><code class="docutils literal notranslate"><span class="pre">DataFrame.reindex</span></code> supports two calling conventions
* <code class="docutils literal notranslate"><span class="pre">(index=index_labels,</span> <span class="pre">columns=column_names)</span></code>
* <code class="docutils literal notranslate"><span class="pre">(labels,</span> <span class="pre">axis={0</span> <span class="pre">or</span> <span class="pre">'index',</span> <span class="pre">1</span> <span class="pre">or</span> <span class="pre">'columns'})</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">Index, Series-convertible, optional, default None</span></dt><dd></dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, optional, default 0</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">Index, Series-convertible, optional, default None</span></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">df.reindex(labels=index_labels,</span> <span class="pre">axis=0)</span></code></p>
</dd>
<dt><strong>columns</strong><span class="classifier">array-like, optional, default None</span></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">df.reindex(labels=column_names,</span> <span class="pre">axis=1)</span></code></p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, optional, default True</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A DataFrame whose axes conform to the new index(es)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_new</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="go">                        columns=[&#39;key&#39;, &#39;val&#39;, &#39;sum&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_new</span><span class="p">)</span>
<span class="go">   key   val  sum</span>
<span class="go">0    0  10.0  NaN</span>
<span class="go">3    3  13.0  NaN</span>
<span class="go">4    4  14.0  NaN</span>
<span class="go">5   -1   NaN  NaN</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.rename">
<code class="sig-name descname">rename</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">mapper=None</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">copy=True</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter column labels.</p>
<p>Function / dict values must be unique (1-to-1). Labels not contained in
a dict / Series will be left as-is. Extra labels listed don’t throw an
error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapper, columns</strong><span class="classifier">dict-like or function, optional</span></dt><dd><p>dict-like or functions transformations to apply to
the column axis’ values.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd><p>Also copy underlying data</p>
</dd>
<dt><strong>inplace: boolean, default False</strong></dt><dd><p>Return new DataFrame.  If True, assign columns without copy</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Support axis=’columns’ only.</p></li>
<li><p>Not supporting: index, level</p></li>
</ul>
</dd>
</dl>
<p>Rename will not overwite column names. If a list with duplicates it
passed, column names will be postfixed.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">to_replace</em>, <em class="sig-param">replacement</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <em>to_replace</em> with <em>replacement</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>to_replace</strong><span class="classifier">numeric, str, list-like or dict</span></dt><dd><p>Value(s) to replace.</p>
<ul>
<li><p>numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>values equal to <em>to_replace</em> will be replaced
with <em>replacement</em></p></li>
</ul>
</div></blockquote>
</li>
<li><p>list of numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <em>replacement</em> is also list-like,
<em>to_replace</em> and <em>replacement</em> must be of same length.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>dict:</p>
<blockquote>
<div><ul class="simple">
<li><p>Dicts can be used to replace different values in different
columns. For example, <cite>{‘a’: 1, ‘z’: 2}</cite> specifies that the
value 1 in column <cite>a</cite> and the value 2 in column <cite>z</cite> should be
replaced with replacement*.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>replacement</strong><span class="classifier">numeric, str, list-like, or dict</span></dt><dd><p>Value(s) to replace <cite>to_replace</cite> with. If a dict is provided, then
its keys must match the keys in <em>to_replace</em>, and correponding
values must be compatible (e.g., if they are lists, then they must
match in length).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd><p>DataFrame after replacement.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.rolling">
<code class="sig-name descname">rolling</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">window</em>, <em class="sig-param">min_periods=None</em>, <em class="sig-param">center=False</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">win_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolling window calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window</strong><span class="classifier">int or offset</span></dt><dd><p>Size of the window, i.e., the number of observations used
to calculate the statistic.
For datetime indexes, an offset can be provided instead
of an int. The offset must be convertible to a timedelta.
As opposed to a fixed window size, each window will be
sized to accommodate observations within the time period
specified by the offset.</p>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>The minimum number of observations in the window that are
required to be non-null, so that the result is non-null.
If not provided or <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> is equal to
the window size.</p>
</dd>
<dt><strong>center</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result is set at the center of the window.
If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), the result is set at the right edge
of the window.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Rolling</span></code> object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>Rolling sum with window size 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling sum with window size 2 and min_periods 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    2</span>
<span class="go">4    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3, but with the result set at the
center of the window.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    2</span>
<span class="go">1    3</span>
<span class="go">2    2</span>
<span class="go">3    2</span>
<span class="go">4    1 dtype: int64</span>
</pre></div>
</div>
<p>Rolling max with variable window size specified by an offset;
only valid for datetime index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:00&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:01&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:02&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:04&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:07&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:08&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">&#39;2s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="go">2019-01-01T09:00:00.000    1</span>
<span class="go">2019-01-01T09:00:01.000    9</span>
<span class="go">2019-01-01T09:00:02.000    9</span>
<span class="go">2019-01-01T09:00:04.000    4</span>
<span class="go">2019-01-01T09:00:07.000</span>
<span class="go">2019-01-01T09:00:08.000    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Apply custom function on the window with the <em>apply</em> method</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">0     4.0</span>
<span class="go">1     9.0</span>
<span class="go">2    15.0</span>
<span class="go">3    18.0</span>
<span class="go">4    21.0</span>
<span class="go">5    24.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>And this also works for window rolling set by an offset</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:00&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:01&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:02&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:04&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:07&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:08&#39;</span><span class="p">)</span>
<span class="gp">... </span>     <span class="p">],</span>
<span class="gp">... </span>    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">&#39;2s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">2019-01-01T09:00:00.000     4.0</span>
<span class="go">2019-01-01T09:00:01.000     9.0</span>
<span class="go">2019-01-01T09:00:02.000    11.0</span>
<span class="go">2019-01-01T09:00:04.000     7.0</span>
<span class="go">2019-01-01T09:00:07.000     8.0</span>
<span class="go">2019-01-01T09:00:08.000    17.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.scatter_by_map">
<code class="sig-name descname">scatter_by_map</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">map_index</em>, <em class="sig-param">map_size=None</em>, <em class="sig-param">keep_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.scatter_by_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Scatter to a list of dataframes.</p>
<p>Uses map_index to determine the destination
of each row of the original DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>map_index</strong><span class="classifier">Series, str or list-like</span></dt><dd><p>Scatter assignment for each row</p>
</dd>
<dt><strong>map_size</strong><span class="classifier">int</span></dt><dd><p>Length of output list. Must be &gt;= uniques in map_index</p>
</dd>
<dt><strong>keep_index</strong><span class="classifier">bool</span></dt><dd><p>Conserve original index values for each row</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A list of cudf.DataFrame objects.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.select_dtypes">
<code class="sig-name descname">select_dtypes</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">include=None</em>, <em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.select_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>include</strong><span class="classifier">str or list</span></dt><dd><p>which columns to include based on dtypes</p>
</dd>
<dt><strong>exclude</strong><span class="classifier">str or list</span></dt><dd><p>which columns to exclude based on dtypes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.set_index">
<code class="sig-name descname">set_index</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">index</em>, <em class="sig-param">drop=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame with a new index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible, str, or list of str</span></dt><dd><p>Index : the new index.
Series-convertible : values for the new index.
str : name of column to be used as series
list of str : name of columns to be converted to a MultiIndex</p>
</dd>
<dt><strong>drop</strong><span class="classifier">boolean</span></dt><dd><p>whether to drop corresponding column for str index argument</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.sort_index">
<code class="sig-name descname">sort_index</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.sort_values">
<code class="sig-name descname">sort_values</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">by</em>, <em class="sig-param">ascending=True</em>, <em class="sig-param">na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values row-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">str or list of str</span></dt><dd><p>Name or list of names to sort by.</p>
</dd>
<dt><strong>ascending</strong><span class="classifier">bool or list of bool, default True</span></dt><dd><p>Sort ascending vs. descending. Specify list for multiple sort
orders. If this is a list of bools, must match the length of the
by.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>sorted_obj</strong><span class="classifier">cuDF DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Support axis=’index’ only.</p></li>
<li><p>Not supporting: inplace, kind</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  0 -3</span>
<span class="go">2  2  0</span>
<span class="go">1  1  2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.stack">
<code class="sig-name descname">stack</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">level=-1</em>, <em class="sig-param">dropna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack the prescribed level(s) from columns to index</p>
<p>Return a reshaped Series</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dropna</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to drop rows in the resulting Series with missing values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The stacked cudf.Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span>
<span class="go">0  a    0</span>
<span class="go">   b    1</span>
<span class="go">1  a    1</span>
<span class="go">   b    2</span>
<span class="go">2  a    3</span>
<span class="go">   b    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.tile">
<code class="sig-name descname">tile</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">reps</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.tile" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a DataFrame by repeating this DataFrame the number of
times given by reps</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reps</strong><span class="classifier">non-negative integer</span></dt><dd><p>The number of repetitions of this DataFrame along axis 0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The tiled output cudf.DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_arrow">
<code class="sig-name descname">to_arrow</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">preserve_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a PyArrow Table.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span>
<span class="go">pyarrow.Table</span>
<span class="go">None: int64</span>
<span class="go">a: int64</span>
<span class="go">b: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_csv">
<code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">path=None</em>, <em class="sig-param">sep='</em>, <em class="sig-param">'</em>, <em class="sig-param">na_rep=''</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">header=True</em>, <em class="sig-param">index=True</em>, <em class="sig-param">line_terminator='n'</em>, <em class="sig-param">chunksize=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a dataframe to csv file format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>DataFrame object to be written to csv</p>
</dd>
<dt><strong>path</strong><span class="classifier">str, default None</span></dt><dd><p>Path of file where DataFrame will be written</p>
</dd>
<dt><strong>sep</strong><span class="classifier">char, default ‘,’</span></dt><dd><p>Delimiter to be used.</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">str, default ‘’</span></dt><dd><p>String to use for null entries</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str, optional</span></dt><dd><p>Columns to write</p>
</dd>
<dt><strong>header</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the column names</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the index as a column</p>
</dd>
<dt><strong>line_terminator</strong><span class="classifier">char, default ‘n’</span></dt><dd></dd>
<dt><strong>chunksize</strong><span class="classifier">int or None, default None</span></dt><dd><p>Rows to write at a time</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.read_csv" title="cudf.io.csv.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.read_csv</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Follows the standard of Pandas csv.QUOTE_NONNUMERIC for all output.</p></li>
<li><p>If <cite>to_csv</cite> leads to memory errors consider setting the <cite>chunksize</cite> argument.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Write a dataframe to csv.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foo.csv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="go">                         &#39;y&#39;: [1.0, 3.3, 2.2, 4.4],</span>
<span class="go">                         &#39;z&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_dlpack">
<code class="sig-name descname">to_dlpack</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_feather">
<code class="sig-name descname">to_feather</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">path</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_gpu_matrix">
<code class="sig-name descname">to_gpu_matrix</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numba gpu ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numba gpu ndarray</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_hdf">
<code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">path_or_buf</em>, <em class="sig-param">key</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,
nor searchable.</p></li>
<li><p>‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p></li>
</ul>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">path_or_buf=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Series</dt><dd><ul>
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>DataFrame</dt><dd><ul>
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:
{‘split’,’records’,’index’,’columns’,’values’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The format of the JSON string</dt><dd><ul>
<li><p>‘split’ : dict like {‘index’ -&gt; [index],
‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}</p></li>
<li><p>‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]</p></li>
<li><p>‘index’ : dict like {index -&gt; {column -&gt; value}}</p></li>
<li><p>‘columns’ : dict like {column -&gt; {index -&gt; value}}</p></li>
<li><p>‘values’ : just the values array</p></li>
<li><p>‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_orc">
<code class="sig-name descname">to_orc</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fname</em>, <em class="sig-param">compression=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the ORC format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fname</strong><span class="classifier">str</span></dt><dd><p>File path or object where the ORC dataset will be stored.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{{ ‘snappy’, None }}, default None</span></dt><dd><p>Name of the compression to use. Use None for no compression.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_pandas">
<code class="sig-name descname">to_pandas</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas DataFrame.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_parquet">
<code class="sig-name descname">to_parquet</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">path</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt><dd><p>Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong><span class="classifier">list, optional, default None</span></dt><dd><p>Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_records">
<code class="sig-name descname">to_records</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numpy recarray</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool</span></dt><dd><p>Whether to include the index in the output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy recarray</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.to_string">
<code class="sig-name descname">to_string</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<p>cuDF uses Pandas internals for efficient string formatting.
Set formatting options using pandas string formatting options and
cuDF objects will print identically to Pandas objects.</p>
<p>cuDF supports <cite>null/None</cite> as a value in any column type, which
is transparently supported during this output process.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
<span class="go">&#39;   key   val\n0    0  10.0\n1    1  11.0\n2    2  12.0&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.dataframe.DataFrame.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose index and columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>a new (ncol x nrow) dataframe. self is (nrow x ncol)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Difference from pandas:
Not supporting <em>copy</em> because default and only behaviour is copy=True</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cudf.core.reshape"></span><dl class="function">
<dt id="cudf.core.reshape.concat">
<code class="sig-prename descclassname">cudf.core.reshape.</code><code class="sig-name descname">concat</code><span class="sig-paren">(</span><em class="sig-param">objs</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">ignore_index=False</em>, <em class="sig-param">sort=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.reshape.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate DataFrames, Series, or Indices row-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>objs</strong><span class="classifier">list of DataFrame, Series, or Index</span></dt><dd></dd>
<dt><strong>axis</strong><span class="classifier">{0/’index’, 1/’columns’}, default 0</span></dt><dd><p>The axis to concatenate along.</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Set True to ignore the index of the <em>objs</em> and provide a
default range index instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new object of like type with rows from each object in <code class="docutils literal notranslate"><span class="pre">objs</span></code>.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cudf.core.reshape.get_dummies">
<code class="sig-prename descclassname">cudf.core.reshape.</code><code class="sig-name descname">get_dummies</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">prefix=None</em>, <em class="sig-param">prefix_sep='_'</em>, <em class="sig-param">dummy_na=False</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">cats={}</em>, <em class="sig-param">sparse=False</em>, <em class="sig-param">drop_first=False</em>, <em class="sig-param">dtype='int8'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.reshape.get_dummies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dataframe whose columns are the one hot encodings of all
columns in <cite>df</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>dataframe to encode</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str, dict, or sequence, optional</span></dt><dd><p>prefix to append. Either a str (to apply a constant prefix), dict
mapping column names to prefixes, or sequence of prefixes to apply with
the same length as the number of columns. If not supplied, defaults
to the empty string</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str, dict, or sequence, optional, default ‘_’</span></dt><dd><p>separator to use when appending prefixes</p>
</dd>
<dt><strong>dummy_na</strong><span class="classifier">boolean, optional</span></dt><dd><p>Right now this is NON-FUNCTIONAL argument in rapids.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">dict, optional</span></dt><dd><p>dictionary mapping column names to sequences of integers representing
that column’s category. See <cite>cudf.DataFrame.one_hot_encoding</cite> for more
information. if not supplied, it will be computed</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">boolean, optional</span></dt><dd><p>Right now this is NON-FUNCTIONAL argument in rapids.</p>
</dd>
<dt><strong>drop_first</strong><span class="classifier">boolean, optional</span></dt><dd><p>Right now this is NON-FUNCTIONAL argument in rapids.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">sequence of str, optional</span></dt><dd><p>Names of columns to encode. If not provided, will attempt to encode all
columns. Note this is different from pandas default behavior, which
encodes all columns with dtype object or categorical</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">str, optional</span></dt><dd><p>output dtype, default ‘int8’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cudf.core.reshape.melt">
<code class="sig-prename descclassname">cudf.core.reshape.</code><code class="sig-name descname">melt</code><span class="sig-paren">(</span><em class="sig-param">frame</em>, <em class="sig-param">id_vars=None</em>, <em class="sig-param">value_vars=None</em>, <em class="sig-param">var_name=None</em>, <em class="sig-param">value_name='value'</em>, <em class="sig-param">col_level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.reshape.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.
default: None</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot.
default: all columns that are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the <cite>variable</cite> column.
default: frame.columns.name or ‘variable’</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">str</span></dt><dd><p>Name to use for the <cite>value</cite> column.
default: ‘value’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>Melted result</p>
</dd>
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Does not support ‘col_level’ because cuDF does not have multi-index</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="n">value_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="go">     A    B variable value</span>
<span class="go">0    1    1        C   1.0</span>
<span class="go">1    1    3        C</span>
<span class="go">2    5    6        C   4.0</span>
<span class="go">3    1    1        D   2.0</span>
<span class="go">4    1    3        D   5.0</span>
<span class="go">5    5    6        D   6.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.core.series.Series">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.series.</code><code class="sig-name descname">Series</code><span class="sig-paren">(</span><em class="sig-param">data=None</em>, <em class="sig-param">index=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">nan_as_null=True</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series" title="Permalink to this definition">¶</a></dt>
<dd><p>Data and null-masks.</p>
<p><code class="docutils literal notranslate"><span class="pre">Series</span></code> objects are used as columns of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cat</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.data" title="cudf.core.series.Series.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a></dt><dd><p>The gpu buffer for the data</p>
</dd>
<dt><strong>dt</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.dtype" title="cudf.core.series.Series.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p>dtype of the Series</p>
</dd>
<dt><strong>empty</strong></dt><dd></dd>
<dt><strong>has_nulls</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.iloc" title="cudf.core.series.Series.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt><dd><p>Select values by position.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.index" title="cudf.core.series.Series.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt><dd><p>The index object</p>
</dd>
<dt><strong>is_monotonic</strong></dt><dd></dd>
<dt><strong>is_monotonic_decreasing</strong></dt><dd></dd>
<dt><strong>is_monotonic_increasing</strong></dt><dd></dd>
<dt><strong>is_unique</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.loc" title="cudf.core.series.Series.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt><dd><p>Select values by label.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.name" title="cudf.core.series.Series.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>Returns name of the Series.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.ndim" title="cudf.core.series.Series.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>Dimension of the data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.null_count" title="cudf.core.series.Series.null_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">null_count</span></code></a></dt><dd><p>Number of null values</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.nullable" title="cudf.core.series.Series.nullable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nullable</span></code></a></dt><dd><p>A boolean indicating whether a null-mask is needed</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.nullmask" title="cudf.core.series.Series.nullmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nullmask</span></code></a></dt><dd><p>The gpu buffer for the null-mask</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.shape" title="cudf.core.series.Series.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd>
<dt><strong>str</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.valid_count" title="cudf.core.series.Series.valid_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">valid_count</span></code></a></dt><dd><p>Number of non-null values</p>
</dd>
<dt><strong>values</strong></dt><dd></dd>
<dt><strong>values_host</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.abs" title="cudf.core.series.Series.abs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a>(self)</p></td>
<td><p>Absolute value of each element of the series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.add" title="cudf.core.series.Series.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Addition of series and other, element-wise (binary operator add).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.append" title="cudf.core.series.Series.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(self, other[, ignore_index])</p></td>
<td><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.applymap" title="cudf.core.series.Series.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">applymap</span></code></a>(self, udf[, out_dtype])</p></td>
<td><p>Apply a elemenwise function to transform the values in the Column.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.argsort" title="cudf.core.series.Series.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>(self[, ascending, na_position])</p></td>
<td><p>Returns a Series of int64 index that will sort the series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.as_mask" title="cudf.core.series.Series.as_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_mask</span></code></a>(self)</p></td>
<td><p>Convert booleans to bitmask</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.astype" title="cudf.core.series.Series.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(self, dtype[, errors])</p></td>
<td><p>Cast the Series to the given dtype</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.ceil" title="cudf.core.series.Series.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>(self)</p></td>
<td><p>Rounds each value upward to the smallest integral value not less than the original.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.corr" title="cudf.core.series.Series.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">corr</span></code></a>(self, other[, method, min_periods])</p></td>
<td><p>Calculates the sample correlation between two Series, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.count" title="cudf.core.series.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(self[, axis, skipna])</p></td>
<td><p>The number of non-null values</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.cov" title="cudf.core.series.Series.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cov</span></code></a>(self, other[, min_periods])</p></td>
<td><p>Calculates the sample covariance between two Series, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.cummax" title="cudf.core.series.Series.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummax</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative maximum of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.cummin" title="cudf.core.series.Series.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummin</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative minimum of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.cumprod" title="cudf.core.series.Series.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative product of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.cumsum" title="cudf.core.series.Series.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the cumulative sum of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.describe" title="cudf.core.series.Series.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">describe</span></code></a>(self[, percentiles, include, exclude])</p></td>
<td><p>Compute summary statistics of a Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.diff" title="cudf.core.series.Series.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>(self[, periods])</p></td>
<td><p>Calculate the difference between values at positions i and i - N in an array and store the output in a new array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.digitize" title="cudf.core.series.Series.digitize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">digitize</span></code></a>(self, bins[, right])</p></td>
<td><p>Return the indices of the bins to which each value in series belongs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.drop_duplicates" title="cudf.core.series.Series.drop_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_duplicates</span></code></a>(self[, keep, inplace])</p></td>
<td><p>Return Series with duplicate values removed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.dropna" title="cudf.core.series.Series.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dropna</span></code></a>(self)</p></td>
<td><p>Return a Series with null values removed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.eq" title="cudf.core.series.Series.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eq</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Equal to of series and other, element-wise (binary operator eq).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.factorize" title="cudf.core.series.Series.factorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorize</span></code></a>(self[, na_sentinel])</p></td>
<td><p>Encode the input values as integer labels</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.fillna" title="cudf.core.series.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(self, value[, method, axis, inplace, …])</p></td>
<td><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.find_first_value" title="cudf.core.series.Series.find_first_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_first_value</span></code></a>(self, value)</p></td>
<td><p>Returns offset of first value that matches</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.find_last_value" title="cudf.core.series.Series.find_last_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_last_value</span></code></a>(self, value)</p></td>
<td><p>Returns offset of last value that matches</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.floor" title="cudf.core.series.Series.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>(self)</p></td>
<td><p>Rounds each value downward to the largest integral value not greater than the original.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.floordiv" title="cudf.core.series.Series.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floordiv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Integer division of series and other, element-wise (binary operator floordiv).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.from_categorical" title="cudf.core.series.Series.from_categorical"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_categorical</span></code></a>(categorical[, codes])</p></td>
<td><p>Creates from a pandas.Categorical</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.from_masked_array" title="cudf.core.series.Series.from_masked_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_masked_array</span></code></a>(data, mask[, null_count])</p></td>
<td><p>Create a Series with null-mask.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.ge" title="cudf.core.series.Series.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ge</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Greater than or equal to of series and other, element-wise (binary operator ge).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.gt" title="cudf.core.series.Series.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gt</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Greater than of series and other, element-wise (binary operator gt).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.hash_encode" title="cudf.core.series.Series.hash_encode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_encode</span></code></a>(self, stop[, use_name])</p></td>
<td><p>Encode column values as ints in [0, stop) using hash function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.hash_values" title="cudf.core.series.Series.hash_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_values</span></code></a>(self)</p></td>
<td><p>Compute the hash of values in this column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.isna" title="cudf.core.series.Series.isna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isna</span></code></a>(self)</p></td>
<td><p>Identify missing values in a Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.isnull" title="cudf.core.series.Series.isnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnull</span></code></a>(self)</p></td>
<td><p>Identify missing values in a Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.kurtosis" title="cudf.core.series.Series.kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis</span></code></a>(self[, axis, skipna, level, …])</p></td>
<td><p>Calculates Fisher’s unbiased kurtosis of a sample.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.label_encoding" title="cudf.core.series.Series.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(self, cats[, dtype, na_sentinel])</p></td>
<td><p>Perform label encoding</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.le" title="cudf.core.series.Series.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">le</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Less than or equal to of series and other, element-wise (binary operator le).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.lt" title="cudf.core.series.Series.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lt</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Less than of series and other, element-wise (binary operator lt).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.max" title="cudf.core.series.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the max of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.mean" title="cudf.core.series.Series.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Compute the mean of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.median" title="cudf.core.series.Series.median"><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code></a>(self[, skipna])</p></td>
<td><p>Compute the median of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.min" title="cudf.core.series.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the min of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.mod" title="cudf.core.series.Series.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mod</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Modulo of series and other, element-wise (binary operator mod).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.mul" title="cudf.core.series.Series.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mul</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Multiplication of series and other, element-wise (binary operator mul).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.nans_to_nulls" title="cudf.core.series.Series.nans_to_nulls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nans_to_nulls</span></code></a>(self)</p></td>
<td><p>Convert nans (if any) to nulls</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.ne" title="cudf.core.series.Series.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ne</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Not equal to of series and other, element-wise (binary operator ne).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.nlargest" title="cudf.core.series.Series.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(self[, n, keep])</p></td>
<td><p>Returns a new Series of the <em>n</em> largest element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.notna" title="cudf.core.series.Series.notna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">notna</span></code></a>(self)</p></td>
<td><p>Identify non-missing values in a Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.notnull" title="cudf.core.series.Series.notnull"><code class="xref py py-obj docutils literal notranslate"><span class="pre">notnull</span></code></a>(self)</p></td>
<td><p>Identify non-missing values in a Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.nsmallest" title="cudf.core.series.Series.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(self[, n, keep])</p></td>
<td><p>Returns a new Series of the <em>n</em> smallest element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.nunique" title="cudf.core.series.Series.nunique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nunique</span></code></a>(self[, method, dropna])</p></td>
<td><p>Returns the number of unique values of the Series: approximate version, and exact version to be moved to libgdf</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.one_hot_encoding" title="cudf.core.series.Series.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(self, cats[, dtype])</p></td>
<td><p>Perform one-hot-encoding</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.pow" title="cudf.core.series.Series.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pow</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Exponential power of series and other, element-wise (binary operator pow).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.prod" title="cudf.core.series.Series.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Alias for product</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.product" title="cudf.core.series.Series.product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">product</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the product of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.quantile" title="cudf.core.series.Series.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(self[, q, interpolation, exact, …])</p></td>
<td><p>Return values at the given quantile.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.radd" title="cudf.core.series.Series.radd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radd</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Addition of series and other, element-wise (binary operator radd).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.reindex" title="cudf.core.series.Series.reindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></a>(self[, index, copy])</p></td>
<td><p>Return a Series that conforms to a new index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rename" title="cudf.core.series.Series.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(self[, index, copy])</p></td>
<td><p>Alter Series name.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.replace" title="cudf.core.series.Series.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(self, to_replace, replacement)</p></td>
<td><p>Replace values given in <em>to_replace</em> with <em>replacement</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.reset_index" title="cudf.core.series.Series.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_index</span></code></a>(self[, drop, inplace])</p></td>
<td><p>Reset index to RangeIndex</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.reverse" title="cudf.core.series.Series.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>(self)</p></td>
<td><p>Reverse the Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rfloordiv" title="cudf.core.series.Series.rfloordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfloordiv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Integer division of series and other, element-wise (binary operator rfloordiv).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rmod" title="cudf.core.series.Series.rmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rmod</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Modulo of series and other, element-wise (binary operator rmod).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rmul" title="cudf.core.series.Series.rmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rmul</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Multiplication of series and other, element-wise (binary operator rmul).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rolling" title="cudf.core.series.Series.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling</span></code></a>(self, window[, min_periods, center, …])</p></td>
<td><p>Rolling window calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.round" title="cudf.core.series.Series.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code></a>(self[, decimals])</p></td>
<td><p>Round a Series to a configurable number of decimal places.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rpow" title="cudf.core.series.Series.rpow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpow</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Exponential power of series and other, element-wise (binary operator rpow).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rsub" title="cudf.core.series.Series.rsub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsub</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Subtraction of series and other, element-wise (binary operator rsub).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rtruediv" title="cudf.core.series.Series.rtruediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtruediv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Floating division of series and other, element-wise (binary operator rtruediv).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.scale" title="cudf.core.series.Series.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a>(self)</p></td>
<td><p>Scale values to [0, 1] in float64</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.searchsorted" title="cudf.core.series.Series.searchsorted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">searchsorted</span></code></a>(self, value[, side])</p></td>
<td><p>Find indices where elements should be inserted to maintain order</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.set_index" title="cudf.core.series.Series.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(self, index)</p></td>
<td><p>Returns a new Series with a different index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.set_mask" title="cudf.core.series.Series.set_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_mask</span></code></a>(self, mask[, null_count])</p></td>
<td><p>Create new Series by setting a mask array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.shift" title="cudf.core.series.Series.shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shift</span></code></a>(self[, periods, freq, axis, fill_value])</p></td>
<td><p>Shift values of an input array by periods positions and store the output in a new array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.skew" title="cudf.core.series.Series.skew"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skew</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Calculates the unbiased Fisher-Pearson skew of a sample.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.sort_index" title="cudf.core.series.Series.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>(self[, ascending])</p></td>
<td><p>Sort by the index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.sort_values" title="cudf.core.series.Series.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(self[, ascending, na_position])</p></td>
<td><p>Sort by the values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.std" title="cudf.core.series.Series.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>(self[, ddof, axis, skipna])</p></td>
<td><p>Compute the standard deviation of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.sub" title="cudf.core.series.Series.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Subtraction of series and other, element-wise (binary operator sub).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.sum" title="cudf.core.series.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(self[, axis, skipna, dtype])</p></td>
<td><p>Compute the sum of the series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.tail" title="cudf.core.series.Series.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>(self[, n])</p></td>
<td><p>Returns the last n rows as a new Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.take" title="cudf.core.series.Series.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(self, indices[, ignore_index])</p></td>
<td><p>Return Series by taking values from the corresponding <em>indices</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_array" title="cudf.core.series.Series.to_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numpy array for the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_dlpack" title="cudf.core.series.Series.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>(self)</p></td>
<td><p>Converts a cuDF object into a DLPack tensor.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_frame" title="cudf.core.series.Series.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_frame</span></code></a>(self[, name])</p></td>
<td><p>Convert Series into a DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_gpu_array" title="cudf.core.series.Series.to_gpu_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numba device array for the data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_hdf" title="cudf.core.series.Series.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(self, path_or_buf, key, \*args, …)</p></td>
<td><p>Write the contained data to an HDF5 file using HDFStore.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_json" title="cudf.core.series.Series.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>(self[, path_or_buf])</p></td>
<td><p>Convert the cuDF object to a JSON string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_string" title="cudf.core.series.Series.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>(self)</p></td>
<td><p>Convert to string</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.tolist" title="cudf.core.series.Series.tolist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code></a>(self)</p></td>
<td><p>Return a list type from series data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.truediv" title="cudf.core.series.Series.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">truediv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Floating division of series and other, element-wise (binary operator truediv).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.unique" title="cudf.core.series.Series.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>(self[, method, sort])</p></td>
<td><p>Returns unique values of this Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.value_counts" title="cudf.core.series.Series.value_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">value_counts</span></code></a>(self[, sort])</p></td>
<td><p>Returns unique values of this Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.values_to_string" title="cudf.core.series.Series.values_to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values_to_string</span></code></a>(self[, nrows])</p></td>
<td><p>Returns a list of string for each element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.var" title="cudf.core.series.Series.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>(self[, ddof, axis, skipna])</p></td>
<td><p>Compute the variance of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.where" title="cudf.core.series.Series.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">where</span></code></a>(self, cond[, other, axis])</p></td>
<td><p>Replace values with other where the condition is False.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 64%" />
<col style="width: 36%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>all</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>any</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>as_index</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>copy</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>deserialize</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>equals</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>from_arrow</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>from_pandas</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>groupby</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>head</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>isin</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>logical_and</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>logical_not</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>logical_or</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>memory_usage</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>repeat</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>serialize</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>sum_of_squares</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>to_arrow</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>to_pandas</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>unique_k</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.core.series.Series.abs">
<code class="sig-name descname">abs</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute value of each element of the series.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition of series and other, element-wise
(binary operator add).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.all" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.any" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.
If <code class="docutils literal notranslate"><span class="pre">ignore_index=True</span></code>, the index is reset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object</span></dt><dd></dd>
<dt><strong>ignore_index</strong><span class="classifier">boolean, default False. If true, the index is reset.</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new Series equivalent to self concatenated with other</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.applymap">
<code class="sig-name descname">applymap</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">udf</em>, <em class="sig-param">out_dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.applymap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a elemenwise function to transform the values in the Column.</p>
<p>The user function is expected to take one argument and return the
result, which will be stored to the output Series.  The function
cannot reference globals except for other simple scalar objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>udf</strong><span class="classifier">Either a callable python function or a python function already</span></dt><dd></dd>
<dt><strong>decorated by ``numba.cuda.jit`` for call on the GPU as a device</strong></dt><dd></dd>
<dt><strong>out_dtype</strong><span class="classifier">numpy.dtype; optional</span></dt><dd><p>The dtype for use in the output.
Only used for <code class="docutils literal notranslate"><span class="pre">numba.cuda.jit</span></code> decorated udf.
By default, the result will have the same dtype as the source.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>The mask and index are preserved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The supported Python features are listed in</p>
<blockquote>
<div><p><a class="reference external" href="https://numba.pydata.org/numba-doc/dev/cuda/cudapysupported.html">https://numba.pydata.org/numba-doc/dev/cuda/cudapysupported.html</a></p>
</div></blockquote>
<p>with these exceptions:</p>
<ul class="simple">
<li><p>Math functions in <cite>cmath</cite> are not supported since <cite>libcudf</cite> does not
have complex number support and output of <cite>cmath</cite> functions are most
likely complex numbers.</p></li>
<li><p>These five functions in <cite>math</cite> are not supported since numba
generates multiple PTX functions from them</p>
<ul>
<li><p>math.sin()</p></li>
<li><p>math.cos()</p></li>
<li><p>math.tan()</p></li>
<li><p>math.gamma()</p></li>
<li><p>math.lgamma()</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.argsort">
<code class="sig-name descname">argsort</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ascending=True</em>, <em class="sig-param">na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Series of int64 index that will sort the series.</p>
<p>Uses Thrust sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>result: Series</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.as_mask">
<code class="sig-name descname">as_mask</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.as_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert booleans to bitmask</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>device array</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">dtype</em>, <em class="sig-param">errors='raise'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast the Series to the given dtype</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data type</span></dt><dd></dd>
<dt><strong>**kwargs</strong><span class="classifier">extra arguments to pass on to the constructor</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">Series</span></dt><dd><p>Copy of <code class="docutils literal notranslate"><span class="pre">self</span></code> cast to the given dtype. Returns
<code class="docutils literal notranslate"><span class="pre">self</span></code> if <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">self.dtype</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.ceil">
<code class="sig-name descname">ceil</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value upward to the smallest integral value not less
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.corr">
<code class="sig-name descname">corr</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">method='pearson'</em>, <em class="sig-param">min_periods=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the sample correlation between two Series,
excluding missing values.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of non-null values</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">min_periods=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the sample covariance between two Series,
excluding missing values.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.cummax">
<code class="sig-name descname">cummax</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cummax" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative maximum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.cummin">
<code class="sig-name descname">cummin</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cummin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative minimum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative product of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cumulative sum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.data">
<em class="property">property </em><code class="sig-name descname">data</code><a class="headerlink" href="#cudf.core.series.Series.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the data</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.describe">
<code class="sig-name descname">describe</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">percentiles=None</em>, <em class="sig-param">include=None</em>, <em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute summary statistics of a Series. For numeric
data, the output includes the minimum, maximum, mean, median,
standard deviation, and various quantiles. For object data, the output
includes the count, number of unique values, the most common value, and
the number of occurrences of the most common value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like, optional</span></dt><dd><p>The percentiles used to generate the output summary statistics.
If None, the default percentiles used are the 25th, 50th and 75th.
Values should be within the interval [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A DataFrame containing summary statistics of relevant columns from</dt><dd></dd>
<dt>the input DataFrame.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">Series</span></code> containing numeric values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">   stats   values</span>
<span class="go">0  count     10.0</span>
<span class="go">1   mean      5.5</span>
<span class="go">2    std  3.02765</span>
<span class="go">3    min      1.0</span>
<span class="go">4    25%      2.5</span>
<span class="go">5    50%      5.5</span>
<span class="go">6    75%      7.5</span>
<span class="go">7    max     10.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">periods=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between values at positions i and i - N in
an array and store the output in a new array.</p>
<p class="rubric">Notes</p>
<p>Diff currently only supports float and integer dtype columns with
no null values.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.digitize">
<code class="sig-name descname">digitize</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">bins</em>, <em class="sig-param">right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.digitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the bins to which each value in series belongs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bins</strong><span class="classifier">np.array</span></dt><dd><p>1-D monotonically, increasing array with same type as this series.</p>
</dd>
<dt><strong>right</strong><span class="classifier">bool</span></dt><dd><p>Indicates whether interval contains the right or left bin edge.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new Series containing the indices.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Monotonicity of bins is assumed and not checked.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.drop_duplicates">
<code class="sig-name descname">drop_duplicates</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">keep='first'</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.drop_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series with duplicate values removed</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.dropna">
<code class="sig-name descname">dropna</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.dropna" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series with null values removed.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#cudf.core.series.Series.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>dtype of the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.eq">
<code class="sig-name descname">eq</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Equal to of series and other, element-wise
(binary operator eq).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.factorize">
<code class="sig-name descname">factorize</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.factorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the input values as integer labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(labels, cats)</strong><span class="classifier">(Series, Series)</span></dt><dd><ul class="simple">
<li><p><em>labels</em> contains the encoded values</p></li>
<li><p><em>cats</em> contains the categories in order that the N-th
item corresponds to the (N-1) code.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.fillna">
<code class="sig-name descname">fillna</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">value</em>, <em class="sig-param">method=None</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar or Series-like</span></dt><dd><p>Value to use to fill nulls. If Series-like, null values
are filled with the values in corresponding indices of the
given Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>Copy with nulls filled.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.find_first_value">
<code class="sig-name descname">find_first_value</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.find_first_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of first value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.find_last_value">
<code class="sig-name descname">find_last_value</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.find_last_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of last value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.floor">
<code class="sig-name descname">floor</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value downward to the largest integral value not greater
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.floordiv">
<code class="sig-name descname">floordiv</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.floordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer division of series and other, element-wise
(binary operator floordiv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.from_categorical">
<em class="property">classmethod </em><code class="sig-name descname">from_categorical</code><span class="sig-paren">(</span><em class="sig-param">categorical</em>, <em class="sig-param">codes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.from_categorical" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates from a pandas.Categorical</p>
<p>If <code class="docutils literal notranslate"><span class="pre">codes</span></code> is defined, use it instead of <code class="docutils literal notranslate"><span class="pre">categorical.codes</span></code></p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.from_masked_array">
<em class="property">classmethod </em><code class="sig-name descname">from_masked_array</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">mask</em>, <em class="sig-param">null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.from_masked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Series with null-mask.
This is equivalent to:</p>
<blockquote>
<div><p>Series(data).set_mask(mask, null_count=null_count)</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">1D array-like</span></dt><dd><p>The values.  Null values must not be skipped.  They can appear
as garbage values.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">1D array-like of numpy.uint8</span></dt><dd><p>The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong><span class="classifier">int, optional</span></dt><dd><p>The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.ge">
<code class="sig-name descname">ge</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>Greater than or equal to of series and other, element-wise
(binary operator ge).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.gt">
<code class="sig-name descname">gt</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>Greater than of series and other, element-wise
(binary operator gt).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.hash_encode">
<code class="sig-name descname">hash_encode</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">stop</em>, <em class="sig-param">use_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.hash_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode column values as ints in [0, stop) using hash function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stop</strong><span class="classifier">int</span></dt><dd><p>The upper bound on the encoding range.</p>
</dd>
<dt><strong>use_name</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> then combine hashed column values
with hashed column name. This is useful for when the same
values in different columns should be encoded
with different hashed values.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>result: Series</strong></dt><dd><p>The encoded Series.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.hash_values">
<code class="sig-name descname">hash_values</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.hash_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hash of values in this column.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.iloc">
<em class="property">property </em><code class="sig-name descname">iloc</code><a class="headerlink" href="#cudf.core.series.Series.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Select values by position.</p>
<p>See DataFrame.iloc</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#cudf.core.series.Series.index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index object</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.isna">
<code class="sig-name descname">isna</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.isna" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify missing values in a Series. Alias for isnull.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.isnull">
<code class="sig-name descname">isnull</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.isnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify missing values in a Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.kurtosis">
<code class="sig-name descname">kurtosis</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=None</em>, <em class="sig-param">level=None</em>, <em class="sig-param">numeric_only=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates Fisher’s unbiased kurtosis of a sample.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.label_encoding">
<code class="sig-name descname">label_encoding</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cats</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform label encoding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">sequence of input values</span></dt><dd></dd>
<dt><strong>dtype: numpy.dtype; optional</strong></dt><dd><p>Specifies the output dtype.  If <cite>None</cite> is given, the
smallest possible integer dtype (starting with np.int32)
is used.</p>
</dd>
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>A sequence of encoded labels with value between 0 and n-1 classes(cats)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.le">
<code class="sig-name descname">le</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.le" title="Permalink to this definition">¶</a></dt>
<dd><p>Less than or equal to of series and other, element-wise
(binary operator le).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.loc">
<em class="property">property </em><code class="sig-name descname">loc</code><a class="headerlink" href="#cudf.core.series.Series.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Select values by label.</p>
<p>See DataFrame.loc</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.lt">
<code class="sig-name descname">lt</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Less than of series and other, element-wise
(binary operator lt).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.median">
<code class="sig-name descname">median</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the min of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.mod">
<code class="sig-name descname">mod</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulo of series and other, element-wise
(binary operator mod).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.mul">
<code class="sig-name descname">mul</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication of series and other, element-wise
(binary operator mul).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#cudf.core.series.Series.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns name of the Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.nans_to_nulls">
<code class="sig-name descname">nans_to_nulls</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nans_to_nulls" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert nans (if any) to nulls</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#cudf.core.series.Series.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the data. Series ndim is always 1.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.ne">
<code class="sig-name descname">ne</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Not equal to of series and other, element-wise
(binary operator ne).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.nlargest">
<code class="sig-name descname">nlargest</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n=5</em>, <em class="sig-param">keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> largest element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.notna">
<code class="sig-name descname">notna</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.notna" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify non-missing values in a Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.notnull">
<code class="sig-name descname">notnull</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.notnull" title="Permalink to this definition">¶</a></dt>
<dd><p>Identify non-missing values in a Series. Alias for notna.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.nsmallest">
<code class="sig-name descname">nsmallest</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n=5</em>, <em class="sig-param">keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> smallest element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.null_count">
<em class="property">property </em><code class="sig-name descname">null_count</code><a class="headerlink" href="#cudf.core.series.Series.null_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of null values</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.nullable">
<em class="property">property </em><code class="sig-name descname">nullable</code><a class="headerlink" href="#cudf.core.series.Series.nullable" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean indicating whether a null-mask is needed</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.nullmask">
<em class="property">property </em><code class="sig-name descname">nullmask</code><a class="headerlink" href="#cudf.core.series.Series.nullmask" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the null-mask</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.nunique">
<code class="sig-name descname">nunique</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">method='sort'</em>, <em class="sig-param">dropna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nunique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of unique values of the Series: approximate version,
and exact version to be moved to libgdf</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.one_hot_encoding">
<code class="sig-name descname">one_hot_encoding</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cats</em>, <em class="sig-param">dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one-hot-encoding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cats</strong><span class="classifier">sequence of values</span></dt><dd><p>values representing each category.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy.dtype</span></dt><dd><p>specifies the output dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A sequence of new series for each category.  Its length is determined</dt><dd></dd>
<dt>by the length of <code class="docutils literal notranslate"><span class="pre">cats</span></code>.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.pow">
<code class="sig-name descname">pow</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential power of series and other, element-wise
(binary operator pow).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for product</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.product">
<code class="sig-name descname">product</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the product of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">q=0.5</em>, <em class="sig-param">interpolation='linear'</em>, <em class="sig-param">exact=True</em>, <em class="sig-param">quant_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">float or array-like, default 0.5 (50% quantile)</span></dt><dd><p>0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{’linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt><dd><p>This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j:</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use approximate or exact quantile algorithm.</p>
</dd>
<dt><strong>quant_index</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use the list of quantiles as index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.radd">
<code class="sig-name descname">radd</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.radd" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition of series and other, element-wise
(binary operator radd).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">index=None</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series that conforms to a new index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible, default None</span></dt><dd></dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new Series that conforms to the supplied index</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rename">
<code class="sig-name descname">rename</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">index=None</em>, <em class="sig-param">copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter Series name.</p>
<p>Change Series.name with a scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Scalar, optional</span></dt><dd><p>Scalar to alter the Series.name attribute</p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd><p>Also copy underlying data</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Supports scalar values only for changing name attribute</p></li>
<li><p>Not supporting: inplace, level</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">to_replace</em>, <em class="sig-param">replacement</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <em>to_replace</em> with <em>replacement</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>to_replace</strong><span class="classifier">numeric, str or list-like</span></dt><dd><p>Value(s) to replace.
* numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>values equal to <em>to_replace</em> will be replaced with <em>value</em></p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>list of numeric or str:</dt><dd><ul>
<li><p>If <em>replacement</em> is also list-like, <em>to_replace</em> and
<em>replacement</em> must be of same length.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>replacement</strong><span class="classifier">numeric, str, list-like, or dict</span></dt><dd><p>Value(s) to replace <cite>to_replace</cite> with.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>Series after replacement. The mask and index are preserved.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.series.Series.fillna" title="cudf.core.series.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.fillna</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.reset_index">
<code class="sig-name descname">reset_index</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">drop=False</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset index to RangeIndex</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.reverse">
<code class="sig-name descname">reverse</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rfloordiv">
<code class="sig-name descname">rfloordiv</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rfloordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer division of series and other, element-wise
(binary operator rfloordiv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rmod">
<code class="sig-name descname">rmod</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulo of series and other, element-wise
(binary operator rmod).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rmul">
<code class="sig-name descname">rmul</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication of series and other, element-wise
(binary operator rmul).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rolling">
<code class="sig-name descname">rolling</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">window</em>, <em class="sig-param">min_periods=None</em>, <em class="sig-param">center=False</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">win_type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolling window calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window</strong><span class="classifier">int or offset</span></dt><dd><p>Size of the window, i.e., the number of observations used
to calculate the statistic.
For datetime indexes, an offset can be provided instead
of an int. The offset must be convertible to a timedelta.
As opposed to a fixed window size, each window will be
sized to accommodate observations within the time period
specified by the offset.</p>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>The minimum number of observations in the window that are
required to be non-null, so that the result is non-null.
If not provided or <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> is equal to
the window size.</p>
</dd>
<dt><strong>center</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result is set at the center of the window.
If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), the result is set at the right edge
of the window.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Rolling</span></code> object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>Rolling sum with window size 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling sum with window size 2 and min_periods 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    2</span>
<span class="go">4    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3, but with the result set at the
center of the window.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    2</span>
<span class="go">1    3</span>
<span class="go">2    2</span>
<span class="go">3    2</span>
<span class="go">4    1 dtype: int64</span>
</pre></div>
</div>
<p>Rolling max with variable window size specified by an offset;
only valid for datetime index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:00&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:01&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:02&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:04&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:07&#39;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:08&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">&#39;2s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="go">2019-01-01T09:00:00.000    1</span>
<span class="go">2019-01-01T09:00:01.000    9</span>
<span class="go">2019-01-01T09:00:02.000    9</span>
<span class="go">2019-01-01T09:00:04.000    4</span>
<span class="go">2019-01-01T09:00:07.000</span>
<span class="go">2019-01-01T09:00:08.000    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Apply custom function on the window with the <em>apply</em> method</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">0     4.0</span>
<span class="go">1     9.0</span>
<span class="go">2    15.0</span>
<span class="go">3    18.0</span>
<span class="go">4    21.0</span>
<span class="go">5    24.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>And this also works for window rolling set by an offset</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:00&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:01&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:02&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:04&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:07&#39;</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">&#39;20190101 09:00:08&#39;</span><span class="p">)</span>
<span class="gp">... </span>     <span class="p">],</span>
<span class="gp">... </span>    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">&#39;2s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">2019-01-01T09:00:00.000     4.0</span>
<span class="go">2019-01-01T09:00:01.000     9.0</span>
<span class="go">2019-01-01T09:00:02.000    11.0</span>
<span class="go">2019-01-01T09:00:04.000     7.0</span>
<span class="go">2019-01-01T09:00:07.000     8.0</span>
<span class="go">2019-01-01T09:00:08.000    17.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">decimals=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round a Series to a configurable number of decimal places.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rpow">
<code class="sig-name descname">rpow</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential power of series and other, element-wise
(binary operator rpow).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rsub">
<code class="sig-name descname">rsub</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction of series and other, element-wise
(binary operator rsub).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.rtruediv">
<code class="sig-name descname">rtruediv</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rtruediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Floating division of series and other, element-wise
(binary operator rtruediv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.scale">
<code class="sig-name descname">scale</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale values to [0, 1] in float64</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.searchsorted">
<code class="sig-name descname">searchsorted</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">value</em>, <em class="sig-param">side='left'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.searchsorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Find indices where elements should be inserted to maintain order</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">array_like</span></dt><dd><p>Column of values to search for</p>
</dd>
<dt><strong>side</strong><span class="classifier">str {‘left’, ‘right’} optional</span></dt><dd><p>If ‘left’, the index of the first suitable location found is given.
If ‘right’, return the last such index</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A Column of insertion points with the same shape as value</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.set_index">
<code class="sig-name descname">set_index</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">index</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series with a different index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible</span></dt><dd><p>the new index or values for the new index</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.set_mask">
<code class="sig-name descname">set_mask</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">mask</em>, <em class="sig-param">null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new Series by setting a mask array.</p>
<p>This will override the existing mask.  The returned Series will
reference the same data buffer as this Series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">1D array-like of numpy.uint8</span></dt><dd><p>The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong><span class="classifier">int, optional</span></dt><dd><p>The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#cudf.core.series.Series.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.shift">
<code class="sig-name descname">shift</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">periods=1</em>, <em class="sig-param">freq=None</em>, <em class="sig-param">axis=0</em>, <em class="sig-param">fill_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift values of an input array by periods positions and store the
output in a new array.</p>
<p class="rubric">Notes</p>
<p>Shift currently only supports float and integer dtype columns with
no null values.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.skew">
<code class="sig-name descname">skew</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=None</em>, <em class="sig-param">level=None</em>, <em class="sig-param">numeric_only=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the unbiased Fisher-Pearson skew of a sample.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.sort_index">
<code class="sig-name descname">sort_index</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.sort_values">
<code class="sig-name descname">sort_values</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ascending=True</em>, <em class="sig-param">na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values.</p>
<p>Sort a Series in ascending or descending order by some criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ascending</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, sort values in ascending order, otherwise descending.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>sorted_obj</strong><span class="classifier">cuDF Series</span></dt><dd></dd>
<dt><strong>Difference from pandas:</strong></dt><dd><ul class="simple">
<li><p>Not supporting: inplace, kind</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">2    2</span>
<span class="go">4    3</span>
<span class="go">3    4</span>
<span class="go">1    5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction of series and other, element-wise
(binary operator sub).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em>, <em class="sig-param">dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new Series</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">3    1</span>
<span class="go">4    0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.take">
<code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">indices</em>, <em class="sig-param">ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series by taking values from the corresponding <em>indices</em>.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.to_array">
<code class="sig-name descname">to_array</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numpy array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>Defaults to None, which will skip null values.
If it equals “pandas”, null values are filled with NaNs.
Non integral dtype is promoted to np.float64.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.to_dlpack">
<code class="sig-name descname">to_dlpack</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.to_frame">
<code class="sig-name descname">to_frame</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str, default None</span></dt><dd><p>Name to be used for the column</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>cudf DataFrame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.to_gpu_array">
<code class="sig-name descname">to_gpu_array</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_gpu_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numba device array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>See <em>fillna</em> in <code class="docutils literal notranslate"><span class="pre">.to_array</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.to_hdf">
<code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">path_or_buf</em>, <em class="sig-param">key</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,
nor searchable.</p></li>
<li><p>‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p></li>
</ul>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">path_or_buf=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Series</dt><dd><ul>
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>DataFrame</dt><dd><ul>
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:
{‘split’,’records’,’index’,’columns’,’values’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The format of the JSON string</dt><dd><ul>
<li><p>‘split’ : dict like {‘index’ -&gt; [index],
‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}</p></li>
<li><p>‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]</p></li>
<li><p>‘index’ : dict like {index -&gt; {column -&gt; value}}</p></li>
<li><p>‘columns’ : dict like {column -&gt; {index -&gt; value}}</p></li>
<li><p>‘values’ : just the values array</p></li>
<li><p>‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.to_string">
<code class="sig-name descname">to_string</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<p>Uses Pandas formatting internals to produce output identical to Pandas.
Use the Pandas formatting settings directly in Pandas to control cuDF
output.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.tolist">
<code class="sig-name descname">tolist</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list type from series data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>list</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.truediv">
<code class="sig-name descname">truediv</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">other</em>, <em class="sig-param">fill_value=None</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.truediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Floating division of series and other, element-wise
(binary operator truediv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other: Series or scalar value</strong></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.unique">
<code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">method='sort'</em>, <em class="sig-param">sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.
default=’sort’ will be changed to ‘hash’ when implemented.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.valid_count">
<em class="property">property </em><code class="sig-name descname">valid_count</code><a class="headerlink" href="#cudf.core.series.Series.valid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-null values</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.value_counts">
<code class="sig-name descname">value_counts</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.value_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.values_to_string">
<code class="sig-name descname">values_to_string</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">nrows=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.values_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of string for each element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">ddof=1</em>, <em class="sig-param">axis=None</em>, <em class="sig-param">skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.series.Series.where">
<code class="sig-name descname">where</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">cond</em>, <em class="sig-param">other=None</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values with other where the condition is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cond</strong><span class="classifier">boolean</span></dt><dd><p>Where cond is True, keep the original value. Where False,
replace with corresponding value from other.</p>
</dd>
<dt><strong>other: scalar, default None</strong></dt><dd><p>Entries where cond is False are replaced with
corresponding value from other.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ser</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="go">0     4</span>
<span class="go">1     3</span>
<span class="go">2    10</span>
<span class="go">3    10</span>
<span class="go">4    10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ser</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">0    4</span>
<span class="go">1    3</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="groupby">
<h2>Groupby<a class="headerlink" href="#groupby" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.agg">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">agg</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">func</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.agg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.count">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.count" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.max">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.mean">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.mean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.min">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.min" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.quantile">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">q=0.5</em>, <em class="sig-param">interpolation='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.quantile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.size">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">size</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.groupby.DataFrameGroupBy.sum">
<code class="sig-prename descclassname">DataFrameGroupBy.</code><code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.DataFrameGroupBy.sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="legacy-groupby">
<h2>Legacy Groupby<a class="headerlink" href="#legacy-groupby" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.core.groupby.legacy_groupby.Groupby">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.groupby.legacy_groupby.</code><code class="sig-name descname">Groupby</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">by</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby object returned by cudf.DataFrame.groupby(method=”cudf”).
<cite>method=cudf</cite> uses numba kernels to compute aggregations and allows
custom UDFs via the <cite>apply</cite> and <cite>apply_grouped</cite> methods.</p>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p><cite>method=cudf</cite> may be deprecated in the future.</p></li>
<li><p>Grouping and aggregating over columns with null values will
return incorrect results.</p></li>
<li><p>Grouping by or aggregating over string columns is currently
not supported.</p></li>
</ul>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.agg" title="cudf.core.groupby.legacy_groupby.Groupby.agg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">agg</span></code></a>(self, args)</p></td>
<td><p>Invoke aggregation functions on the groups.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.apply" title="cudf.core.groupby.legacy_groupby.Groupby.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code></a>(self, function)</p></td>
<td><p>Apply a python transformation function over the grouped chunk.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.apply_grouped" title="cudf.core.groupby.legacy_groupby.Groupby.apply_grouped"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_grouped</span></code></a>(self, function, \*\*kwargs)</p></td>
<td><p>Apply a transformation function over the grouped chunk.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.as_df" title="cudf.core.groupby.legacy_groupby.Groupby.as_df"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_df</span></code></a>(self)</p></td>
<td><p>Get the intermediate dataframe after shuffling the rows into groups.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.count" title="cudf.core.groupby.legacy_groupby.Groupby.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(self)</p></td>
<td><p>Compute the count of each group</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.max" title="cudf.core.groupby.legacy_groupby.Groupby.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(self)</p></td>
<td><p>Compute the max of each group</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.mean" title="cudf.core.groupby.legacy_groupby.Groupby.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(self)</p></td>
<td><p>Compute the mean of each group</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.min" title="cudf.core.groupby.legacy_groupby.Groupby.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(self)</p></td>
<td><p>Compute the min of each group</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.std" title="cudf.core.groupby.legacy_groupby.Groupby.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>(self)</p></td>
<td><p>Compute the std of each group</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.sum" title="cudf.core.groupby.legacy_groupby.Groupby.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(self)</p></td>
<td><p>Compute the sum of each group</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.sum_of_squares" title="cudf.core.groupby.legacy_groupby.Groupby.sum_of_squares"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_of_squares</span></code></a>(self)</p></td>
<td><p>Compute the sum_of_squares of each group</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.legacy_groupby.Groupby.var" title="cudf.core.groupby.legacy_groupby.Groupby.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>(self)</p></td>
<td><p>Compute the var of each group</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.agg">
<code class="sig-name descname">agg</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">args</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke aggregation functions on the groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>args: dict, list, str, callable</strong></dt><dd><ul class="simple">
<li><dl class="simple">
<dt>str</dt><dd><p>The aggregate function name.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>callable</dt><dd><p>The aggregate function.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>list</dt><dd><p>List of <em>str</em> or <em>callable</em> of the aggregate function.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>dict</dt><dd><p>key-value pairs of source column name and list of
aggregate functions as <em>str</em> or <em>callable</em>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">function</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a python transformation function over the grouped chunk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The python transformation function that will be applied
on the grouped chunk.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="c1"># Define a function to apply to each row in a group</span>
<span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
  <span class="n">df</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">df</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span>  <span class="n">out</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.apply_grouped">
<code class="sig-name descname">apply_grouped</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">function</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.apply_grouped" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation function over the grouped chunk.</p>
<p>This uses numba’s CUDA JIT compiler to convert the Python
transformation function into a CUDA kernel, thus will have a
compilation overhead during the first run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt><dd><p>A list of names of input columns.</p>
</dd>
<dt><strong>outcols: list</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>name-value of extra arguments. These values are passed directly into
the function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="c1"># Define a function to apply to each group</span>
<span class="k">def</span> <span class="nf">mult_add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply_grouped</span><span class="p">(</span><span class="n">mult_add</span><span class="p">,</span>
                              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">],</span>
                              <span class="n">outcols</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;out1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                                       <span class="s1">&#39;out2&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">},</span>
                              <span class="c1"># threads per block</span>
                              <span class="n">tpb</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span> <span class="n">out1</span> <span class="n">out2</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">3</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>    <span class="mi">4</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>    <span class="mi">6</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>    <span class="mi">7</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>    <span class="mi">8</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="c1"># Create a random 15 row dataframe with one categorical</span>
<span class="c1"># feature and one random integer valued feature</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;cat&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)],</span>
        <span class="p">}</span>
     <span class="p">)</span>

<span class="c1"># Group the dataframe by its categorical feature</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cudf&quot;</span><span class="p">)</span>

<span class="c1"># Define a kernel which takes the moving average of a</span>
<span class="c1"># sliding window</span>
<span class="k">def</span> <span class="nf">rolling_avg</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">avg</span><span class="p">):</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">win_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If there is not enough data to fill the window,</span>
            <span class="c1"># take the average to be NaN</span>
            <span class="n">avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">win_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="n">win_size</span>

<span class="c1"># Compute moving avgs on all groups</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply_grouped</span><span class="p">(</span><span class="n">rolling_avg</span><span class="p">,</span>
                               <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">],</span>
                               <span class="n">outcols</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">avg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Results:&quot;</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>

<span class="c1"># Note this gives the same result as its pandas equivalent</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="n">pd_results</span> <span class="o">=</span> <span class="n">pdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;cat&#39;</span><span class="p">)[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Results</span><span class="p">:</span>
     <span class="n">cat</span>  <span class="n">val</span>                 <span class="n">avg</span>
<span class="mi">0</span>    <span class="mi">1</span>   <span class="mi">16</span>
<span class="mi">1</span>    <span class="mi">1</span>   <span class="mi">45</span>
<span class="mi">2</span>    <span class="mi">1</span>   <span class="mi">62</span>                <span class="mf">41.0</span>
<span class="mi">3</span>    <span class="mi">1</span>   <span class="mi">45</span>  <span class="mf">50.666666666666664</span>
<span class="mi">4</span>    <span class="mi">1</span>   <span class="mi">26</span>  <span class="mf">44.333333333333336</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>
<span class="mi">6</span>    <span class="mi">2</span>   <span class="mi">51</span>
<span class="mi">7</span>    <span class="mi">2</span>   <span class="mi">77</span>  <span class="mf">44.333333333333336</span>
<span class="mi">8</span>    <span class="mi">2</span>    <span class="mi">1</span>                <span class="mf">43.0</span>
<span class="mi">9</span>    <span class="mi">2</span>   <span class="mi">46</span>  <span class="mf">41.333333333333336</span>
<span class="p">[</span><span class="mi">5</span> <span class="n">more</span> <span class="n">rows</span><span class="p">]</span>
</pre></div>
</div>
<p>This is functionally equivalent to <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html">pandas.DataFrame.Rolling</a></p>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.as_df">
<code class="sig-name descname">as_df</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.as_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the intermediate dataframe after shuffling the rows into
groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>(df, segs)</strong><span class="classifier">namedtuple</span></dt><dd><ul class="simple">
<li><p>df : DataFrame</p></li>
<li><dl class="simple">
<dt>segs<span class="classifier">Series</span></dt><dd><p>Beginning offsets of each group.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="n">df_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">as_df</span><span class="p">()</span>

<span class="c1"># DataFrame indexes of group starts</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_groups</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># DataFrame itself</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># DataFrame indexes of group starts</span>
<span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">2</span>
<span class="mi">2</span>    <span class="mi">4</span>

<span class="c1"># DataFrame itself</span>
   <span class="n">key</span>  <span class="n">val</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the count of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the min of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.sum_of_squares">
<code class="sig-name descname">sum_of_squares</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.sum_of_squares" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum_of_squares of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.core.groupby.legacy_groupby.Groupby.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.legacy_groupby.Groupby.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the var of each group</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cudf.io.csv">
<span id="io"></span><h2>IO<a class="headerlink" href="#module-cudf.io.csv" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cudf.io.csv.read_csv">
<code class="sig-prename descclassname">cudf.io.csv.</code><code class="sig-name descname">read_csv</code><span class="sig-paren">(</span><em class="sig-param">filepath_or_buffer</em>, <em class="sig-param">lineterminator='n'</em>, <em class="sig-param">quotechar='&quot;'</em>, <em class="sig-param">quoting=0</em>, <em class="sig-param">doublequote=True</em>, <em class="sig-param">header='infer'</em>, <em class="sig-param">mangle_dupe_cols=True</em>, <em class="sig-param">usecols=None</em>, <em class="sig-param">sep='</em>, <em class="sig-param">'</em>, <em class="sig-param">delimiter=None</em>, <em class="sig-param">delim_whitespace=False</em>, <em class="sig-param">skipinitialspace=False</em>, <em class="sig-param">names=None</em>, <em class="sig-param">dtype=None</em>, <em class="sig-param">skipfooter=0</em>, <em class="sig-param">skiprows=0</em>, <em class="sig-param">dayfirst=False</em>, <em class="sig-param">compression='infer'</em>, <em class="sig-param">thousands=None</em>, <em class="sig-param">decimal='.'</em>, <em class="sig-param">true_values=None</em>, <em class="sig-param">false_values=None</em>, <em class="sig-param">nrows=None</em>, <em class="sig-param">byte_range=None</em>, <em class="sig-param">skip_blank_lines=True</em>, <em class="sig-param">parse_dates=None</em>, <em class="sig-param">comment=None</em>, <em class="sig-param">na_values=None</em>, <em class="sig-param">keep_default_na=True</em>, <em class="sig-param">na_filter=True</em>, <em class="sig-param">prefix=None</em>, <em class="sig-param">index_col=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.read_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a comma-seperated-values (CSV) dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
or any object with a <cite>read()</cite> method (such as builtin <cite>open()</cite> file handler
function or <cite>StringIO</cite>).</p>
</dd>
<dt><strong>sep</strong><span class="classifier">char, default ‘,’</span></dt><dd><p>Delimiter to be used.</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">char, default None</span></dt><dd><p>Alternative argument name for sep.</p>
</dd>
<dt><strong>delim_whitespace</strong><span class="classifier">bool, default False</span></dt><dd><p>Determines whether to use whitespace as delimiter.</p>
</dd>
<dt><strong>lineterminator</strong><span class="classifier">char, default ‘n’</span></dt><dd><p>Character to indicate end of line.</p>
</dd>
<dt><strong>skipinitialspace</strong><span class="classifier">bool, default False</span></dt><dd><p>Skip spaces after delimiter.</p>
</dd>
<dt><strong>names</strong><span class="classifier">list of str, default None</span></dt><dd><p>List of column names to be used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type, list of types, or dict of column -&gt; type, default None</span></dt><dd><p>Data type(s) for data or columns. If list, types are applied in the same
order as the column names. If dict, types are mapped to the column names.
E.g. {‘a’: np.float64, ‘b’: int32, ‘c’: ‘float’}
If <cite>None</cite>, dtypes are inferred from the dataset. Use <cite>str</cite> to preserve data
and not infer or interpret to dtype.</p>
</dd>
<dt><strong>quotechar</strong><span class="classifier">char, default ‘”’</span></dt><dd><p>Character to indicate start and end of quote item.</p>
</dd>
<dt><strong>quoting</strong><span class="classifier">str or int, default 0</span></dt><dd><p>Controls quoting behavior. Set to one of
0 (csv.QUOTE_MINIMAL), 1 (csv.QUOTE_ALL),
2 (csv.QUOTE_NONNUMERIC) or 3 (csv.QUOTE_NONE).
Quoting is enabled with all values except 3.</p>
</dd>
<dt><strong>doublequote</strong><span class="classifier">bool, default True</span></dt><dd><p>When quoting is enabled, indicates whether to interpret two
consecutive quotechar inside fields as single quotechar</p>
</dd>
<dt><strong>header</strong><span class="classifier">int, default ‘infer’</span></dt><dd><p>Row number to use as the column names. Default behavior is to infer
the column names: if no names are passed, header=0;
if column names are passed explicitly, header=None.</p>
</dd>
<dt><strong>usecols</strong><span class="classifier">list of int or str, default None</span></dt><dd><p>Returns subset of the columns given in the list. All elements must be
either integer indices (column number) or strings that correspond to
column names</p>
</dd>
<dt><strong>mangle_dupe_cols</strong><span class="classifier">boolean, default True</span></dt><dd><p>Duplicate columns will be specified as ‘X’,’X.1’,…’X.N’.</p>
</dd>
<dt><strong>skiprows</strong><span class="classifier">int, default 0</span></dt><dd><p>Number of rows to be skipped from the start of file.</p>
</dd>
<dt><strong>skipfooter</strong><span class="classifier">int, default 0</span></dt><dd><p>Number of rows to be skipped at the bottom of file.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘zip’, None}, default ‘infer’</span></dt><dd><p>For on-the-fly decompression of on-disk data. If ‘infer’, then detect
compression from the following extensions: ‘.gz’,‘.zip’ (otherwise no
decompression). If using ‘zip’, the ZIP file must contain only one
data file to be read in, otherwise the first non-zero-sized file will
be used. Set to None for no decompression.</p>
</dd>
<dt><strong>decimal</strong><span class="classifier">char, default ‘.’</span></dt><dd><p>Character used as a decimal point.</p>
</dd>
<dt><strong>thousands</strong><span class="classifier">char, default None</span></dt><dd><p>Character used as a thousands delimiter.</p>
</dd>
<dt><strong>true_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as boolean True</p>
</dd>
<dt><strong>false_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as boolean False</p>
</dd>
<dt><strong>nrows</strong><span class="classifier">int, default None</span></dt><dd><p>If specified, maximum number of rows to read</p>
</dd>
<dt><strong>byte_range</strong><span class="classifier">list or tuple, default None</span></dt><dd><p>Byte range within the input file to be read. The first number is the
offset in bytes, the second number is the range size in bytes. Set the
size to zero to read all data after the offset location. Reads the row
that starts before or at the end of the range, even if it ends after
the end of the range.</p>
</dd>
<dt><strong>skip_blank_lines</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, discard and do not parse empty lines
If False, interpret empty lines as NaN values</p>
</dd>
<dt><strong>parse_dates</strong><span class="classifier">list of int or names, default None</span></dt><dd><p>If list of columns, then attempt to parse each entry as a date.
Columns may not always be recognized as dates, for instance due to
unusual or non-standard formats. To guarantee a date and increase parsing
speed, explicitly specify <cite>dtype=’date’</cite> for the desired columns.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">char, default None</span></dt><dd><p>Character used as a comments indicator. If found at the beginning of a
line, the line will be ignored altogether.</p>
</dd>
<dt><strong>na_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as invalid</p>
</dd>
<dt><strong>keep_default_na</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether or not to include the default NA values when parsing the data.</p>
</dd>
<dt><strong>na_filter</strong><span class="classifier">bool, default True</span></dt><dd><p>Detect missing values (empty strings and the values in na_values).
Passing False can improve performance.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str, default None</span></dt><dd><p>Prefix to add to column numbers when parsing without a header row</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">int, string or False, default None</span></dt><dd><p>Column to use as the row labels of the DataFrame. Passing <cite>index_col=False</cite>
explicitly disables index column inference and discards the last column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>GPU <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object.</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.to_csv" title="cudf.io.csv.to_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.to_csv</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Create a test csv file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foo.csv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>  <span class="s2">&quot;num1,datetime,text&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;123,2018-11-13T12:00:00,abc&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;456,2018-11-14T12:35:01,def&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;789,2018-11-15T18:02:59,ghi&quot;</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Read the file with <code class="docutils literal notranslate"><span class="pre">cudf.read_csv</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.csv.to_csv">
<code class="sig-prename descclassname">cudf.io.csv.</code><code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">path=None</em>, <em class="sig-param">sep='</em>, <em class="sig-param">'</em>, <em class="sig-param">na_rep=''</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">header=True</em>, <em class="sig-param">index=True</em>, <em class="sig-param">line_terminator='n'</em>, <em class="sig-param">chunksize=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a dataframe to csv file format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>DataFrame object to be written to csv</p>
</dd>
<dt><strong>path</strong><span class="classifier">str, default None</span></dt><dd><p>Path of file where DataFrame will be written</p>
</dd>
<dt><strong>sep</strong><span class="classifier">char, default ‘,’</span></dt><dd><p>Delimiter to be used.</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">str, default ‘’</span></dt><dd><p>String to use for null entries</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str, optional</span></dt><dd><p>Columns to write</p>
</dd>
<dt><strong>header</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the column names</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the index as a column</p>
</dd>
<dt><strong>line_terminator</strong><span class="classifier">char, default ‘n’</span></dt><dd></dd>
<dt><strong>chunksize</strong><span class="classifier">int or None, default None</span></dt><dd><p>Rows to write at a time</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.read_csv" title="cudf.io.csv.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.read_csv</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Follows the standard of Pandas csv.QUOTE_NONNUMERIC for all output.</p></li>
<li><p>If <cite>to_csv</cite> leads to memory errors consider setting the <cite>chunksize</cite> argument.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Write a dataframe to csv.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foo.csv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="go">                         &#39;y&#39;: [1.0, 3.3, 2.2, 4.4],</span>
<span class="go">                         &#39;z&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.parquet"></span><dl class="function">
<dt id="cudf.io.parquet.read_parquet">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">read_parquet</code><span class="sig-paren">(</span><em class="sig-param">filepath_or_buffer</em>, <em class="sig-param">engine='cudf'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">row_group=None</em>, <em class="sig-param">skip_rows=None</em>, <em class="sig-param">num_rows=None</em>, <em class="sig-param">strings_to_categorical=False</em>, <em class="sig-param">use_pandas_metadata=True</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.read_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a Parquet dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, bytes, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
Python bytes of raw binary data, or any object with a <cite>read()</cite> method
(such as builtin <cite>open()</cite> file handler function or <cite>BytesIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘pyarrow’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read.</p>
</dd>
<dt><strong>row_group</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, only the row group with the specified index will be read.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the nunber of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
<dt><strong>strings_to_categorical</strong><span class="classifier">boolean, default False</span></dt><dd><p>If True, return string columns as GDF_CATEGORY dtype; if False, return a
as GDF_STRING dtype.</p>
</dd>
<dt><strong>use_pandas_metadata</strong><span class="classifier">boolean, default True</span></dt><dd><p>If True and dataset has custom PANDAS schema metadata, ensure that index
columns are also loaded.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet_metadata" title="cudf.io.parquet.read_parquet_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet_metadata</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.parquet.read_parquet_metadata">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">read_parquet_metadata</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.read_parquet_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a Parquet file’s metadata and schema</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string or path object</span></dt><dd><p>Path of file to be read</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Total number of rows</dt><dd></dd>
<dt>Number of row groups</dt><dd></dd>
<dt>List of column names</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_row_groups</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_parquet_metadata</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">row_group</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_groups</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.parquet.to_parquet">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">to_parquet</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">path</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt><dd><p>Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong><span class="classifier">list, optional, default None</span></dt><dd><p>Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.orc"></span><dl class="function">
<dt id="cudf.io.orc.read_orc">
<code class="sig-prename descclassname">cudf.io.orc.</code><code class="sig-name descname">read_orc</code><span class="sig-paren">(</span><em class="sig-param">filepath_or_buffer</em>, <em class="sig-param">engine='cudf'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">stripe=None</em>, <em class="sig-param">skip_rows=None</em>, <em class="sig-param">num_rows=None</em>, <em class="sig-param">use_index=True</em>, <em class="sig-param">decimals_as_float=True</em>, <em class="sig-param">force_decimal_scale=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.read_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an ORC dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, bytes, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
Python bytes of raw binary data, or any object with a <cite>read()</cite> method
(such as builtin <cite>open()</cite> file handler function or <cite>BytesIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘pyarrow’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read from the file.</p>
</dd>
<dt><strong>stripe: int, default None</strong></dt><dd><p>If not None, only the stripe with the specified index will be read.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the number of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
<dt><strong>use_index</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, use row index if available for faster seeking.</p>
</dd>
<dt><strong>kwargs are passed to the engine</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_orc</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.orc.read_orc_metadata">
<code class="sig-prename descclassname">cudf.io.orc.</code><code class="sig-name descname">read_orc_metadata</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.read_orc_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an ORC file’s metadata and schema</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string or path object</span></dt><dd><p>Path of file to be read</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Total number of rows</dt><dd></dd>
<dt>Number of stripes</dt><dd></dd>
<dt>List of column names</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_rows</span><span class="p">,</span> <span class="n">stripes</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_orc_metadata</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="n">cudf</span><span class="o">.</span><span class="n">read_orc</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">stripe</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stripes</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.orc.to_orc">
<code class="sig-prename descclassname">cudf.io.orc.</code><code class="sig-name descname">to_orc</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">fname</em>, <em class="sig-param">compression=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.to_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the ORC format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fname</strong><span class="classifier">str</span></dt><dd><p>File path or object where the ORC dataset will be stored.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{{ ‘snappy’, None }}, default None</span></dt><dd><p>Name of the compression to use. Use None for no compression.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.json"></span><dl class="function">
<dt id="cudf.io.json.read_json">
<code class="sig-prename descclassname">cudf.io.json.</code><code class="sig-name descname">read_json</code><span class="sig-paren">(</span><em class="sig-param">path_or_buf</em>, <em class="sig-param">engine='auto'</em>, <em class="sig-param">dtype=True</em>, <em class="sig-param">lines=False</em>, <em class="sig-param">compression='infer'</em>, <em class="sig-param">byte_range=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.read_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a JSON dataset into a DataFrame</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">str, path object, or file-like object</span></dt><dd><p>Either JSON data in a <cite>str</cite>, path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
or any object with a <cite>read()</cite> method (such as builtin <cite>open()</cite> file handler
function or <cite>StringIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{{ ‘auto’, ‘cudf’, ‘pandas’ }}, default ‘auto’</span></dt><dd><p>Parser engine to use. If ‘auto’ is passed, the engine will be
automatically selected based on the other parameters.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string,</span></dt><dd><p>Indication of expected JSON string format (pandas engine only).
Compatible JSON strings can be produced by <code class="docutils literal notranslate"><span class="pre">to_json()</span></code> with a
corresponding orient value.
The set of possible orients is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'split'</span></code> : dict like
<code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">[index],</span> <span class="pre">columns</span> <span class="pre">-&gt;</span> <span class="pre">[columns],</span> <span class="pre">data</span> <span class="pre">-&gt;</span> <span class="pre">[values]}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'records'</span></code> : list like
<code class="docutils literal notranslate"><span class="pre">[{column</span> <span class="pre">-&gt;</span> <span class="pre">value},</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'index'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'columns'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'values'</span></code> : just the values array</p></li>
</ul>
<p>The allowed and default values depend on the value
of the <cite>typ</cite> parameter.</p>
<ul class="simple">
<li><p>when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'series'</span></code>,</p>
<ul>
<li><p>allowed orients are <code class="docutils literal notranslate"><span class="pre">{'split','records','index'}</span></code></p></li>
<li><p>default is <code class="docutils literal notranslate"><span class="pre">'index'</span></code></p></li>
<li><p>The Series index must be unique for orient <code class="docutils literal notranslate"><span class="pre">'index'</span></code>.</p></li>
</ul>
</li>
<li><p>when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'frame'</span></code>,</p>
<ul>
<li><p>allowed orients are <code class="docutils literal notranslate"><span class="pre">{'split','records','index',</span>
<span class="pre">'columns','values',</span> <span class="pre">'table'}</span></code></p></li>
<li><p>default is <code class="docutils literal notranslate"><span class="pre">'columns'</span></code></p></li>
<li><p>The DataFrame index must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>.</p></li>
<li><p>The DataFrame columns must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'records'</span></code>.</p></li>
</ul>
</li>
</ul>
</dd>
<dt><strong>typ</strong><span class="classifier">type of object to recover (series or frame), default ‘frame’</span></dt><dd><p>With cudf engine, only frame output is supported.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">boolean or dict, default True</span></dt><dd><p>If True, infer dtypes, if a dict of column to dtype, then use those,
if False, then don’t infer dtypes at all, applies only to the data.</p>
</dd>
<dt><strong>convert_axes</strong><span class="classifier">boolean, default True</span></dt><dd><p>Try to convert the axes to the proper dtypes (pandas engine only).</p>
</dd>
<dt><strong>convert_dates</strong><span class="classifier">boolean, default True</span></dt><dd><p>List of columns to parse for dates (pandas engine only); If True, then try
to parse datelike columns default is True; a column label is datelike if</p>
<ul class="simple">
<li><p>it ends with <code class="docutils literal notranslate"><span class="pre">'_at'</span></code>,</p></li>
<li><p>it ends with <code class="docutils literal notranslate"><span class="pre">'_time'</span></code>,</p></li>
<li><p>it begins with <code class="docutils literal notranslate"><span class="pre">'timestamp'</span></code>,</p></li>
<li><p>it is <code class="docutils literal notranslate"><span class="pre">'modified'</span></code>, or</p></li>
<li><p>it is <code class="docutils literal notranslate"><span class="pre">'date'</span></code></p></li>
</ul>
</dd>
<dt><strong>keep_default_dates</strong><span class="classifier">boolean, default True</span></dt><dd><p>If parsing dates, parse the default datelike columns (pandas engine only)</p>
</dd>
<dt><strong>numpy</strong><span class="classifier">boolean, default False</span></dt><dd><p>Direct decoding to numpy arrays (pandas engine only). Supports numeric
data only, but non-numeric column and index labels are supported. Note
also that the JSON ordering MUST be the same for each term if numpy=True.</p>
</dd>
<dt><strong>precise_float</strong><span class="classifier">boolean, default False</span></dt><dd><p>Set to enable usage of higher precision (strtod) function when
decoding string to double values (pandas engine only). Default (False)
is to use fast but less precise builtin functionality</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default None</span></dt><dd><p>The timestamp unit to detect if converting dates (pandas engine only).
The default behaviour is to try and detect the correct precision, but if
this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force
parsing only seconds, milliseconds, microseconds or nanoseconds.</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">str, default is ‘utf-8’</span></dt><dd><p>The encoding to use to decode py3 bytes.
With cudf engine, only utf-8 is supported.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">boolean, default False</span></dt><dd><p>Read the file as a json object per line.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">integer, default None</span></dt><dd><p>Return JsonReader object for iteration (pandas engine only).
See the <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-jsonl">line-delimted json docs</a>
for more information on <code class="docutils literal notranslate"><span class="pre">chunksize</span></code>.
This can only be passed if <cite>lines=True</cite>.
If this is None, the file will be read into memory all at once.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}, default ‘infer’</span></dt><dd><p>For on-the-fly decompression of on-disk data. If ‘infer’, then use
gzip, bz2, zip or xz if path_or_buf is a string ending in
‘.gz’, ‘.bz2’, ‘.zip’, or ‘xz’, respectively, and no decompression
otherwise. If using ‘zip’, the ZIP file must contain only one data
file to be read in. Set to None for no decompression.</p>
</dd>
<dt><strong>byte_range</strong><span class="classifier">list or tuple, default None</span></dt><dd><p>Byte range within the input file to be read (cudf engine only).
The first number is the offset in bytes, the second number is the range
size in bytes. Set the size to zero to read all data after the offset
location. Reads the row that starts before or at the end of the range,
even if it ends after the end of the range.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">Series or DataFrame, depending on the value of <cite>typ</cite>.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.to_json" title="cudf.io.json.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.to_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.json.to_json">
<code class="sig-prename descclassname">cudf.io.json.</code><code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param">cudf_val</em>, <em class="sig-param">path_or_buf=None</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Series</dt><dd><ul>
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>DataFrame</dt><dd><ul>
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:
{‘split’,’records’,’index’,’columns’,’values’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The format of the JSON string</dt><dd><ul>
<li><p>‘split’ : dict like {‘index’ -&gt; [index],
‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}</p></li>
<li><p>‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]</p></li>
<li><p>‘index’ : dict like {index -&gt; {column -&gt; value}}</p></li>
<li><p>‘columns’ : dict like {column -&gt; {index -&gt; value}}</p></li>
<li><p>‘values’ : just the values array</p></li>
<li><p>‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.avro"></span><dl class="function">
<dt id="cudf.io.avro.read_avro">
<code class="sig-prename descclassname">cudf.io.avro.</code><code class="sig-name descname">read_avro</code><span class="sig-paren">(</span><em class="sig-param">filepath_or_buffer</em>, <em class="sig-param">engine='cudf'</em>, <em class="sig-param">columns=None</em>, <em class="sig-param">skip_rows=None</em>, <em class="sig-param">num_rows=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.avro.read_avro" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an Avro dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, bytes, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
Python bytes of raw binary data, or any object with a <cite>read()</cite> method
(such as builtin <cite>open()</cite> file handler function or <cite>BytesIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘fastavro’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the nunber of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.read_csv" title="cudf.io.csv.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.read_csv</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_avro</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.dlpack"></span><dl class="function">
<dt id="cudf.io.dlpack.from_dlpack">
<code class="sig-prename descclassname">cudf.io.dlpack.</code><code class="sig-name descname">from_dlpack</code><span class="sig-paren">(</span><em class="sig-param">pycapsule_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.dlpack.from_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from a DLPack tensor to a cuDF object.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a PyCapsule object which contains a pointer to
a DLPack tensor as input, and returns a cuDF object. This function deep
copies the data in the DLPack tensor into a cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Input DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A cuDF DataFrame or Series depending on if the input DLPack tensor is 1D</dt><dd></dd>
<dt>or 2D.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="cudf.io.dlpack.to_dlpack">
<code class="sig-prename descclassname">cudf.io.dlpack.</code><code class="sig-name descname">to_dlpack</code><span class="sig-paren">(</span><em class="sig-param">cudf_obj</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.dlpack.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-cudf.io.feather"></span><dl class="function">
<dt id="cudf.io.feather.read_feather">
<code class="sig-prename descclassname">cudf.io.feather.</code><code class="sig-name descname">read_feather</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.read_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an feather object from the file path, returning a DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string</span></dt><dd><p>File path</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default=None</span></dt><dd><p>If not None, only these columns will be read from the file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_feather</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.feather.to_feather">
<code class="sig-prename descclassname">cudf.io.feather.</code><code class="sig-name descname">to_feather</code><span class="sig-paren">(</span><em class="sig-param">df</em>, <em class="sig-param">path</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.hdf"></span><dl class="function">
<dt id="cudf.io.hdf.read_hdf">
<code class="sig-prename descclassname">cudf.io.hdf.</code><code class="sig-name descname">read_hdf</code><span class="sig-paren">(</span><em class="sig-param">path_or_buf</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.read_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the store, close it if we opened it.</p>
<p>Retrieve pandas object stored in file, optionally based on where
criteria</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string, buffer or path object</span></dt><dd><p>Path to the file to open, or an open <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">HDFStore</a>.
object.
Supports any object implementing the <code class="docutils literal notranslate"><span class="pre">__fspath__</span></code> protocol.
This includes <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> and py._path.local.LocalPath
objects.</p>
</dd>
<dt><strong>key</strong><span class="classifier">object, optional</span></dt><dd><p>The group identifier in the store. Can be omitted if the HDF file
contains a single pandas object.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘r’, ‘r+’, ‘a’}, optional</span></dt><dd><p>Mode to use when opening the file. Ignored if path_or_buf is a
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">Pandas HDFS</a>.
Default is ‘r’.</p>
</dd>
<dt><strong>where</strong><span class="classifier">list, optional</span></dt><dd><p>A list of Term (or convertible) objects.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int, optional</span></dt><dd><p>Row number to start selection.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int, optional</span></dt><dd><p>Row number to stop selection.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, optional</span></dt><dd><p>A list of columns names to return.</p>
</dd>
<dt><strong>iterator</strong><span class="classifier">bool, optional</span></dt><dd><p>Return an iterator object.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rows to include in an iteration when using an iterator.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments passed to HDFStore.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>item</strong><span class="classifier">object</span></dt><dd><p>The selected object. Return type depends on the object stored.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.to_hdf" title="cudf.io.hdf.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.to_hdf</span></code></a></dt><dd><p>Write a HDF file from a DataFrame.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.hdf.to_hdf">
<code class="sig-prename descclassname">cudf.io.hdf.</code><code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param">path_or_buf</em>, <em class="sig-param">key</em>, <em class="sig-param">value</em>, <em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,
nor searchable.</p></li>
<li><p>‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p></li>
</ul>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="gpuarrowreader">
<h2>GpuArrowReader<a class="headerlink" href="#gpuarrowreader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.comm.gpuarrow.GpuArrowReader">
<em class="property">class </em><code class="sig-prename descclassname">cudf.comm.gpuarrow.</code><code class="sig-name descname">GpuArrowReader</code><span class="sig-paren">(</span><em class="sig-param">schema</em>, <em class="sig-param">dev_ary</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="cudf.comm.gpuarrow.GpuArrowReader.to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code></a>(self)</p></td>
<td><p>Return a dictionary of Series object</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>schema</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.comm.gpuarrow.GpuArrowReader.to_dict">
<code class="sig-name descname">to_dict</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of Series object</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="10min.html" class="btn btn-neutral float-right" title="10 Minutes to cuDF and Dask-cuDF" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to cuDF’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>