

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; cudf 0.6.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10 Minutes to cuDF" href="10min.html" />
    <link rel="prev" title="Welcome to cuDF’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> cudf
          

          
          </a>

          
            
            
              <div class="version">
                0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dataframe">DataFrame</a></li>
<li class="toctree-l2"><a class="reference internal" href="#series">Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#groupby">Groupby</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cudf.io.csv">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpuarrowreader">GpuArrowReader</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="10min.html">10 Minutes to cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="dask-cudf.html">Multi-GPU with Dask-cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer.html">Developer Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cudf</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast,
.nboutput.nblast {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast + .nbinput {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="dataframe">
<h2>DataFrame<a class="headerlink" href="#dataframe" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.dataframe.DataFrame">
<em class="property">class </em><code class="descclassname">cudf.dataframe.</code><code class="descname">DataFrame</code><span class="sig-paren">(</span><em>name_series=None</em>, <em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>A GPU Dataframe object.</p>
<p class="rubric">Examples</p>
<p>Build dataframe with <cite>__setitem__</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
<p>Build dataframe with initializer:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Create some datetime data</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t0</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-07 12:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">datetimes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">datetimes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create the GPU DataFrame</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">ids</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;datetimes&#39;</span><span class="p">,</span> <span class="n">dts</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">    id                datetimes</span>
<span class="go">0    0  2018-10-07T12:00:00.000</span>
<span class="go">1    1  2018-10-07T12:00:01.000</span>
<span class="go">2    2  2018-10-07T12:00:02.000</span>
<span class="go">3    3  2018-10-07T12:00:03.000</span>
<span class="go">4    4  2018-10-07T12:00:04.000</span>
</pre></div>
</div>
<p>Convert from a Pandas DataFrame:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  a b</span>
<span class="go">0 0 0.1</span>
<span class="go">1 1 0.2</span>
<span class="go">2 2 nan</span>
<span class="go">3 3 0.3</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>T</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.columns" title="cudf.dataframe.DataFrame.columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">columns</span></code></a></dt>
<dd><p class="first last">Returns a tuple of columns</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.dtypes" title="cudf.dataframe.DataFrame.dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtypes</span></code></a></dt>
<dd><p class="first last">Return the dtypes in this object.</p>
</dd>
<dt><strong>empty</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.iloc" title="cudf.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt>
<dd><p class="first last">Returns a integer-location based indexer for selection by position.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.index" title="cudf.dataframe.DataFrame.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt>
<dd><p class="first last">Returns the index of the DataFrame</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.loc" title="cudf.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt>
<dd><p class="first last">Returns a label-based indexer for row-slicing and column selection.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.shape" title="cudf.dataframe.DataFrame.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt>
<dd><p class="first last">Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.add_column" title="cudf.dataframe.DataFrame.add_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_column</span></code></a>(name,&nbsp;data[,&nbsp;forceindex])</td>
<td>Add a column</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_chunks" title="cudf.dataframe.DataFrame.apply_chunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_chunks</span></code></a>(func,&nbsp;incols,&nbsp;outcols[,&nbsp;…])</td>
<td>Transform user-specified chunks using the user-provided function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_rows" title="cudf.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_rows</span></code></a>(func,&nbsp;incols,&nbsp;outcols,&nbsp;kwargs[,&nbsp;…])</td>
<td>Apply a row-wise user defined function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.as_gpu_matrix" title="cudf.dataframe.DataFrame.as_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_gpu_matrix</span></code></a>([columns,&nbsp;order])</td>
<td>Convert to a matrix in device memory.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.as_matrix" title="cudf.dataframe.DataFrame.as_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_matrix</span></code></a>([columns])</td>
<td>Convert to a matrix in host memory.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.assign" title="cudf.dataframe.DataFrame.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code></a>(**kwargs)</td>
<td>Assign columns to DataFrame from keyword arguments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.copy" title="cudf.dataframe.DataFrame.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([deep])</td>
<td>Returns a copy of this dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.drop" title="cudf.dataframe.DataFrame.drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop</span></code></a>(labels)</td>
<td>Drop column(s)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.drop_column" title="cudf.dataframe.DataFrame.drop_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_column</span></code></a>(name)</td>
<td>Drop a column by <em>name</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.fillna" title="cudf.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(value[,&nbsp;method,&nbsp;axis,&nbsp;inplace,&nbsp;limit])</td>
<td>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.from_arrow" title="cudf.dataframe.DataFrame.from_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_arrow</span></code></a>(table)</td>
<td>Convert from a PyArrow Table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.from_gpu_matrix" title="cudf.dataframe.DataFrame.from_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_gpu_matrix</span></code></a>(data[,&nbsp;index,&nbsp;columns,&nbsp;…])</td>
<td>Convert from a numba gpu ndarray.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.from_pandas" title="cudf.dataframe.DataFrame.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(dataframe[,&nbsp;nan_as_null])</td>
<td>Convert from a Pandas DataFrame.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.from_records" title="cudf.dataframe.DataFrame.from_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_records</span></code></a>(data[,&nbsp;index,&nbsp;columns,&nbsp;nan_as_null])</td>
<td>Convert from a numpy recarray or structured array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.groupby" title="cudf.dataframe.DataFrame.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a>([by,&nbsp;sort,&nbsp;as_index,&nbsp;method,&nbsp;level])</td>
<td>Groupby</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.hash_columns" title="cudf.dataframe.DataFrame.hash_columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_columns</span></code></a>([columns])</td>
<td>Hash the given <em>columns</em> and return a new Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.head" title="cudf.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">head</span></code></a>([n])</td>
<td>Returns the first n rows as a new DataFrame</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.iteritems" title="cudf.dataframe.DataFrame.iteritems"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iteritems</span></code></a>()</td>
<td>Iterate over column names and series pairs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.join" title="cudf.dataframe.DataFrame.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(other[,&nbsp;on,&nbsp;how,&nbsp;lsuffix,&nbsp;rsuffix,&nbsp;…])</td>
<td>Join columns with other DataFrame on index or on a key column.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.label_encoding" title="cudf.dataframe.DataFrame.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(column,&nbsp;prefix,&nbsp;cats[,&nbsp;…])</td>
<td>Encode labels in a column with label encoding.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.merge" title="cudf.dataframe.DataFrame.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code></a>(right[,&nbsp;on,&nbsp;how,&nbsp;left_on,&nbsp;right_on,&nbsp;…])</td>
<td>Merge GPU DataFrame objects by performing a database-style join operation by columns or indexes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.nlargest" title="cudf.dataframe.DataFrame.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(n,&nbsp;columns[,&nbsp;keep])</td>
<td>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.nsmallest" title="cudf.dataframe.DataFrame.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(n,&nbsp;columns[,&nbsp;keep])</td>
<td>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.one_hot_encoding" title="cudf.dataframe.DataFrame.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(column,&nbsp;prefix,&nbsp;cats[,&nbsp;…])</td>
<td>Expand a column with one-hot-encoding.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.partition_by_hash" title="cudf.dataframe.DataFrame.partition_by_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_by_hash</span></code></a>(columns,&nbsp;nparts)</td>
<td>Partition the dataframe by the hashed value of data in <em>columns</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.quantile" title="cudf.dataframe.DataFrame.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>([q,&nbsp;interpolation,&nbsp;columns,&nbsp;exact])</td>
<td>Return values at the given quantile.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.query" title="cudf.dataframe.DataFrame.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query</span></code></a>(expr)</td>
<td>Query with a boolean expression using Numba to compile a GPU kernel.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.rename" title="cudf.dataframe.DataFrame.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>([mapper,&nbsp;columns,&nbsp;copy,&nbsp;inplace])</td>
<td>Alter column labels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.replace" title="cudf.dataframe.DataFrame.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(to_replace,&nbsp;value)</td>
<td>Replace values given in <em>to_replace</em> with <em>value</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.select_dtypes" title="cudf.dataframe.DataFrame.select_dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_dtypes</span></code></a>([include])</td>
<td>Return a subset of the DataFrame’s columns based on the column dtypes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.set_index" title="cudf.dataframe.DataFrame.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(index)</td>
<td>Return a new DataFrame with a new index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.sort_index" title="cudf.dataframe.DataFrame.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>([ascending])</td>
<td>Sort by the index</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.sort_values" title="cudf.dataframe.DataFrame.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(by[,&nbsp;ascending,&nbsp;na_position])</td>
<td>Sort by the values row-wise.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.tail" title="cudf.dataframe.DataFrame.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>([n])</td>
<td>Returns the last n rows as a new DataFrame</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_arrow" title="cudf.dataframe.DataFrame.to_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_arrow</span></code></a>([preserve_index])</td>
<td>Convert to a PyArrow Table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_dlpack" title="cudf.dataframe.DataFrame.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>()</td>
<td>Converts a cuDF object into a DLPack tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_feather" title="cudf.dataframe.DataFrame.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_feather</span></code></a>(path,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Write a DataFrame to the feather format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_gpu_matrix" title="cudf.dataframe.DataFrame.to_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_matrix</span></code></a>()</td>
<td>Convert to a numba gpu ndarray</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_hdf" title="cudf.dataframe.DataFrame.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(path_or_buf,&nbsp;key,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Write the contained data to an HDF5 file using HDFStore.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_json" title="cudf.dataframe.DataFrame.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>([path_or_buf])</td>
<td>Convert the cuDF object to a JSON string.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_pandas" title="cudf.dataframe.DataFrame.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>()</td>
<td>Convert to a Pandas DataFrame.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_parquet" title="cudf.dataframe.DataFrame.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a>(path,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Write a DataFrame to the parquet format.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_records" title="cudf.dataframe.DataFrame.to_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_records</span></code></a>([index])</td>
<td>Convert to a numpy recarray</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_string" title="cudf.dataframe.DataFrame.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>([nrows,&nbsp;ncols])</td>
<td>Convert to string</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.transpose" title="cudf.dataframe.DataFrame.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>()</td>
<td>Transpose index and columns.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>argsort</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>deserialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>mask</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>reset_index</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>serialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>take</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.dataframe.DataFrame.add_column">
<code class="descname">add_column</code><span class="sig-paren">(</span><em>name</em>, <em>data</em>, <em>forceindex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.add_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of column to be added.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series, array-like</span></dt>
<dd><p class="first last">Values to be added.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.apply_chunks">
<code class="descname">apply_chunks</code><span class="sig-paren">(</span><em>func</em>, <em>incols</em>, <em>outcols</em>, <em>kwargs={}</em>, <em>chunks=None</em>, <em>tpb=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.apply_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform user-specified chunks using the user-provided function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt>
<dd><p class="first last">A list of names of input columns.</p>
</dd>
<dt><strong>outcols: dict</strong></dt>
<dd><p class="first last">A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt>
<dd><p class="first last">name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
<dt><strong>chunks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or Series-like</span></dt>
<dd><p class="first last">If it is an <code class="docutils literal notranslate"><span class="pre">int</span></code>, it is the chunksize.
If it is an array, it contains integer offset for the start of
each chunk.  The span of a chunk for chunk i-th is
<code class="docutils literal notranslate"><span class="pre">data[chunks[i]</span> <span class="pre">:</span> <span class="pre">chunks[i</span> <span class="pre">+</span> <span class="pre">1]]</span></code> for any
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">chunks.size</span></code>; or, <code class="docutils literal notranslate"><span class="pre">data[chunks[i]:]</span></code> for the
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">len(chunks)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>tpb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int; optional</span></dt>
<dd><p class="first last">It is the thread-per-block for the underlying kernel.
The default uses 1 thread to emulate serial execution for
each chunk.  It is a good starting point but inefficient.
Its maximum possible value is limited by the available CUDA GPU
resources.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_rows" title="cudf.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply_rows</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>For <code class="docutils literal notranslate"><span class="pre">tpb</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">func</span></code> is executed by <code class="docutils literal notranslate"><span class="pre">tpb</span></code> number of threads
concurrently.  To access the thread id and count,
use <code class="docutils literal notranslate"><span class="pre">numba.cuda.threadIdx.x</span></code> and <code class="docutils literal notranslate"><span class="pre">numba.cuda.blockDim.x</span></code>,
respectively (See <a class="reference external" href="http://numba.pydata.org/numba-doc/latest/cuda/kernels.html">numba CUDA kernel documentation</a>).</p>
<p>In the example below, the <em>kernel</em> is invoked concurrently on each
specified chunk. The <em>kernel</em> computes the corresponding output
for the chunk.</p>
<p>By looping over the range
<code class="docutils literal notranslate"><span class="pre">range(cuda.threadIdx.x,</span> <span class="pre">in1.size,</span> <span class="pre">cuda.blockDim.x)</span></code>, the <em>kernel</em>
function can be used with any <em>tpb</em> in a efficient manner.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numba</span> <span class="k">import</span> <span class="n">cuda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@cuda</span><span class="o">.</span><span class="n">jit</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">):</span>
<span class="gp">... </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>         <span class="n">x</span> <span class="o">=</span> <span class="n">in1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">y</span> <span class="o">=</span> <span class="n">in2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">z</span> <span class="o">=</span> <span class="n">in3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.apply_rows">
<code class="descname">apply_rows</code><span class="sig-paren">(</span><em>func</em>, <em>incols</em>, <em>outcols</em>, <em>kwargs</em>, <em>cache_key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.apply_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a row-wise user defined function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt>
<dd><p class="first last">A list of names of input columns.</p>
</dd>
<dt><strong>outcols: dict</strong></dt>
<dd><p class="first last">A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt>
<dd><p class="first last">name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The user function should loop over the columns and set the output for
each row. Loop execution order is arbitrary, so each iteration of
the loop <strong>MUST</strong> be independent of each other.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">func</span></code> is invoked, the array args corresponding to the
input/output are strided so as to improve GPU parallelism.
The loop in the function resembles serial code, but executes
concurrently in multiple threads.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nelem</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
</pre></div>
</div>
<p>Define input columns for the kernel</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">in1</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in3</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">,</span> <span class="n">kwarg1</span><span class="p">,</span> <span class="n">kwarg2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">)):</span>
<span class="gp">... </span>        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwarg2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">... </span>        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">z</span>
</pre></div>
</div>
<p>Call <code class="docutils literal notranslate"><span class="pre">.apply_rows</span></code> with the name of the input columns, the name and
dtype of the output columns, and, optionally, a dict of extra
arguments.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">apply_rows</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">,</span> <span class="s1">&#39;in2&#39;</span><span class="p">,</span> <span class="s1">&#39;in3&#39;</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">outcols</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">out2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwarg1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">kwarg2</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">   in1  in2  in3 out1 out2</span>
<span class="go">0    0    0    0  0.0  0.0</span>
<span class="go">1    1    1    1  1.0 -2.0</span>
<span class="go">2    2    2    2  2.0 -4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.as_gpu_matrix">
<code class="descname">as_gpu_matrix</code><span class="sig-paren">(</span><em>columns=None</em>, <em>order='F'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.as_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in device memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str</span></dt>
<dd><p class="first last">List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘F’ or ‘C’</span></dt>
<dd><p class="first last">Optional argument to determine whether to return a column major
(Fortran) matrix or a row major (C) matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A (nrow x ncol) numpy ndarray in “F” order.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.as_matrix">
<code class="descname">as_matrix</code><span class="sig-paren">(</span><em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.as_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in host memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str</span></dt>
<dd><p class="first last">List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A (nrow x ncol) numpy ndarray in “F” order.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign columns to DataFrame from keyword arguments.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">0  0  3</span>
<span class="go">1  1  4</span>
<span class="go">2  2  5</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.columns">
<code class="descname">columns</code><a class="headerlink" href="#cudf.dataframe.DataFrame.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of columns</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this dataframe</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>deep: bool</strong></dt>
<dd><p class="first last">Make a full copy of Series columns and Index at the GPU level, or
create a new allocation with references.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop column(s)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>labels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or sequence of strings</span></dt>
<dd><p class="first last">Name of column(s) to be dropped.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A dataframe without dropped column(s)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_new</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;val&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_new</span><span class="p">)</span>
<span class="go">   key</span>
<span class="go">0    0</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.drop_column">
<code class="descname">drop_column</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.drop_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop a column by <em>name</em></p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.dtypes">
<code class="descname">dtypes</code><a class="headerlink" href="#cudf.dataframe.DataFrame.dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dtypes in this object.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.fillna">
<code class="descname">fillna</code><span class="sig-paren">(</span><em>value</em>, <em>method=None</em>, <em>axis=None</em>, <em>inplace=False</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar, Series-like or dict</span></dt>
<dd><p class="first last">Value to use to fill nulls. If Series-like, null values
are filled with values in corresponding indices.
A dict can be used to provide different values to fill nulls
in different columns.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">Copy with nulls filled.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  4  5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  3  5</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_arrow">
<em class="property">classmethod </em><code class="descname">from_arrow</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a PyArrow Table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError for invalid input type.</strong></dt>
<dd></dd>
<dt><strong>**Notes**</strong></dt>
<dd></dd>
<dt><strong>Does not support automatically setting index column(s) similar to how</strong></dt>
<dd></dd>
<dt><strong>``to_pandas`` works for PyArrow Tables.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">,</span> <span class="s1">&#39;f1&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_batches</span><span class="p">([</span><span class="n">batch</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_arrow</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
<span class="go">&lt;cudf.DataFrame ncols=2 nrows=3 &gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_gpu_matrix">
<em class="property">classmethod </em><code class="descname">from_gpu_matrix</code><span class="sig-paren">(</span><em>data</em>, <em>index=None</em>, <em>columns=None</em>, <em>nan_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numba gpu ndarray.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numba gpu ndarray</span></dt>
<dd></dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of column names to include.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_pandas">
<em class="property">classmethod </em><code class="descname">from_pandas</code><span class="sig-paren">(</span><em>dataframe</em>, <em>nan_as_null=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a Pandas DataFrame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError for invalid input type.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="go">&lt;cudf.DataFrame ncols=2 nrows=3 &gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_records">
<em class="property">classmethod </em><code class="descname">from_records</code><span class="sig-paren">(</span><em>data</em>, <em>index=None</em>, <em>columns=None</em>, <em>nan_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numpy recarray or structured array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy structured dtype or recarray of ndim=2</span></dt>
<dd></dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of column names to include.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.groupby">
<code class="descname">groupby</code><span class="sig-paren">(</span><em>by=None</em>, <em>sort=False</em>, <em>as_index=True</em>, <em>method='hash'</em>, <em>level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list-of-str or str</span></dt>
<dd><p class="first last">Column name(s) to form that groups by.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Force sorting group keys.
Depends on the underlying algorithm.</p>
</dd>
<dt><strong>as_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool; defaults to False</span></dt>
<dd><p class="first last">Must be False.  Provided to be API compatible with pandas.
The keys are always left as regular columns in the result.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A string indicating the method to use to perform the group by.
Valid values are “hash” or “cudf”.
“cudf” method may be deprecated in the future, but is currently
the only method supporting group UDFs via the <cite>apply</cite> function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>The groupby object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Unlike pandas, this groupby operation behaves like a SQL groupby.
No empty rows are returned.  (For categorical keys, pandas returns
rows for all categories even if they are no corresponding values.)</p>
<p>Only a minimal number of operations is implemented so far.</p>
<ul class="simple">
<li>Only <em>by</em> argument is supported.</li>
<li>Since we don’t support multiindex, the <em>by</em> columns are stored
as regular columns.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.hash_columns">
<code class="descname">hash_columns</code><span class="sig-paren">(</span><em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.hash_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the given <em>columns</em> and return a new Series</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>column</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str; optional</span></dt>
<dd><p class="first last">Sequence of column names. If columns is <em>None</em> (unspecified),
all columns in the frame are used.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.head">
<code class="descname">head</code><span class="sig-paren">(</span><em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.iloc">
<code class="descname">iloc</code><a class="headerlink" href="#cudf.dataframe.DataFrame.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a  integer-location based indexer for selection by position.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># get the row from index 1st</span>
<span class="go">a    1</span>
<span class="go">b    1</span>
<span class="go">c    1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">18</span><span class="p">]]</span>  <span class="c1"># get the rows from indices 0,2,9 and 18.</span>
<span class="go">      a    b    c</span>
<span class="go"> 0    0    0    0</span>
<span class="go"> 2    2    2    2</span>
<span class="go"> 9    9    9    9</span>
<span class="go">18   18   18   18</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># get the rows using slice indices</span>
<span class="go">     a    b    c</span>
<span class="go">3    3    3    3</span>
<span class="go">5    5    5    5</span>
<span class="go">7    7    7    7</span>
<span class="go">9    9    9    9</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.index">
<code class="descname">index</code><a class="headerlink" href="#cudf.dataframe.DataFrame.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the DataFrame</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.iteritems">
<code class="descname">iteritems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over column names and series pairs</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>other</em>, <em>on=None</em>, <em>how='left'</em>, <em>lsuffix=''</em>, <em>rsuffix=''</em>, <em>sort=False</em>, <em>type=''</em>, <em>method='hash'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join columns with other DataFrame on index or on a key column.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
<dt><strong>how</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Only accepts “left”, “right”, “inner”, “outer”</p>
</dd>
<dt><strong>lsuffix, rsuffix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The suffices to add to the left (<em>lsuffix</em>) and right (<em>rsuffix</em>)
column names when avoiding conflicts.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set to True to ensure sorted ordering.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>joined</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Difference from pandas:</p>
<ul class="simple">
<li><em>other</em> must be a single DataFrame for now.</li>
<li><em>on</em> is not supported yet due to lack of multi-index support.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.label_encoding">
<code class="descname">label_encoding</code><span class="sig-paren">(</span><em>column</em>, <em>prefix</em>, <em>cats</em>, <em>prefix_sep='_'</em>, <em>dtype=None</em>, <em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode labels in a column with label encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>column</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the new column name prefix.</p>
</dd>
<dt><strong>cats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ints</span></dt>
<dd><p class="first last">the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt>
<dd><p class="first last">the dtype for the outputs; see Series.label_encoding</p>
</dd>
<dt><strong>na_sentinel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd><p class="first last">Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>a new dataframe with a new column append for the coded values.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.loc">
<code class="descname">loc</code><a class="headerlink" href="#cudf.dataframe.DataFrame.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a label-based indexer for row-slicing and column selection.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))])</span>
</pre></div>
</div>
<p>Get the row by index label from ‘a’ and ‘b’ columns</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]</span>
<span class="go">a    0</span>
<span class="go">b    0</span>
</pre></div>
</div>
<p>Get rows from index 2 to index 5 from ‘a’ and ‘b’ columns.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]</span>
<span class="go">   a  b</span>
<span class="go">2  2  2</span>
<span class="go">3  3  3</span>
<span class="go">4  4  4</span>
<span class="go">5  5  5</span>
</pre></div>
</div>
<p>Get the every 3rd rows from index 2 to 10 from ‘a’ and ‘b’</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]</span>
<span class="go">    a    b</span>
<span class="go">2   2    2</span>
<span class="go">5   5    5</span>
<span class="go">8   8    8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>right</em>, <em>on=None</em>, <em>how='inner'</em>, <em>left_on=None</em>, <em>right_on=None</em>, <em>left_index=False</em>, <em>right_index=False</em>, <em>lsuffix=None</em>, <em>rsuffix=None</em>, <em>type=''</em>, <em>method='hash'</em>, <em>indicator=False</em>, <em>suffixes=('_x'</em>, <em>'_y')</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge GPU DataFrame objects by performing a database-style join
operation by columns or indexes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>right</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
<dt><strong>on</strong> <span class="classifier-delimiter">:</span> <span class="classifier">label or list; defaults to None</span></dt>
<dd><p class="first">Column or index level names to join on. These must be found in
both DataFrames.</p>
<p class="last">If on is None and not merging on indexes then
this defaults to the intersection of the columns
in both DataFrames.</p>
</dd>
<dt><strong>left_on</strong> <span class="classifier-delimiter">:</span> <span class="classifier">label or list, or array-like</span></dt>
<dd><p class="first last">Column or index level names to join on in the left DataFrame.
Can also be an array or list of arrays of the length of the
left DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>right_on</strong> <span class="classifier-delimiter">:</span> <span class="classifier">label or list, or array-like</span></dt>
<dd><p class="first last">Column or index level names to join on in the right DataFrame.
Can also be an array or list of arrays of the length of the
right DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>left_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Use the index from the left DataFrame as the join key(s).</p>
</dd>
<dt><strong>right_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Use the index from the right DataFrame as the join key.</p>
</dd>
<dt><strong>how</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to ‘left’</span></dt>
<dd><p class="first last">Only accepts ‘left’
left: use only keys from left frame, similar to
a SQL left outer join; preserve key order</p>
</dd>
<dt><strong>suffixes: Tuple[str, str], defaults to (‘_x’, ‘_y’)</strong></dt>
<dd><p class="first last">Suffixes applied to overlapping column names on the left and right
sides</p>
</dd>
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to ‘hash’</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>merged</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">&#39;vals_a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;vals_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span> <span class="o">=</span> <span class="n">df_a</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_b</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">)</span>  <span class="c1"># doctest: +SKIP</span>
<span class="go">   key  vals_a  vals_b</span>
<span class="go">3    0    10.0</span>
<span class="go">0    1    11.0    10.0</span>
<span class="go">1    2    12.0    11.0</span>
<span class="go">4    3    13.0</span>
<span class="go">2    4    14.0    12.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.nlargest">
<code class="descname">nlargest</code><span class="sig-paren">(</span><em>n</em>, <em>columns</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p>
<p class="rubric">Notes</p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.nsmallest">
<code class="descname">nsmallest</code><span class="sig-paren">(</span><em>n</em>, <em>columns</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.one_hot_encoding">
<code class="descname">one_hot_encoding</code><span class="sig-paren">(</span><em>column</em>, <em>prefix</em>, <em>cats</em>, <em>prefix_sep='_'</em>, <em>dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a column with one-hot-encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>column</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the new column name prefix.</p>
</dd>
<dt><strong>cats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ints</span></dt>
<dd><p class="first last">the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt>
<dd><p class="first last">the dtype for the outputs; defaults to float64.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a new dataframe with new columns append for each category.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_owner</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;pet_owner&#39;</span><span class="p">:</span> <span class="n">pet_owner</span><span class="p">,</span> <span class="s1">&#39;pet_type&#39;</span><span class="p">:</span> <span class="n">pet_type</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">pet_type</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a column with numerically encoded category values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Create the list of category codes to use in the encoding</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">pet_codes</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">one_hot_encoding</span><span class="p">(</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">,</span> <span class="s1">&#39;pet_dummy&#39;</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">  pet_owner  pet_type  pet_codes  pet_dummy_0  pet_dummy_1  pet_dummy_2</span>
<span class="go">0         1      fish          2          0.0          0.0          1.0</span>
<span class="go">1         2       dog          1          0.0          1.0          0.0</span>
<span class="go">2         3      fish          2          0.0          0.0          1.0</span>
<span class="go">3         4      bird          0          1.0          0.0          0.0</span>
<span class="go">4         5      fish          2          0.0          0.0          1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.partition_by_hash">
<code class="descname">partition_by_hash</code><span class="sig-paren">(</span><em>columns</em>, <em>nparts</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.partition_by_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str</span></dt>
<dd><p class="first last">The names of the columns to be hashed.
Must have at least one name.</p>
</dd>
<dt><strong>nparts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of output partitions</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>partitioned: list of DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>q=0.5</em>, <em>interpolation='linear'</em>, <em>columns=None</em>, <em>exact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array-like</span></dt>
<dd><p class="first last">0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{<cite>linear</cite>, <cite>lower</cite>, <cite>higher</cite>, <cite>midpoint</cite>, <cite>nearest</cite>}</span></dt>
<dd><p class="first last">This  parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j.
Default ‘linear’.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of column names to include.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether to use approximate or exact quantile algorithm.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.query">
<code class="descname">query</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Query with a boolean expression using Numba to compile a GPU kernel.</p>
<p>See pandas.DataFrame.query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>expr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">A boolean expression. Names in expression refer to columns.</p>
<p class="last">Names starting with <cite>&#64;</cite> refer to Python variables</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filtered</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;(a == 2 and b == 4) or (b == 3)&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
</pre></div>
</div>
<p>DateTime conditionals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;2018-10-07&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-10-08&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetimes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-08&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;datetimes==@search_date&#39;</span><span class="p">))</span>
<span class="go">                datetimes</span>
<span class="go">1 2018-10-08T00:00:00.000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.rename">
<code class="descname">rename</code><span class="sig-paren">(</span><em>mapper=None</em>, <em>columns=None</em>, <em>copy=True</em>, <em>inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter column labels.</p>
<p>Function / dict values must be unique (1-to-1). Labels not contained in
a dict / Series will be left as-is. Extra labels listed don’t throw an
error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>mapper, columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict-like or function, optional</span></dt>
<dd><p class="first last">dict-like or functions transformations to apply to
the column axis’ values.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default True</span></dt>
<dd><p class="first last">Also copy underlying data</p>
</dd>
<dt><strong>inplace: boolean, default False</strong></dt>
<dd><p class="first last">Retrun new DataFrame.  If True, assign columns without copy</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Difference from pandas:</dt>
<dd><ul class="first last simple">
<li>Support axis=’columns’ only.</li>
<li>Not supporting: index, level</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>to_replace</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <em>to_replace</em> with <em>value</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>to_replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numeric, str, list-like or dict</span></dt>
<dd><p class="first">Value(s) to replace.</p>
<ul class="last">
<li><p class="first">numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li>values equal to <em>to_replace</em> will be replaced
with <em>value</em></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">list of numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li>If <em>value</em> is also list-like,
<em>to_replace</em> and <em>value</em> must be of same length.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">dict:</p>
<blockquote>
<div><ul class="simple">
<li>Dicts can be used to replace different values in different
columns. For example, <cite>{‘a’: 1, ‘z’: 2}</cite> specifies that the
value 1 in column <cite>a</cite> and the value 2 in column <cite>z</cite> should be
replaced with value*.</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numeric, str, list-like, or dict</span></dt>
<dd><p class="first last">Value(s) to replace <cite>to_replace</cite> with. If a dict is provided, then
its keys must match the keys in <em>to_replace</em>, and correponding
values must be compatible (e.g., if they are lists, then they must
match in length).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">DataFrame after replacement.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.select_dtypes">
<code class="descname">select_dtypes</code><span class="sig-paren">(</span><em>include=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.select_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>include</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list</span></dt>
<dd><p class="first last">which columns to include based on dtypes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.set_index">
<code class="descname">set_index</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame with a new index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index, Series-convertible, or str</span></dt>
<dd><p class="first last">Index : the new index.
Series-convertible : values for the new index.
str : name of column to be used as series</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.shape">
<code class="descname">shape</code><a class="headerlink" href="#cudf.dataframe.DataFrame.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.sort_index">
<code class="descname">sort_index</code><span class="sig-paren">(</span><em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.sort_values">
<code class="descname">sort_values</code><span class="sig-paren">(</span><em>by</em>, <em>ascending=True</em>, <em>na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values row-wise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or list of str</span></dt>
<dd><p class="first last">Name or list of names to sort by.</p>
</dd>
<dt><strong>ascending</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool or list of bool, default True</span></dt>
<dd><p class="first last">Sort ascending vs. descending. Specify list for multiple sort
orders. If this is a list of bools, must match the length of the
by.</p>
</dd>
<dt><strong>na_position</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt>
<dd><p class="first last">‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>sorted_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">cuDF DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Difference from pandas:</dt>
<dd><ul class="first last simple">
<li>Support axis=’index’ only.</li>
<li>Not supporting: inplace, kind</li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  0 -3</span>
<span class="go">2  2  0</span>
<span class="go">1  1  2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.tail">
<code class="descname">tail</code><span class="sig-paren">(</span><em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_arrow">
<code class="descname">to_arrow</code><span class="sig-paren">(</span><em>preserve_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a PyArrow Table.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span>
<span class="go">pyarrow.Table</span>
<span class="go">None: int64</span>
<span class="go">a: int64</span>
<span class="go">b: int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_dlpack">
<code class="descname">to_dlpack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>cudf_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame, Series, Index, or Column</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pycapsule_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PyCapsule</span></dt>
<dd><p class="first last">Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_feather">
<code class="descname">to_feather</code><span class="sig-paren">(</span><em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">File path</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_gpu_matrix">
<code class="descname">to_gpu_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numba gpu ndarray</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>numba gpu ndarray</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_hdf">
<code class="descname">to_hdf</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>key</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path_or_buf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or pandas.HDFStore</span></dt>
<dd><p class="first last">File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt>
<dd><p class="first">Mode to open file:</p>
<ul class="last simple">
<li>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</li>
<li>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</li>
<li>‘r+’: similar to ‘a’, but the file must already exist.</li>
</ul>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt>
<dd><p class="first">Possible values:</p>
<ul class="simple">
<li>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,</li>
</ul>
<p class="last">nor searchable.
- ‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p>
</dd>
<dt><strong>append</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of columns or True, optional</span></dt>
<dd><p class="first last">List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{0-9}, optional</span></dt>
<dd><p class="first last">Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt>
<dd><p class="first last">Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default ‘strict’</span></dt>
<dd><p class="first last">Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt>
<dd>Read from HDF file.</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt>
<dd>Write a DataFrame to the binary parquet format.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather..to_feather</span></code></dt>
<dd>Write out feather-format for DataFrames.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><em>path_or_buf=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path_or_buf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or file handle, optional</span></dt>
<dd><p class="first last">File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Indication of expected JSON string format.
* Series</p>
<blockquote>
<div><ul class="simple">
<li>default is ‘index’</li>
<li>allowed values are: {‘split’,’records’,’index’,’table’}</li>
</ul>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>DataFrame</dt>
<dd><ul class="first simple">
<li>default is ‘columns’</li>
<li>allowed values are:</li>
</ul>
<p class="last">{‘split’,’records’,’index’,’columns’,’values’,’table’}</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The format of the JSON string</dt>
<dd><ul class="first simple">
<li>‘split’ : dict like {‘index’ -&gt; [index],</li>
</ul>
<p class="last">‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}
- ‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]
- ‘index’ : dict like {index -&gt; {column -&gt; value}}
- ‘columns’ : dict like {column -&gt; {index -&gt; value}}
- ‘values’ : just the values array
- ‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt>
<dd><p class="first last">Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default 10</span></dt>
<dd><p class="first last">The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, default ‘ms’ (milliseconds)</span></dt>
<dd><p class="first last">The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, default None</span></dt>
<dd><p class="first last">Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt><strong>lines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt>
<dd><p class="first last">A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
<dt><strong>See Also</strong></dt>
<dd></dd>
<dt><strong>——–</strong></dt>
<dd></dd>
<dt><strong>.cudf.io.json.read_json</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_pandas">
<code class="descname">to_pandas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas DataFrame.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>
<span class="go">&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_parquet">
<code class="descname">to_parquet</code><span class="sig-paren">(</span><em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt>
<dd><p class="first last">Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default None</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional, default None</span></dt>
<dd><p class="first last">Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a>, <a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_records">
<code class="descname">to_records</code><span class="sig-paren">(</span><em>index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numpy recarray</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to include the index in the output.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>numpy recarray</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>nrows=NOTSET</em>, <em>ncols=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nrows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of rows to show.
If it is None, all rows are shown.</p>
</dd>
<dt><strong>ncols</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of columns to show.
If it is None, all columns are shown.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
<span class="go">&#39;   key   val\n0    0  10.0\n1    1  11.0\n2    2  12.0&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.transpose">
<code class="descname">transpose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose index and columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a new (ncol x nrow) dataframe. self is (nrow x ncol)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Difference from pandas:
Not supporting <em>copy</em> because default and only behaviour is copy=True</p>
</dd></dl>

</dd></dl>

<span class="target" id="module-cudf.multi"></span><dl class="function">
<dt id="cudf.multi.concat">
<code class="descclassname">cudf.multi.</code><code class="descname">concat</code><span class="sig-paren">(</span><em>objs</em>, <em>axis=0</em>, <em>ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.multi.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate DataFrames, Series, or Indices row-wise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>objs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of DataFrame, Series, or Index</span></dt>
<dd></dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">concatenation axis, 0 - index, 1 - columns</span></dt>
<dd></dd>
<dt><strong>ignore_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set True to ignore the index of the <em>objs</em> and provide a
default range index instead.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A new object of like type with rows from each object in ``objs``.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-cudf.reshape.general"></span><dl class="function">
<dt id="cudf.reshape.general.melt">
<code class="descclassname">cudf.reshape.general.</code><code class="descname">melt</code><span class="sig-paren">(</span><em>frame</em>, <em>id_vars=None</em>, <em>value_vars=None</em>, <em>var_name='variable'</em>, <em>value_name='value'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>frame</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
<dt><strong>id_vars</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, list, or ndarray, optional</span></dt>
<dd><p class="first last">Column(s) to use as identifier variables.
default: None</p>
</dd>
<dt><strong>value_vars</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple, list, or ndarray, optional</span></dt>
<dd><p class="first last">Column(s) to unpivot.
default: all columns that are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">Name to use for the <cite>variable</cite> column.
default: frame.columns.name or ‘variable’</p>
</dd>
<dt><strong>value_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name to use for the <cite>value</cite> column.
default: ‘value’</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>out</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">Melted result</p>
</dd>
<dt><strong>Difference from pandas:</strong></dt>
<dd><ul class="first last simple">
<li>Does not support ‘col_level’ because cuDF does not have multi-index</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="n">value_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">])</span>
<span class="go">     A    B variable value</span>
<span class="go">0    1    1        C   1.0</span>
<span class="go">1    1    3        C</span>
<span class="go">2    5    6        C   4.0</span>
<span class="go">3    1    1        D   2.0</span>
<span class="go">4    1    3        D   5.0</span>
<span class="go">5    5    6        D   6.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.reshape.general.Series">
<em class="property">class </em><code class="descclassname">cudf.reshape.general.</code><code class="descname">Series</code><span class="sig-paren">(</span><em>data=None</em>, <em>index=None</em>, <em>name=None</em>, <em>nan_as_null=True</em>, <em>dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series" title="Permalink to this definition">¶</a></dt>
<dd><p>Data and null-masks.</p>
<p><code class="docutils literal notranslate"><span class="pre">Series</span></code> objects are used as columns of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cat</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.data" title="cudf.reshape.general.Series.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a></dt>
<dd><p class="first last">The gpu buffer for the data</p>
</dd>
<dt><strong>dt</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.dtype" title="cudf.reshape.general.Series.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt>
<dd><p class="first last">dtype of the Series</p>
</dd>
<dt><strong>empty</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.has_null_mask" title="cudf.reshape.general.Series.has_null_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_null_mask</span></code></a></dt>
<dd><p class="first last">A boolean indicating whether a null-mask is needed</p>
</dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.iloc" title="cudf.reshape.general.Series.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt>
<dd><p class="first last">For integer-location based selection.</p>
</dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.index" title="cudf.reshape.general.Series.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt>
<dd><p class="first last">The index object</p>
</dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.null_count" title="cudf.reshape.general.Series.null_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">null_count</span></code></a></dt>
<dd><p class="first last">Number of null values</p>
</dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.nullmask" title="cudf.reshape.general.Series.nullmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nullmask</span></code></a></dt>
<dd><p class="first last">The gpu buffer for the null-mask</p>
</dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.shape" title="cudf.reshape.general.Series.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt>
<dd><p class="first last">Returns a tuple representing the dimensionality of the Series.</p>
</dd>
<dt><strong>str</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.reshape.general.Series.valid_count" title="cudf.reshape.general.Series.valid_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">valid_count</span></code></a></dt>
<dd><p class="first last">Number of non-null values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.append" title="cudf.reshape.general.Series.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(arbitrary)</td>
<td>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.applymap" title="cudf.reshape.general.Series.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">applymap</span></code></a>(udf[,&nbsp;out_dtype])</td>
<td>Apply a elemenwise function to transform the values in the Column.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.argsort" title="cudf.reshape.general.Series.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>([ascending,&nbsp;na_position])</td>
<td>Returns a Series of int64 index that will sort the series.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.as_mask" title="cudf.reshape.general.Series.as_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_mask</span></code></a>()</td>
<td>Convert booleans to bitmask</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.astype" title="cudf.reshape.general.Series.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(dtype)</td>
<td>Convert to the given <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.ceil" title="cudf.reshape.general.Series.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>()</td>
<td>Rounds each value upward to the smallest integral value not less than the original.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.count" title="cudf.reshape.general.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>([axis,&nbsp;skipna])</td>
<td>The number of non-null values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.digitize" title="cudf.reshape.general.Series.digitize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">digitize</span></code></a>(bins[,&nbsp;right])</td>
<td>Return the indices of the bins to which each value in series belongs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.factorize" title="cudf.reshape.general.Series.factorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorize</span></code></a>([na_sentinel])</td>
<td>Encode the input values as integer labels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.fillna" title="cudf.reshape.general.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(value[,&nbsp;method,&nbsp;axis,&nbsp;inplace,&nbsp;limit])</td>
<td>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.find_first_value" title="cudf.reshape.general.Series.find_first_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_first_value</span></code></a>(value)</td>
<td>Returns offset of first value that matches</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.find_last_value" title="cudf.reshape.general.Series.find_last_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_last_value</span></code></a>(value)</td>
<td>Returns offset of last value that matches</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.floor" title="cudf.reshape.general.Series.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>()</td>
<td>Rounds each value downward to the largest integral value not greater than the original.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.from_categorical" title="cudf.reshape.general.Series.from_categorical"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_categorical</span></code></a>(categorical[,&nbsp;codes])</td>
<td>Creates from a pandas.Categorical</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.from_masked_array" title="cudf.reshape.general.Series.from_masked_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_masked_array</span></code></a>(data,&nbsp;mask[,&nbsp;null_count])</td>
<td>Create a Series with null-mask.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.hash_encode" title="cudf.reshape.general.Series.hash_encode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_encode</span></code></a>(stop[,&nbsp;use_name])</td>
<td>Encode column values as ints in [0, stop) using hash function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.hash_values" title="cudf.reshape.general.Series.hash_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_values</span></code></a>()</td>
<td>Compute the hash of values in this column.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.label_encoding" title="cudf.reshape.general.Series.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(cats[,&nbsp;dtype,&nbsp;na_sentinel])</td>
<td>Perform label encoding</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.masked_assign" title="cudf.reshape.general.Series.masked_assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">masked_assign</span></code></a>(value,&nbsp;mask)</td>
<td>Assign a scalar value to a series using a boolean mask df[df &lt; 0] = 0</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.max" title="cudf.reshape.general.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the max of the series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.mean" title="cudf.reshape.general.Series.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the mean of the series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.mean_var" title="cudf.reshape.general.Series.mean_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_var</span></code></a>([ddof])</td>
<td>Compute mean and variance at the same time.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.min" title="cudf.reshape.general.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the min of the series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.nlargest" title="cudf.reshape.general.Series.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>([n,&nbsp;keep])</td>
<td>Returns a new Series of the <em>n</em> largest element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.nsmallest" title="cudf.reshape.general.Series.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>([n,&nbsp;keep])</td>
<td>Returns a new Series of the <em>n</em> smallest element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.nunique" title="cudf.reshape.general.Series.nunique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nunique</span></code></a>([method,&nbsp;dropna])</td>
<td>Returns the number of unique values of the Series: approximate version, and exact version to be moved to libgdf</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.one_hot_encoding" title="cudf.reshape.general.Series.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(cats[,&nbsp;dtype])</td>
<td>Perform one-hot-encoding</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.product" title="cudf.reshape.general.Series.product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">product</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the product of the series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.quantile" title="cudf.reshape.general.Series.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(q[,&nbsp;interpolation,&nbsp;exact,&nbsp;quant_index])</td>
<td>Return values at the given quantile.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.rename" title="cudf.reshape.general.Series.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>([index,&nbsp;copy])</td>
<td>Alter Series name.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.replace" title="cudf.reshape.general.Series.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(to_replace,&nbsp;value)</td>
<td>Replace values given in <em>to_replace</em> with <em>value</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.reset_index" title="cudf.reshape.general.Series.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_index</span></code></a>([drop])</td>
<td>Reset index to RangeIndex</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.reverse" title="cudf.reshape.general.Series.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>()</td>
<td>Reverse the Series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.scale" title="cudf.reshape.general.Series.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a>()</td>
<td>Scale values to [0, 1] in float64</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.set_index" title="cudf.reshape.general.Series.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(index)</td>
<td>Returns a new Series with a different index.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.set_mask" title="cudf.reshape.general.Series.set_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_mask</span></code></a>(mask[,&nbsp;null_count])</td>
<td>Create new Series by setting a mask array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.sort_index" title="cudf.reshape.general.Series.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>([ascending])</td>
<td>Sort by the index.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.sort_values" title="cudf.reshape.general.Series.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>([ascending,&nbsp;na_position])</td>
<td>Sort by the values.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.std" title="cudf.reshape.general.Series.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>([ddof,&nbsp;axis,&nbsp;skipna])</td>
<td>Compute the standard deviation of the series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.sum" title="cudf.reshape.general.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the sum of the series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.tail" title="cudf.reshape.general.Series.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>([n])</td>
<td>Returns the last n rows as a new Series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.take" title="cudf.reshape.general.Series.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(indices[,&nbsp;ignore_index])</td>
<td>Return Series by taking values from the corresponding <em>indices</em>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.to_array" title="cudf.reshape.general.Series.to_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_array</span></code></a>([fillna])</td>
<td>Get a dense numpy array for the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.to_dlpack" title="cudf.reshape.general.Series.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>()</td>
<td>Converts a cuDF object into a DLPack tensor.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.to_frame" title="cudf.reshape.general.Series.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_frame</span></code></a>([name])</td>
<td>Convert Series into a DataFrame</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.to_gpu_array" title="cudf.reshape.general.Series.to_gpu_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_array</span></code></a>([fillna])</td>
<td>Get a dense numba device array for the data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.to_hdf" title="cudf.reshape.general.Series.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(path_or_buf,&nbsp;key,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Write the contained data to an HDF5 file using HDFStore.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.to_json" title="cudf.reshape.general.Series.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>([path_or_buf])</td>
<td>Convert the cuDF object to a JSON string.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.to_string" title="cudf.reshape.general.Series.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>([nrows])</td>
<td>Convert to string</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.unique" title="cudf.reshape.general.Series.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>([method,&nbsp;sort])</td>
<td>Returns unique values of this Series.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.value_counts" title="cudf.reshape.general.Series.value_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">value_counts</span></code></a>([method,&nbsp;sort])</td>
<td>Returns unique values of this Series.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.reshape.general.Series.values_to_string" title="cudf.reshape.general.Series.values_to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values_to_string</span></code></a>([nrows])</td>
<td>Returns a list of string for each element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.reshape.general.Series.var" title="cudf.reshape.general.Series.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>([ddof,&nbsp;axis,&nbsp;skipna])</td>
<td>Compute the variance of the series</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="36%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>as_index</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>copy</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>deserialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>from_arrow</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>from_pandas</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>groupby</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>head</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>serialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>sum_of_squares</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>to_arrow</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>to_pandas</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>unique_k</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.reshape.general.Series.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>arbitrary</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.
Returns a new copy with the index resetted.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.applymap">
<code class="descname">applymap</code><span class="sig-paren">(</span><em>udf</em>, <em>out_dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.applymap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a elemenwise function to transform the values in the Column.</p>
<p>The user function is expected to take one argument and return the
result, which will be stored to the output Series.  The function
cannot reference globals except for other simple scalar objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>udf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Wrapped by <code class="docutils literal notranslate"><span class="pre">numba.cuda.jit</span></code> for call on the GPU as a device
function.</p>
</dd>
<dt><strong>out_dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype; optional</span></dt>
<dd><p class="first last">The dtype for use in the output.
By default, the result will have the same dtype as the source.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series</span></dt>
<dd><p class="first last">The mask and index are preserved.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><em>ascending=True</em>, <em>na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Series of int64 index that will sort the series.</p>
<p>Uses Thrust sort.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: Series</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.as_mask">
<code class="descname">as_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.as_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert booleans to bitmask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>device array</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to the given <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>If the dtype changed, a new ``Series`` is returned by casting each</strong></dt>
<dd></dd>
<dt><strong>values to the given dtype.</strong></dt>
<dd></dd>
<dt><strong>If the dtype is not changed, ``self`` is returned.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.ceil">
<code class="descname">ceil</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value upward to the smallest integral value not less
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of non-null values</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.data">
<code class="descname">data</code><a class="headerlink" href="#cudf.reshape.general.Series.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the data</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.digitize">
<code class="descname">digitize</code><span class="sig-paren">(</span><em>bins</em>, <em>right=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.digitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the bins to which each value in series belongs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">np.array</span></dt>
<dd><p class="first last">1-D monotonically, increasing array with same type as this series.</p>
</dd>
<dt><strong>right</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates whether interval contains the right or left bin edge.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A new Series containing the indices.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Monotonicity of bins is assumed and not checked.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#cudf.reshape.general.Series.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>dtype of the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.factorize">
<code class="descname">factorize</code><span class="sig-paren">(</span><em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.factorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the input values as integer labels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>na_sentinel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd><p class="first last">Value to indicate missing category.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>(labels, cats)</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(Series, Series)</span></dt>
<dd><ul class="first last simple">
<li><em>labels</em> contains the encoded values</li>
<li><em>cats</em> contains the categories in order that the N-th
item corresponds to the (N-1) code.</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.fillna">
<code class="descname">fillna</code><span class="sig-paren">(</span><em>value</em>, <em>method=None</em>, <em>axis=None</em>, <em>inplace=False</em>, <em>limit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar or Series-like</span></dt>
<dd><p class="first last">Value to use to fill nulls. If Series-like, null values
are filled with the values in corresponding indices of the
given Series.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series</span></dt>
<dd><p class="first last">Copy with nulls filled.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.find_first_value">
<code class="descname">find_first_value</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.find_first_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of first value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.find_last_value">
<code class="descname">find_last_value</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.find_last_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of last value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.floor">
<code class="descname">floor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value downward to the largest integral value not greater
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.reshape.general.Series.from_categorical">
<em class="property">classmethod </em><code class="descname">from_categorical</code><span class="sig-paren">(</span><em>categorical</em>, <em>codes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.from_categorical" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates from a pandas.Categorical</p>
<p>If <code class="docutils literal notranslate"><span class="pre">codes</span></code> is defined, use it instead of <code class="docutils literal notranslate"><span class="pre">categorical.codes</span></code></p>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.reshape.general.Series.from_masked_array">
<em class="property">classmethod </em><code class="descname">from_masked_array</code><span class="sig-paren">(</span><em>data</em>, <em>mask</em>, <em>null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.from_masked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Series with null-mask.
This is equivalent to:</p>
<blockquote>
<div>Series(data).set_mask(mask, null_count=null_count)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array-like</span></dt>
<dd><p class="first last">The values.  Null values must not be skipped.  They can appear
as garbage values.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array-like of numpy.uint8</span></dt>
<dd><p class="first">The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.has_null_mask">
<code class="descname">has_null_mask</code><a class="headerlink" href="#cudf.reshape.general.Series.has_null_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean indicating whether a null-mask is needed</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.hash_encode">
<code class="descname">hash_encode</code><span class="sig-paren">(</span><em>stop</em>, <em>use_name=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.hash_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode column values as ints in [0, stop) using hash function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>stop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The upper bound on the encoding range.</p>
</dd>
<dt><strong>use_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">True</span></code> then combine hashed column values
with hashed column name. This is useful for when the same
values in different columns should be encoded
with different hashed values.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>result: Series</strong></dt>
<dd><p class="first last">The encoded Series.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.hash_values">
<code class="descname">hash_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.hash_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hash of values in this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.iloc">
<code class="descname">iloc</code><a class="headerlink" href="#cudf.reshape.general.Series.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>For integer-location based selection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Series containing the elements corresponding to the indices</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))</span>
</pre></div>
</div>
<p>Get the value from 1st index</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Get the values from 0,2,9 and 18th index</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
<span class="go"> 0    0</span>
<span class="go"> 2    2</span>
<span class="go"> 9    9</span>
<span class="go">18   18</span>
</pre></div>
</div>
<p>Get the values using slice indices</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">3    3</span>
<span class="go">5    5</span>
<span class="go">7    7</span>
<span class="go">9    9</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.index">
<code class="descname">index</code><a class="headerlink" href="#cudf.reshape.general.Series.index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index object</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.label_encoding">
<code class="descname">label_encoding</code><span class="sig-paren">(</span><em>cats</em>, <em>dtype=None</em>, <em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform label encoding</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of input values</span></dt>
<dd></dd>
<dt><strong>dtype: numpy.dtype; optional</strong></dt>
<dd><p class="first last">Specifies the output dtype.  If <cite>None</cite> is given, the
smallest possible integer dtype (starting with np.int32)
is used.</p>
</dd>
<dt><strong>na_sentinel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd><p class="first last">Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>A sequence of encoded labels with value between 0 and n-1 classes(cats)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.masked_assign">
<code class="descname">masked_assign</code><span class="sig-paren">(</span><em>value</em>, <em>mask</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.masked_assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign a scalar value to a series using a boolean mask
df[df &lt; 0] = 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">scalar value for assignment</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">cudf Series</span></dt>
<dd><p class="first last">Boolean Series</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cudf Series</strong></dt>
<dd><p class="first last">cudf series with new value set to where mask is True</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.mean_var">
<code class="descname">mean_var</code><span class="sig-paren">(</span><em>ddof=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.mean_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance at the same time.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the min of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.nlargest">
<code class="descname">nlargest</code><span class="sig-paren">(</span><em>n=5</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> largest element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.nsmallest">
<code class="descname">nsmallest</code><span class="sig-paren">(</span><em>n=5</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> smallest element.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.null_count">
<code class="descname">null_count</code><a class="headerlink" href="#cudf.reshape.general.Series.null_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of null values</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.nullmask">
<code class="descname">nullmask</code><a class="headerlink" href="#cudf.reshape.general.Series.nullmask" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the null-mask</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.nunique">
<code class="descname">nunique</code><span class="sig-paren">(</span><em>method='sort'</em>, <em>dropna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.nunique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of unique values of the Series: approximate version,
and exact version to be moved to libgdf</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.one_hot_encoding">
<code class="descname">one_hot_encoding</code><span class="sig-paren">(</span><em>cats</em>, <em>dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one-hot-encoding</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>cats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of values</span></dt>
<dd><p class="first last">values representing each category.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype</span></dt>
<dd><p class="first last">specifies the output dtype.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A sequence of new series for each category.  Its length is determined</strong></dt>
<dd></dd>
<dt><strong>by the length of ``cats``.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.product">
<code class="descname">product</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the product of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>q</em>, <em>interpolation='midpoint'</em>, <em>exact=True</em>, <em>quant_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array-like, default 0.5 (50% quantile)</span></dt>
<dd><p class="first last">0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{’linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt>
<dd><p class="first last">This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j:</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of column names to include.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether to use approximate or exact quantile algorithm.</p>
</dd>
<dt><strong>quant_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether to use the list of quantiles as index.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.rename">
<code class="descname">rename</code><span class="sig-paren">(</span><em>index=None</em>, <em>copy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter Series name.</p>
<p>Change Series.name with a scalar value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Scalar, optional</span></dt>
<dd><p class="first last">Scalar to alter the Series.name attribute</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default True</span></dt>
<dd><p class="first last">Also copy underlying data</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Series</strong></dt>
<dd></dd>
<dt><strong>Difference from pandas:</strong></dt>
<dd><ul class="first last simple">
<li>Supports scalar values only for changing name attribute</li>
<li>Not supporting: inplace, level</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.replace">
<code class="descname">replace</code><span class="sig-paren">(</span><em>to_replace</em>, <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <em>to_replace</em> with <em>value</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>to_replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numeric, str or list-like</span></dt>
<dd><p class="first">Value(s) to replace.</p>
<ul class="last">
<li><p class="first">numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li>values equal to <em>to_replace</em> will be replaced with <em>value</em></li>
</ul>
</div></blockquote>
</li>
<li><p class="first">list of numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li>If <em>value</em> is also list-like, <em>to_replace</em> and <em>value</em> must</li>
</ul>
<p>be of same length.</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numeric, str, list-like, or dict</span></dt>
<dd><p class="first last">Value(s) to replace <cite>to_replace</cite> with.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series</span></dt>
<dd><p class="first last">Series after replacement. The mask and index are preserved.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.reshape.general.Series.fillna" title="cudf.reshape.general.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.fillna</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.reset_index">
<code class="descname">reset_index</code><span class="sig-paren">(</span><em>drop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset index to RangeIndex</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale values to [0, 1] in float64</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.set_index">
<code class="descname">set_index</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series with a different index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index, Series-convertible</span></dt>
<dd><p class="first last">the new index or values for the new index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.set_mask">
<code class="descname">set_mask</code><span class="sig-paren">(</span><em>mask</em>, <em>null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new Series by setting a mask array.</p>
<p>This will override the existing mask.  The returned Series will
reference the same data buffer as this Series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array-like of numpy.uint8</span></dt>
<dd><p class="first">The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.shape">
<code class="descname">shape</code><a class="headerlink" href="#cudf.reshape.general.Series.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.sort_index">
<code class="descname">sort_index</code><span class="sig-paren">(</span><em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.sort_values">
<code class="descname">sort_values</code><span class="sig-paren">(</span><em>ascending=True</em>, <em>na_position='last'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values.</p>
<p>Sort a Series in ascending or descending order by some criterion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ascending</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">If True, sort values in ascending order, otherwise descending.</p>
</dd>
<dt><strong>na_position</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt>
<dd><p class="first last">‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>sorted_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">cuDF Series</span></dt>
<dd></dd>
<dt><strong>Difference from pandas:</strong></dt>
<dd><ul class="first last simple">
<li>Not supporting: inplace, kind</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">2    2</span>
<span class="go">4    3</span>
<span class="go">3    4</span>
<span class="go">1    5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.std">
<code class="descname">std</code><span class="sig-paren">(</span><em>ddof=1</em>, <em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.tail">
<code class="descname">tail</code><span class="sig-paren">(</span><em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new Series</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">3    1</span>
<span class="go">4    0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.take">
<code class="descname">take</code><span class="sig-paren">(</span><em>indices</em>, <em>ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series by taking values from the corresponding <em>indices</em>.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.to_array">
<code class="descname">to_array</code><span class="sig-paren">(</span><em>fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numpy array for the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fillna</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">Defaults to None, which will skip null values.
If it equals “pandas”, null values are filled with NaNs.
Non integral dtype is promoted to np.float64.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.to_dlpack">
<code class="descname">to_dlpack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>cudf_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame, Series, Index, or Column</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>pycapsule_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PyCapsule</span></dt>
<dd><p class="first last">Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.to_frame">
<code class="descname">to_frame</code><span class="sig-paren">(</span><em>name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series into a DataFrame</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default None</span></dt>
<dd><p class="first last">Name to be used for the column</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd><p class="first last">cudf DataFrame</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.to_gpu_array">
<code class="descname">to_gpu_array</code><span class="sig-paren">(</span><em>fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.to_gpu_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numba device array for the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fillna</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">See <em>fillna</em> in <code class="docutils literal notranslate"><span class="pre">.to_array</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.to_hdf">
<code class="descname">to_hdf</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>key</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a href="#id2"><span class="problematic" id="id3">:ref:`user guide
&lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables&gt;`_</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path_or_buf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or pandas.HDFStore</span></dt>
<dd><p class="first last">File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt>
<dd><p class="first">Mode to open file:
- ‘w’: write, a new file is created (an existing file with</p>
<blockquote>
<div><p>the same name would be deleted).</p>
</div></blockquote>
<ul class="last simple">
<li><dl class="first docutils">
<dt>‘a’: append, an existing file is opened for reading and</dt>
<dd>writing, and if the file does not exist it is created.</dd>
</dl>
</li>
<li>‘r+’: similar to ‘a’, but the file must already exist.</li>
</ul>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt>
<dd><p class="first">Possible values:
- ‘fixed’: Fixed format. Fast writing/reading. Not-appendable,</p>
<blockquote>
<div><p>nor searchable.</p>
</div></blockquote>
<ul class="last simple">
<li><dl class="first docutils">
<dt>‘table’: Table format. Write as a PyTables Table structure</dt>
<dd>which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>append</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of columns or True, optional</span></dt>
<dd><p class="first last">List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">See Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{0-9}, optional</span></dt>
<dd><p class="first last">Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt>
<dd><p class="first last">Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default ‘strict’</span></dt>
<dd><p class="first last">Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.to_json">
<code class="descname">to_json</code><span class="sig-paren">(</span><em>path_or_buf=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.
Parameters
———-
path_or_buf : string or file handle, optional</p>
<blockquote>
<div>File path or object. If not specified, the result is returned as
a string.</div></blockquote>
<dl class="docutils">
<dt>orient <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Indication of expected JSON string format.
* Series</p>
<blockquote>
<div><ul class="simple">
<li>default is ‘index’</li>
<li>allowed values are: {‘split’,’records’,’index’,’table’}</li>
</ul>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>DataFrame</dt>
<dd><ul class="first simple">
<li>default is ‘columns’</li>
<li>allowed values are:</li>
</ul>
<p class="last">{‘split’,’records’,’index’,’columns’,’values’,’table’}</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The format of the JSON string</dt>
<dd><ul class="first simple">
<li>‘split’ : dict like {‘index’ -&gt; [index],</li>
</ul>
<p class="last">‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}
- ‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]
- ‘index’ : dict like {index -&gt; {column -&gt; value}}
- ‘columns’ : dict like {column -&gt; {index -&gt; value}}
- ‘values’ : just the values array
- ‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>date_format <span class="classifier-delimiter">:</span> <span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt>
<dd>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</dd>
<dt>double_precision <span class="classifier-delimiter">:</span> <span class="classifier">int, default 10</span></dt>
<dd>The number of decimal places to use when encoding
floating point values.</dd>
<dt>force_ascii <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd>Force encoded string to be ASCII.</dd>
<dt>date_unit <span class="classifier-delimiter">:</span> <span class="classifier">string, default ‘ms’ (milliseconds)</span></dt>
<dd>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</dd>
<dt>default_handler <span class="classifier-delimiter">:</span> <span class="classifier">callable, default None</span></dt>
<dd>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</dd>
<dt>lines <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</dd>
<dt>compression <span class="classifier-delimiter">:</span> <span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt>
<dd>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</dd>
<dt>index <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>nrows=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nrows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of rows to show.
If it is None, all rows are shown.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.unique">
<code class="descname">unique</code><span class="sig-paren">(</span><em>method='sort'</em>, <em>sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.
default=’sort’ will be changed to ‘hash’ when implemented.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.reshape.general.Series.valid_count">
<code class="descname">valid_count</code><a class="headerlink" href="#cudf.reshape.general.Series.valid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-null values</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.value_counts">
<code class="descname">value_counts</code><span class="sig-paren">(</span><em>method='sort'</em>, <em>sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.value_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.values_to_string">
<code class="descname">values_to_string</code><span class="sig-paren">(</span><em>nrows=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.values_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of string for each element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.reshape.general.Series.var">
<code class="descname">var</code><span class="sig-paren">(</span><em>ddof=1</em>, <em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.reshape.general.Series.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance of the series</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="groupby">
<h2>Groupby<a class="headerlink" href="#groupby" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.groupby.groupby.Groupby">
<em class="property">class </em><code class="descclassname">cudf.groupby.groupby.</code><code class="descname">Groupby</code><span class="sig-paren">(</span><em>df</em>, <em>by</em>, <em>method='hash'</em>, <em>as_index=True</em>, <em>level=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.groupby.Groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby object returned by cudf.DataFrame.groupby().</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.groupby.groupby.Groupby.agg" title="cudf.groupby.groupby.Groupby.agg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">agg</span></code></a>(args)</td>
<td>Invoke aggregation functions on the groups.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>copy</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>count</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>max</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>mean</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>min</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>sum</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.groupby.groupby.Groupby.agg">
<code class="descname">agg</code><span class="sig-paren">(</span><em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.groupby.Groupby.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke aggregation functions on the groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, list, str, callable</span></dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>str</dt>
<dd>The aggregate function name.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>list</dt>
<dd>List of <em>str</em> of the aggregate function.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dict</dt>
<dd>key-value pairs of source column name and list of
aggregate functions as <em>str</em>.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Since multi-indexes aren’t supported aggregation results are returned
in columns using the naming scheme of <cite>aggregation_columnname</cite>.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.apply">
<code class="descclassname">Groupby.</code><code class="descname">apply</code><span class="sig-paren">(</span><em>function</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation function over the grouped chunk.</p>
<p>This uses numba’s CUDA JIT compiler to convert the Python
transformation function into a CUDA kernel, thus will have a
compilation overhead during the first run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">The transformation function that will be executed on the CUDA GPU.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="c1"># Define a function to apply to each row in a group</span>
<span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
  <span class="n">df</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">df</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span>  <span class="n">out</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.apply_grouped">
<code class="descclassname">Groupby.</code><code class="descname">apply_grouped</code><span class="sig-paren">(</span><em>function</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.apply_grouped" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation function over the grouped chunk.</p>
<p>This uses numba’s CUDA JIT compiler to convert the Python
transformation function into a CUDA kernel, thus will have a
compilation overhead during the first run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt>
<dd><p class="first last">A list of names of input columns.</p>
</dd>
<dt><strong>outcols: list</strong></dt>
<dd><p class="first last">A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">name-value of extra arguments. These values are passed directly into
the function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="c1"># Define a function to apply to each group</span>
<span class="k">def</span> <span class="nf">mult_add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply_grouped</span><span class="p">(</span><span class="n">mult_add</span><span class="p">,</span>
                              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;val&#39;</span><span class="p">],</span>
                              <span class="n">outcols</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;out1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                                       <span class="s1">&#39;out2&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">},</span>
                              <span class="c1"># threads per block</span>
                              <span class="n">tpb</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span> <span class="n">out1</span> <span class="n">out2</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">3</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>    <span class="mi">4</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>    <span class="mi">6</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>    <span class="mi">7</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>    <span class="mi">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.as_df">
<code class="descclassname">Groupby.</code><code class="descname">as_df</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.as_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the intermediate dataframe after shuffling the rows into
groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>(df, segs)</strong> <span class="classifier-delimiter">:</span> <span class="classifier">namedtuple</span></dt>
<dd><ul class="first last simple">
<li>df : DataFrame</li>
<li><dl class="first docutils">
<dt>segs <span class="classifier-delimiter">:</span> <span class="classifier">Series</span></dt>
<dd>Beginning offsets of each group.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cudf&#39;</span><span class="p">)</span>

<span class="n">df_groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">as_df</span><span class="p">()</span>

<span class="c1"># DataFrame indexes of group starts</span>
<span class="k">print</span><span class="p">(</span><span class="n">df_groups</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># DataFrame itself</span>
<span class="k">print</span><span class="p">(</span><span class="n">df_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># DataFrame indexes of group starts</span>
<span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">2</span>
<span class="mi">2</span>    <span class="mi">4</span>

<span class="c1"># DataFrame itself</span>
   <span class="n">key</span>  <span class="n">val</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.std">
<code class="descclassname">Groupby.</code><code class="descname">std</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of each group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.var">
<code class="descclassname">Groupby.</code><code class="descname">var</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the var of each group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.groupby.legacy_groupby.Groupby.sum_of_squares">
<code class="descclassname">Groupby.</code><code class="descname">sum_of_squares</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.legacy_groupby.Groupby.sum_of_squares" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum_of_squares of each group</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-cudf.io.csv">
<span id="io"></span><h2>IO<a class="headerlink" href="#module-cudf.io.csv" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cudf.io.csv.read_csv">
<code class="descclassname">cudf.io.csv.</code><code class="descname">read_csv</code><span class="sig-paren">(</span><em>filepath_or_buffer</em>, <em>lineterminator='\n'</em>, <em>quotechar='&quot;'</em>, <em>quoting=0</em>, <em>doublequote=True</em>, <em>header='infer'</em>, <em>mangle_dupe_cols=True</em>, <em>usecols=None</em>, <em>sep='</em>, <em>'</em>, <em>delimiter=None</em>, <em>delim_whitespace=False</em>, <em>skipinitialspace=False</em>, <em>names=None</em>, <em>dtype=None</em>, <em>skipfooter=0</em>, <em>skiprows=0</em>, <em>dayfirst=False</em>, <em>compression='infer'</em>, <em>thousands=None</em>, <em>decimal='.'</em>, <em>true_values=None</em>, <em>false_values=None</em>, <em>nrows=None</em>, <em>byte_range=None</em>, <em>skip_blank_lines=True</em>, <em>comment=None</em>, <em>na_values=None</em>, <em>keep_default_na=True</em>, <em>na_filter=True</em>, <em>prefix=None</em>, <em>index_col=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.read_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Load and parse a CSV file into a DataFrame</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filepath_or_buffer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path of file to be read or a file-like object containing the file.</p>
</dd>
<dt><strong>sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default ‘,’</span></dt>
<dd><p class="first last">Delimiter to be used.</p>
</dd>
<dt><strong>delimiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default None</span></dt>
<dd><p class="first last">Alternative argument name for sep.</p>
</dd>
<dt><strong>delim_whitespace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Determines whether to use whitespace as delimiter.</p>
</dd>
<dt><strong>lineterminator</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default ‘\n’</span></dt>
<dd><p class="first last">Character to indicate end of line.</p>
</dd>
<dt><strong>skipinitialspace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Skip spaces after delimiter.</p>
</dd>
<dt><strong>names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str, default None</span></dt>
<dd><p class="first last">List of column names to be used.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str or dict of {col: dtype}, default None</span></dt>
<dd><p class="first last">List of data types in the same order of the column names
or a dictionary with column_name:dtype (pandas style).</p>
</dd>
<dt><strong>quotechar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default ‘”’</span></dt>
<dd><p class="first last">Character to indicate start and end of quote item.</p>
</dd>
<dt><strong>quoting</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or int, default 0</span></dt>
<dd><p class="first last">Controls quoting behavior. Set to one of
0 (csv.QUOTE_MINIMAL), 1 (csv.QUOTE_ALL),
2 (csv.QUOTE_NONNUMERIC) or 3 (csv.QUOTE_NONE).
Quoting is enabled with all values except 3.</p>
</dd>
<dt><strong>doublequote</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">When quoting is enabled, indicates whether to interpret two
consecutive quotechar inside fields as single quotechar</p>
</dd>
<dt><strong>header</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default ‘infer’</span></dt>
<dd><p class="first last">Row number to use as the column names. Default behavior is to infer
the column names: if no names are passed, header=0;
if column names are passed explicitly, header=None.</p>
</dd>
<dt><strong>usecols</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int or str, default None</span></dt>
<dd><p class="first last">Returns subset of the columns given in the list. All elements must be
either integer indices (column number) or strings that correspond to
column names</p>
</dd>
<dt><strong>mangle_dupe_cols</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default True</span></dt>
<dd><p class="first last">Duplicate columns will be specified as ‘X’,’X.1’,…’X.N’.</p>
</dd>
<dt><strong>skiprows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default 0</span></dt>
<dd><p class="first last">Number of rows to be skipped from the start of file.</p>
</dd>
<dt><strong>skipfooter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default 0</span></dt>
<dd><p class="first last">Number of rows to be skipped at the bottom of file.</p>
</dd>
<dt><strong>compression</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infer’, ‘gzip’, ‘zip’, None}, default ‘infer’</span></dt>
<dd><p class="first last">For on-the-fly decompression of on-disk data. If ‘infer’, then detect
compression from the following extensions: ‘.gz’,‘.zip’ (otherwise no
decompression). If using ‘zip’, the ZIP file must contain only one
data file to be read in, otherwise the first non-zero-sized file will
be used. Set to None for no decompression.</p>
</dd>
<dt><strong>decimal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default ‘.’</span></dt>
<dd><p class="first last">Character used as a decimal point.</p>
</dd>
<dt><strong>thousands</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default None</span></dt>
<dd><p class="first last">Character used as a thousands delimiter.</p>
</dd>
<dt><strong>true_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, default None</span></dt>
<dd><p class="first last">Values to consider as boolean True</p>
</dd>
<dt><strong>false_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, default None</span></dt>
<dd><p class="first last">Values to consider as boolean False</p>
</dd>
<dt><strong>nrows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default None</span></dt>
<dd><p class="first last">If specified, maximum number of rows to read</p>
</dd>
<dt><strong>byte_range</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or tuple, default None</span></dt>
<dd><p class="first last">Byte range within the input file to be read. The first number is the
offset in bytes, the second number is the range size in bytes. Set the
size to zero to read all data after the offset location. Reads the row
that starts before or at the end of the range, even if it ends after
the end of the range.</p>
</dd>
<dt><strong>skip_blank_lines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">If True, discard and do not parse empty lines
If False, interpret empty lines as NaN values</p>
</dd>
<dt><strong>comment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default None</span></dt>
<dd><p class="first last">Character used as a comments indicator. If found at the beginning of a
line, the line will be ignored altogether.</p>
</dd>
<dt><strong>na_values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, default None</span></dt>
<dd><p class="first last">Values to consider as invalid</p>
</dd>
<dt><strong>keep_default_na</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Whether or not to include the default NA values when parsing the data.</p>
</dd>
<dt><strong>na_filter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Detect missing values (empty strings and the values in na_values).
Passing False can improve performance.</p>
</dd>
<dt><strong>prefix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default None</span></dt>
<dd><p class="first last">Prefix to add to column numbers when parsing without a header row</p>
</dd>
<dt><strong>index_col</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or string, default None</span></dt>
<dd><p class="first last">Column to use as the row labels</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>GPU ``DataFrame`` object.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Create a test csv file</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foo.csv&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>  <span class="s2">&quot;num1,datetime,text&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;123,2018-11-13T12:00:00,abc&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;456,2018-11-14T12:35:01,def&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;789,2018-11-15T18:02:59,ghi&quot;</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Read the file with <code class="docutils literal notranslate"><span class="pre">cudf.read_csv</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.parquet"></span><dl class="function">
<dt id="cudf.io.parquet.read_parquet">
<code class="descclassname">cudf.io.parquet.</code><code class="descname">read_parquet</code><span class="sig-paren">(</span><em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.read_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a parquet object from the file path, returning a DataFrame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">File path</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, default=None</span></dt>
<dd><p class="first last">If not None, only these columns will be read from the file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a>, <a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.parquet.to_parquet">
<code class="descclassname">cudf.io.parquet.</code><code class="descname">to_parquet</code><span class="sig-paren">(</span><em>df</em>, <em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt>
<dd><p class="first last">Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default None</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional, default None</span></dt>
<dd><p class="first last">Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a>, <a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></p>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.orc"></span><dl class="function">
<dt id="cudf.io.orc.read_orc">
<code class="descclassname">cudf.io.orc.</code><code class="descname">read_orc</code><span class="sig-paren">(</span><em>path</em>, <em>columns=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.read_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an orc object from the file path, returning a DataFrame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">File path</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, default=None</span></dt>
<dd><p class="first last">If not None, only these columns will be read from the file.</p>
</dd>
<dt><strong>kwargs are passed to the engine</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a>, <a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_orc</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.json"></span><dl class="function">
<dt id="cudf.io.json.read_json">
<code class="descclassname">cudf.io.json.</code><code class="descname">read_json</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.read_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a JSON string to a cuDF object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>path_or_buf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a valid JSON string or file-like, default: None</span></dt>
<dd><p class="first last">The string could be a URL. Valid URL schemes include http, ftp, s3,
gcs, and file. For file URLs, a host is expected. For instance, a local
file could be <code class="docutils literal notranslate"><span class="pre">file://localhost/path/to/table.json</span></code></p>
</dd>
<dt><strong>orient</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string,</span></dt>
<dd><p class="first">Indication of expected JSON string format.
Compatible JSON strings can be produced by <code class="docutils literal notranslate"><span class="pre">to_json()</span></code> with a
corresponding orient value.
The set of possible orients is:
- <code class="docutils literal notranslate"><span class="pre">'split'</span></code> : dict like</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">[index],</span> <span class="pre">columns</span> <span class="pre">-&gt;</span> <span class="pre">[columns],</span> <span class="pre">data</span> <span class="pre">-&gt;</span> <span class="pre">[values]}</span></code></p>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'records'</span></code> : list like
<code class="docutils literal notranslate"><span class="pre">[{column</span> <span class="pre">-&gt;</span> <span class="pre">value},</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">'index'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">'columns'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">'values'</span></code> : just the values array</li>
</ul>
<p>The allowed and default values depend on the value
of the <cite>typ</cite> parameter.
* when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'series'</span></code>,</p>
<blockquote>
<div><ul class="simple">
<li>allowed orients are <code class="docutils literal notranslate"><span class="pre">{'split','records','index'}</span></code></li>
<li>default is <code class="docutils literal notranslate"><span class="pre">'index'</span></code></li>
<li>The Series index must be unique for orient <code class="docutils literal notranslate"><span class="pre">'index'</span></code>.</li>
</ul>
</div></blockquote>
<ul class="last">
<li><p class="first">when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'frame'</span></code>,
- allowed orients are <a href="#id4"><span class="problematic" id="id5">``</span></a>{‘split’,’records’,’index’,</p>
<blockquote>
<div><p>‘columns’,’values’, ‘table’}``</p>
</div></blockquote>
<ul class="simple">
<li>default is <code class="docutils literal notranslate"><span class="pre">'columns'</span></code></li>
<li>The DataFrame index must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>.</li>
<li>The DataFrame columns must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'records'</span></code>.</li>
</ul>
<blockquote>
<div><p>‘table’ as an allowed value for the <code class="docutils literal notranslate"><span class="pre">orient</span></code> argument</p>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>typ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type of object to recover (series or frame), default ‘frame’</span></dt>
<dd></dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean or dict, default True</span></dt>
<dd><p class="first last">If True, infer dtypes, if a dict of column to dtype, then use those,
if False, then don’t infer dtypes at all, applies only to the data.</p>
</dd>
<dt><strong>convert_axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default True</span></dt>
<dd><p class="first last">Try to convert the axes to the proper dtypes.</p>
</dd>
<dt><strong>convert_dates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default True</span></dt>
<dd><p class="first last">List of columns to parse for dates; If True, then try to parse
datelike columns default is True; a column label is datelike if
* it ends with <code class="docutils literal notranslate"><span class="pre">'_at'</span></code>,
* it ends with <code class="docutils literal notranslate"><span class="pre">'_time'</span></code>,
* it begins with <code class="docutils literal notranslate"><span class="pre">'timestamp'</span></code>,
* it is <code class="docutils literal notranslate"><span class="pre">'modified'</span></code>, or
* it is <code class="docutils literal notranslate"><span class="pre">'date'</span></code></p>
</dd>
<dt><strong>keep_default_dates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default True</span></dt>
<dd><p class="first last">If parsing dates, then parse the default datelike columns</p>
</dd>
<dt><strong>numpy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span></dt>
<dd><p class="first last">Direct decoding to numpy arrays. Supports numeric data only, but
non-numeric column and index labels are supported. Note also that the
JSON ordering MUST be the same for each term if numpy=True.</p>
</dd>
<dt><strong>precise_float</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span></dt>
<dd><p class="first last">Set to enable usage of higher precision (strtod) function when
decoding string to double values. Default (False) is to use fast but
less precise builtin functionality</p>
</dd>
<dt><strong>date_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, default None</span></dt>
<dd><p class="first last">The timestamp unit to detect if converting dates. The default behaviour
is to try and detect the correct precision, but if this is not desired
then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force parsing only seconds,
milliseconds, microseconds or nanoseconds respectively.</p>
</dd>
<dt><strong>encoding</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default is ‘utf-8’</span></dt>
<dd><p class="first last">The encoding to use to decode py3 bytes.</p>
</dd>
<dt><strong>lines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean, default False</span></dt>
<dd><p class="first last">Read the file as a json object per line.</p>
</dd>
<dt><strong>chunksize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer, default None</span></dt>
<dd><p class="first last">Return JsonReader object for iteration.
See the <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-jsonl">line-delimted json docs</a>
for more information on <code class="docutils literal notranslate"><span class="pre">chunksize</span></code>.
This can only be passed if <cite>lines=True</cite>.
If this is None, the file will be read into memory all at once.</p>
</dd>
<dt><strong>compression</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}, default ‘infer’</span></dt>
<dd><p class="first last">For on-the-fly decompression of on-disk data. If ‘infer’, then use
gzip, bz2, zip or xz if path_or_buf is a string ending in
‘.gz’, ‘.bz2’, ‘.zip’, or ‘xz’, respectively, and no decompression
otherwise. If using ‘zip’, the ZIP file must contain only one data
file to be read in. Set to None for no decompression.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series or DataFrame, depending on the value of <cite>typ</cite>.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.json.to_json" title="cudf.io.json.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.to_json</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.json.to_json">
<code class="descclassname">cudf.io.json.</code><code class="descname">to_json</code><span class="sig-paren">(</span><em>cudf_val</em>, <em>path_or_buf=None</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path_or_buf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or file handle, optional</span></dt>
<dd><p class="first last">File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Indication of expected JSON string format.
* Series</p>
<blockquote>
<div><ul class="simple">
<li>default is ‘index’</li>
<li>allowed values are: {‘split’,’records’,’index’,’table’}</li>
</ul>
</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>DataFrame</dt>
<dd><ul class="first simple">
<li>default is ‘columns’</li>
<li>allowed values are:</li>
</ul>
<p class="last">{‘split’,’records’,’index’,’columns’,’values’,’table’}</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The format of the JSON string</dt>
<dd><ul class="first simple">
<li>‘split’ : dict like {‘index’ -&gt; [index],</li>
</ul>
<p class="last">‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}
- ‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]
- ‘index’ : dict like {index -&gt; {column -&gt; value}}
- ‘columns’ : dict like {column -&gt; {index -&gt; value}}
- ‘values’ : just the values array
- ‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt>
<dd><p class="first last">Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default 10</span></dt>
<dd><p class="first last">The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, default ‘ms’ (milliseconds)</span></dt>
<dd><p class="first last">The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable, default None</span></dt>
<dd><p class="first last">Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serialisable object.</p>
</dd>
<dt><strong>lines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt>
<dd><p class="first last">A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
<dt><strong>See Also</strong></dt>
<dd></dd>
<dt><strong>——–</strong></dt>
<dd></dd>
<dt><strong>.cudf.io.json.read_json</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-cudf.io.feather"></span><dl class="function">
<dt id="cudf.io.feather.read_feather">
<code class="descclassname">cudf.io.feather.</code><code class="descname">read_feather</code><span class="sig-paren">(</span><em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.read_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an feather object from the file path, returning a DataFrame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">File path</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, default=None</span></dt>
<dd><p class="first last">If not None, only these columns will be read from the file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_feather</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.feather.to_feather">
<code class="descclassname">cudf.io.feather.</code><code class="descname">to_feather</code><span class="sig-paren">(</span><em>df</em>, <em>path</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">File path</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></p>
</div>
</dd></dl>

<span class="target" id="module-cudf.io.hdf"></span><dl class="function">
<dt id="cudf.io.hdf.read_hdf">
<code class="descclassname">cudf.io.hdf.</code><code class="descname">read_hdf</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.read_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the store, close it if we opened it.</p>
<p>Retrieve pandas object stored in file, optionally based on where
criteria</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>path_or_buf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string, buffer or path object</span></dt>
<dd><p class="first last">Path to the file to open, or an open <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">HDFStore</a>.
object.
Supports any object implementing the <code class="docutils literal notranslate"><span class="pre">__fspath__</span></code> protocol.
This includes <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> and py._path.local.LocalPath
objects.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object, optional</span></dt>
<dd><p class="first last">The group identifier in the store. Can be omitted if the HDF file
contains a single pandas object.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘r’, ‘r+’, ‘a’}, optional</span></dt>
<dd><p class="first last">Mode to use when opening the file. Ignored if path_or_buf is a
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">Pandas HDFS</a>.
Default is ‘r’.</p>
</dd>
<dt><strong>where</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">A list of Term (or convertible) objects.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Row number to start selection.</p>
</dd>
<dt><strong>stop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Row number to stop selection.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">A list of columns names to return.</p>
</dd>
<dt><strong>iterator</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Return an iterator object.</p>
</dd>
<dt><strong>chunksize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of rows to include in an iteration when using an iterator.</p>
</dd>
<dt><strong>errors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default ‘strict’</span></dt>
<dd><p class="first last">Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
<dt><strong>**kwargs</strong></dt>
<dd><p class="first last">Additional keyword arguments passed to HDFStore.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>item</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">The selected object. Return type depends on the object stored.</p>
</dd>
<dt><strong>See Also</strong></dt>
<dd></dd>
<dt><strong>——–</strong></dt>
<dd></dd>
<dt><strong>cudf.io.hdf.to_hdf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Write a HDF file from a DataFrame.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cudf.io.hdf.to_hdf">
<code class="descclassname">cudf.io.hdf.</code><code class="descname">to_hdf</code><span class="sig-paren">(</span><em>path_or_buf</em>, <em>key</em>, <em>value</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path_or_buf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or pandas.HDFStore</span></dt>
<dd><p class="first last">File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt>
<dd><p class="first">Mode to open file:</p>
<ul class="last simple">
<li>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</li>
<li>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</li>
<li>‘r+’: similar to ‘a’, but the file must already exist.</li>
</ul>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt>
<dd><p class="first">Possible values:</p>
<ul class="simple">
<li>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,</li>
</ul>
<p class="last">nor searchable.
- ‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p>
</dd>
<dt><strong>append</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of columns or True, optional</span></dt>
<dd><p class="first last">List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{0-9}, optional</span></dt>
<dd><p class="first last">Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt>
<dd><p class="first last">Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default ‘strict’</span></dt>
<dd><p class="first last">Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt>
<dd>Read from HDF file.</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt>
<dd>Write a DataFrame to the binary parquet format.</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather..to_feather</span></code></dt>
<dd>Write out feather-format for DataFrames.</dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="gpuarrowreader">
<h2>GpuArrowReader<a class="headerlink" href="#gpuarrowreader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.comm.gpuarrow.GpuArrowReader">
<em class="property">class </em><code class="descclassname">cudf.comm.gpuarrow.</code><code class="descname">GpuArrowReader</code><span class="sig-paren">(</span><em>schema_data</em>, <em>gpu_data</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="cudf.comm.gpuarrow.GpuArrowReader.to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code></a>()</td>
<td>Return a dictionary of Series object</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.comm.gpuarrow.GpuArrowReader.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of Series object</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="10min.html" class="btn btn-neutral float-right" title="10 Minutes to cuDF" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to cuDF’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>