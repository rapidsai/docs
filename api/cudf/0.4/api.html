

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API Reference &mdash; cudf 0.4.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Developer Documentation" href="developer.html" />
    <link rel="prev" title="Welcome to cuDF’s documentation!" href="index.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> cudf
          

          
          </a>

          
            
            
              <div class="version">
                0.4.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dataframe">DataFrame</a></li>
<li class="toctree-l2"><a class="reference internal" href="#series">Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#groupby">Groupby</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cudf.io.csv">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpuarrowreader">GpuArrowReader</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="developer.html">Developer Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="10min.html">10 Minutes to cuDF</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cudf</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="dataframe">
<h2>DataFrame<a class="headerlink" href="#dataframe" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.dataframe.DataFrame">
<em class="property">class </em><code class="descclassname">cudf.dataframe.</code><code class="descname">DataFrame</code><span class="sig-paren">(</span><em>name_series=None</em>, <em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>A GPU Dataframe object.</p>
<p class="rubric">Examples</p>
<p>Build dataframe with <cite>__setitem__</cite>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">key</span>  <span class="n">val</span>
<span class="mi">0</span>    <span class="mi">0</span> <span class="mf">10.0</span>
<span class="mi">1</span>    <span class="mi">1</span> <span class="mf">11.0</span>
<span class="mi">2</span>    <span class="mi">2</span> <span class="mf">12.0</span>
<span class="mi">3</span>    <span class="mi">3</span> <span class="mf">13.0</span>
<span class="mi">4</span>    <span class="mi">4</span> <span class="mf">14.0</span>
</pre></div>
</div>
<p>Build dataframe with initializer:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="kn">as</span> <span class="nn">dt</span>
<span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Create some datetime data</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-07 12:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
<span class="n">datetimes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t0</span><span class="o">+</span> <span class="n">dt</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">datetimes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>

<span class="c1"># Create the GPU DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">ids</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;datetimes&#39;</span><span class="p">,</span> <span class="n">dts</span><span class="p">)])</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="nb">id</span>               <span class="n">datetimes</span>
<span class="mi">0</span>    <span class="mi">0</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">07</span><span class="n">T12</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mf">00.000</span>
<span class="mi">1</span>    <span class="mi">1</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">07</span><span class="n">T12</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mf">01.000</span>
<span class="mi">2</span>    <span class="mi">2</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">07</span><span class="n">T12</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mf">02.000</span>
<span class="mi">3</span>    <span class="mi">3</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">07</span><span class="n">T12</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mf">03.000</span>
<span class="mi">4</span>    <span class="mi">4</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mo">07</span><span class="n">T12</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mf">04.000</span>
</pre></div>
</div>
<p>Convert from a Pandas DataFrame:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pygdf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]})</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>  <span class="n">a</span> <span class="n">b</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mf">0.1</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mf">0.2</span>
<span class="mi">2</span> <span class="mi">2</span> <span class="n">nan</span>
<span class="mi">3</span> <span class="mi">3</span> <span class="mf">0.3</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.columns" title="cudf.dataframe.DataFrame.columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">columns</span></code></a></dt>
<dd><p class="first last">Returns a tuple of columns</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.dtypes" title="cudf.dataframe.DataFrame.dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtypes</span></code></a></dt>
<dd><p class="first last">Return the dtypes in this object.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.index" title="cudf.dataframe.DataFrame.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt>
<dd><p class="first last">Returns the index of the DataFrame</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.loc" title="cudf.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt>
<dd><p class="first last">Returns a label-based indexer for row-slicing and column selection.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.DataFrame.shape" title="cudf.dataframe.DataFrame.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt>
<dd><p class="first last">Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.add_column" title="cudf.dataframe.DataFrame.add_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_column</span></code></a>(name,&nbsp;data[,&nbsp;forceindex])</td>
<td>Add a column</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_chunks" title="cudf.dataframe.DataFrame.apply_chunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_chunks</span></code></a>(func,&nbsp;incols,&nbsp;outcols[,&nbsp;…])</td>
<td>Transform user-specified chunks using the user-provided function.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_rows" title="cudf.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_rows</span></code></a>(func,&nbsp;incols,&nbsp;outcols,&nbsp;kwargs[,&nbsp;…])</td>
<td>Apply a row-wise user defined function.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.as_gpu_matrix" title="cudf.dataframe.DataFrame.as_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_gpu_matrix</span></code></a>([columns,&nbsp;order])</td>
<td>Convert to a matrix in device memory.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.as_matrix" title="cudf.dataframe.DataFrame.as_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_matrix</span></code></a>([columns])</td>
<td>Convert to a matrix in host memory.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.assign" title="cudf.dataframe.DataFrame.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code></a>(**kwargs)</td>
<td>Assign columns to DataFrame from keyword arguments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.copy" title="cudf.dataframe.DataFrame.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Returns a copy of this dataframe</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.drop_column" title="cudf.dataframe.DataFrame.drop_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_column</span></code></a>(name)</td>
<td>Drop a column by <em>name</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.from_arrow" title="cudf.dataframe.DataFrame.from_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_arrow</span></code></a>(table)</td>
<td>Convert from a PyArrow Table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.from_pandas" title="cudf.dataframe.DataFrame.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(dataframe[,&nbsp;nan_as_null])</td>
<td>Convert from a Pandas DataFrame.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.from_records" title="cudf.dataframe.DataFrame.from_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_records</span></code></a>(data[,&nbsp;index,&nbsp;columns,&nbsp;nan_as_null])</td>
<td>Convert from a numpy recarray or structured array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.groupby" title="cudf.dataframe.DataFrame.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a>(by[,&nbsp;sort,&nbsp;as_index,&nbsp;method])</td>
<td>Groupby</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.hash_columns" title="cudf.dataframe.DataFrame.hash_columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_columns</span></code></a>([columns])</td>
<td>Hash the given <em>columns</em> and return a new Series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.head" title="cudf.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">head</span></code></a>([n])</td>
<td>Returns the first n rows as a new DataFrame</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.join" title="cudf.dataframe.DataFrame.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(other[,&nbsp;on,&nbsp;how,&nbsp;lsuffix,&nbsp;rsuffix,&nbsp;…])</td>
<td>Join columns with other DataFrame on index or on a key column.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.label_encoding" title="cudf.dataframe.DataFrame.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(column,&nbsp;prefix,&nbsp;cats[,&nbsp;…])</td>
<td>Encode labels in a column with label encoding.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.merge" title="cudf.dataframe.DataFrame.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code></a>(other[,&nbsp;on,&nbsp;how,&nbsp;lsuffix,&nbsp;rsuffix,&nbsp;…])</td>
<td>Merge GPU DataFrame objects by performing a database-style join operation by columns or indexes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.nlargest" title="cudf.dataframe.DataFrame.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(n,&nbsp;columns[,&nbsp;keep])</td>
<td>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.nsmallest" title="cudf.dataframe.DataFrame.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(n,&nbsp;columns[,&nbsp;keep])</td>
<td>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.one_hot_encoding" title="cudf.dataframe.DataFrame.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(column,&nbsp;prefix,&nbsp;cats[,&nbsp;…])</td>
<td>Expand a column with one-hot-encoding.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.partition_by_hash" title="cudf.dataframe.DataFrame.partition_by_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_by_hash</span></code></a>(columns,&nbsp;nparts)</td>
<td>Partition the dataframe by the hashed value of data in <em>columns</em>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.quantile" title="cudf.dataframe.DataFrame.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(q[,&nbsp;interpolation,&nbsp;exact])</td>
<td>Return values at the given quantile.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.query" title="cudf.dataframe.DataFrame.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query</span></code></a>(expr)</td>
<td>Query with a boolean expression using Numba to compile a GPU kernel.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.set_index" title="cudf.dataframe.DataFrame.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(index)</td>
<td>Return a new DataFrame with a new index</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.sort_index" title="cudf.dataframe.DataFrame.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>([ascending])</td>
<td>Sort by the index</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.sort_values" title="cudf.dataframe.DataFrame.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(by[,&nbsp;ascending])</td>
<td>Uses parallel radixsort, which is a stable sort.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_arrow" title="cudf.dataframe.DataFrame.to_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_arrow</span></code></a>([index])</td>
<td>Convert to a PyArrow Table.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_pandas" title="cudf.dataframe.DataFrame.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>()</td>
<td>Convert to a Pandas DataFrame.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_records" title="cudf.dataframe.DataFrame.to_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_records</span></code></a>([index])</td>
<td>Convert to a numpy recarray</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.DataFrame.to_string" title="cudf.dataframe.DataFrame.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>([nrows,&nbsp;ncols])</td>
<td>Convert to string</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="60%" />
<col width="40%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>deserialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>reset_index</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>serialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>take</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.dataframe.DataFrame.add_column">
<code class="descname">add_column</code><span class="sig-paren">(</span><em>name</em>, <em>data</em>, <em>forceindex=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.add_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of column to be added.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series, array-like</span></dt>
<dd><p class="first last">Values to be added.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.apply_chunks">
<code class="descname">apply_chunks</code><span class="sig-paren">(</span><em>func</em>, <em>incols</em>, <em>outcols</em>, <em>kwargs={}</em>, <em>chunks=None</em>, <em>tpb=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.apply_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform user-specified chunks using the user-provided function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt>
<dd><p class="first last">A list of names of input columns.</p>
</dd>
<dt><strong>outcols: dict</strong></dt>
<dd><p class="first last">A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt>
<dd><p class="first last">name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
<dt><strong>chunks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or Series-like</span></dt>
<dd><p class="first last">If it is an <code class="docutils literal notranslate"><span class="pre">int</span></code>, it is the chunksize.
If it is an array, it contains integer offset for the start of
each chunk.  The span of a chunk for chunk i-th is
<code class="docutils literal notranslate"><span class="pre">data[chunks[i]</span> <span class="pre">:</span> <span class="pre">chunks[i</span> <span class="pre">+</span> <span class="pre">1]]</span></code> for any
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">chunks.size</span></code>; or, <code class="docutils literal notranslate"><span class="pre">data[chunks[i]:]</span></code> for the
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">len(chunks)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>tpb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int; optional</span></dt>
<dd><p class="first last">It is the thread-per-block for the underlying kernel.
The default uses 1 thread to emulate serial execution for
each chunk.  It is a good starting point but inefficient.
Its maximum possible value is limited by the available CUDA GPU
resources.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.dataframe.DataFrame.apply_rows" title="cudf.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_rows</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<p>For <code class="docutils literal notranslate"><span class="pre">tpb</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">func</span></code> is executed by <code class="docutils literal notranslate"><span class="pre">tpb</span></code> number of threads
concurrently.  To access the thread id and count,
use <code class="docutils literal notranslate"><span class="pre">numba.cuda.threadIdx.x</span></code> and <code class="docutils literal notranslate"><span class="pre">numba.cuda.blockDim.x</span></code>,
respectively (See <a class="reference external" href="http://numba.pydata.org/numba-doc/latest/cuda/kernels.html">numba CUDA kernel documentation</a>).</p>
<p>In the example below, the <em>kernel</em> is invoked concurrently on each
specified chunk. The <em>kernel</em> computes the corresponding output
for the chunk.</p>
<p>By looping over the range
<code class="docutils literal notranslate"><span class="pre">range(cuda.threadIdx.x,</span> <span class="pre">in1.size,</span> <span class="pre">cuda.blockDim.x)</span></code>, the <em>kernel</em>
function can be used with any <em>tpb</em> in a efficient manner.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">):</span>
     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
         <span class="n">x</span> <span class="o">=</span> <span class="n">in1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
         <span class="n">y</span> <span class="o">=</span> <span class="n">in2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
         <span class="n">z</span> <span class="o">=</span> <span class="n">in3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
         <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.apply_rows">
<code class="descname">apply_rows</code><span class="sig-paren">(</span><em>func</em>, <em>incols</em>, <em>outcols</em>, <em>kwargs</em>, <em>cache_key=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.apply_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a row-wise user defined function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt>
<dd><p class="first last">A list of names of input columns.</p>
</dd>
<dt><strong>outcols: dict</strong></dt>
<dd><p class="first last">A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt>
<dd><p class="first last">name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>The user function should loop over the columns and set the output for
each row. Loop execution order is arbitrary, so each iteration of
the loop <strong>MUST</strong> be independent of each other.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">func</span></code> is invoked, the array args corresponding to the
input/output are strided so as to improve GPU parallelism.
The loop in the function resembles serial code, but executes
concurrently in multiple threads.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">nelem</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>

<span class="c1"># Define input columns for the kernel</span>
<span class="n">in1</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">]</span>
<span class="n">in2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in2&#39;</span><span class="p">]</span>
<span class="n">in3</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;in3&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">,</span> <span class="n">kwarg1</span><span class="p">,</span> <span class="n">kwarg2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">)):</span>
       <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwarg2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">y</span>
       <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">z</span>
</pre></div>
</div>
<p>Call <code class="docutils literal notranslate"><span class="pre">.apply_rows</span></code> with the name of the input columns, the name and
dtype of the output columns, and, optionally, a dict of extra
arguments.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span><span class="o">.</span><span class="n">apply_rows</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;in1&#39;</span><span class="p">,</span> <span class="s1">&#39;in2&#39;</span><span class="p">,</span> <span class="s1">&#39;in3&#39;</span><span class="p">],</span>
              <span class="n">outcols</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">out2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
              <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwarg1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">kwarg2</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">in1</span>  <span class="n">in2</span>  <span class="n">in3</span> <span class="n">out1</span> <span class="n">out2</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>
<span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">1</span>  <span class="mf">1.0</span> <span class="o">-</span><span class="mf">2.0</span>
<span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">2</span>  <span class="mf">2.0</span> <span class="o">-</span><span class="mf">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.as_gpu_matrix">
<code class="descname">as_gpu_matrix</code><span class="sig-paren">(</span><em>columns=None</em>, <em>order='F'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.as_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in device memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str</span></dt>
<dd><p class="first last">List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘F’ or ‘C’</span></dt>
<dd><p class="first last">Optional argument to determine whether to return a column major
(Fortran) matrix or a row major (C) matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A (nrow x ncol) numpy ndarray in “F” order.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.as_matrix">
<code class="descname">as_matrix</code><span class="sig-paren">(</span><em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.as_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in host memory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str</span></dt>
<dd><p class="first last">List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A (nrow x ncol) numpy ndarray in “F” order.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign columns to DataFrame from keyword arguments.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>     <span class="n">a</span>    <span class="n">b</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">3</span>
<span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">4</span>
<span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.columns">
<code class="descname">columns</code><a class="headerlink" href="#cudf.dataframe.DataFrame.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of columns</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this dataframe</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.drop_column">
<code class="descname">drop_column</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.drop_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop a column by <em>name</em></p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.dtypes">
<code class="descname">dtypes</code><a class="headerlink" href="#cudf.dataframe.DataFrame.dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dtypes in this object.</p>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_arrow">
<em class="property">classmethod </em><code class="descname">from_arrow</code><span class="sig-paren">(</span><em>table</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a PyArrow Table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError for invalid input type.</strong></dt>
<dd></dd>
<dt><strong>**Notes**</strong></dt>
<dd></dd>
<dt><strong>Does not support automatically setting index column(s) similar to how</strong></dt>
<dd></dd>
<dt><strong>``to_pandas`` works for PyArrow Tables.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyarrow</span> <span class="kn">as</span> <span class="nn">pa</span>
<span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="n">batch</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">,</span> <span class="s1">&#39;f1&#39;</span><span class="p">])</span>
<span class="n">table</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_batches</span><span class="p">([</span><span class="n">batch</span><span class="p">])</span>
<span class="n">DataFrame</span><span class="o">.</span><span class="n">from_arrow</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">3</span> <span class="o">&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_pandas">
<em class="property">classmethod </em><code class="descname">from_pandas</code><span class="sig-paren">(</span><em>dataframe</em>, <em>nan_as_null=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a Pandas DataFrame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError for invalid input type.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">cudf</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">3</span> <span class="o">&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.DataFrame.from_records">
<em class="property">classmethod </em><code class="descname">from_records</code><span class="sig-paren">(</span><em>data</em>, <em>index=None</em>, <em>columns=None</em>, <em>nan_as_null=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.from_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numpy recarray or structured array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy structured dtype or recarray</span></dt>
<dd></dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of column names to include.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.groupby">
<code class="descname">groupby</code><span class="sig-paren">(</span><em>by</em>, <em>sort=False</em>, <em>as_index=False</em>, <em>method='sort'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list-of-str or str</span></dt>
<dd><p class="first last">Column name(s) to form that groups by.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Force sorting group keys.
Depends on the underlying algorithm.</p>
</dd>
<dt><strong>as_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool; defaults to False</span></dt>
<dd><p class="first last">Must be False.  Provided to be API compatible with pandas.
The keys are always left as regular columns in the result.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">A string indicating the method to use to perform the group by.
Valid values are “sort”, “hash”, or “cudf”.
“cudf” method may be deprecated in the future, but is currently
the only method supporting group UDFs via the <cite>apply</cite> function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>The groupby object</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Unlike pandas, this groupby operation behaves like a SQL groupby.
No empty rows are returned.  (For categorical keys, pandas returns
rows for all categories even if they are no corresponding values.)</p>
<p>Only a minimal number of operations is implemented so far.</p>
<ul class="simple">
<li>Only <em>by</em> argument is supported.</li>
<li>Since we don’t support multiindex, the <em>by</em> columns are stored
as regular columns.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.hash_columns">
<code class="descname">hash_columns</code><span class="sig-paren">(</span><em>columns=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.hash_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the given <em>columns</em> and return a new Series</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>column</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str; optional</span></dt>
<dd><p class="first last">Sequence of column names. If columns is <em>None</em> (unspecified),
all columns in the frame are used.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.head">
<code class="descname">head</code><span class="sig-paren">(</span><em>n=5</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Output</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">key</span>  <span class="n">val</span>
<span class="mi">0</span>    <span class="mi">0</span> <span class="mf">10.0</span>
<span class="mi">1</span>    <span class="mi">1</span> <span class="mf">11.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.index">
<code class="descname">index</code><a class="headerlink" href="#cudf.dataframe.DataFrame.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the DataFrame</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.join">
<code class="descname">join</code><span class="sig-paren">(</span><em>other</em>, <em>on=None</em>, <em>how='left'</em>, <em>lsuffix=''</em>, <em>rsuffix=''</em>, <em>sort=False</em>, <em>type=''</em>, <em>method='hash'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join columns with other DataFrame on index or on a key column.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
<dt><strong>how</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Only accepts “left”, “right”, “inner”, “outer”</p>
</dd>
<dt><strong>lsuffix, rsuffix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The suffices to add to the left (<em>lsuffix</em>) and right (<em>rsuffix</em>)
column names when avoiding conflicts.</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set to True to ensure sorted ordering.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>joined</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Difference from pandas:</p>
<ul class="simple">
<li><em>other</em> must be a single DataFrame for now.</li>
<li><em>on</em> is not supported yet due to lack of multi-index support.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.label_encoding">
<code class="descname">label_encoding</code><span class="sig-paren">(</span><em>column</em>, <em>prefix</em>, <em>cats</em>, <em>prefix_sep='_'</em>, <em>dtype=None</em>, <em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode labels in a column with label encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>column</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the new column name prefix.</p>
</dd>
<dt><strong>cats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ints</span></dt>
<dd><p class="first last">the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt>
<dd><p class="first last">the dtype for the outputs; see Series.label_encoding</p>
</dd>
<dt><strong>na_sentinel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd><p class="first last">Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>a new dataframe with a new column append for the coded values.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.loc">
<code class="descname">loc</code><a class="headerlink" href="#cudf.dataframe.DataFrame.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a label-based indexer for row-slicing and column selection.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">))),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)))])</span>
<span class="go"># get rows from index 2 to index 5 from &#39;a&#39; and &#39;b&#39; columns.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]]</span>
<span class="go">     a    b</span>
<span class="go">2    2    2</span>
<span class="go">3    3    3</span>
<span class="go">4    4    4</span>
<span class="go">5    5    5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.merge">
<code class="descname">merge</code><span class="sig-paren">(</span><em>other</em>, <em>on=None</em>, <em>how='left'</em>, <em>lsuffix='_x'</em>, <em>rsuffix='_y'</em>, <em>type=''</em>, <em>method='hash'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge GPU DataFrame objects by performing a database-style join operation
by columns or indexes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
<dt><strong>on</strong> <span class="classifier-delimiter">:</span> <span class="classifier">label or list; defaults to None</span></dt>
<dd><p class="first">Column or index level names to join on. These must be found in
both DataFrames.</p>
<p class="last">If on is None and not merging on indexes then
this defaults to the intersection of the columns
in both DataFrames.</p>
</dd>
<dt><strong>how</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to ‘left’</span></dt>
<dd><p class="first last">Only accepts ‘left’
left: use only keys from left frame, similar to
a SQL left outer join; preserve key order</p>
</dd>
<dt><strong>lsuffix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to ‘_x’</span></dt>
<dd><p class="first last">Suffix applied to overlapping column names on the left side</p>
</dd>
<dt><strong>rsuffix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to ‘_y’</span></dt>
<dd><p class="first last">Suffix applied to overlapping column names on the right side</p>
</dd>
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, defaults to ‘hash’</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>merged</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="n">df_a</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;vals_a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>

<span class="n">df_b</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">df_b</span><span class="p">[</span><span class="s1">&#39;vals_b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">df_merged</span> <span class="o">=</span> <span class="n">df_a</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_b</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">df_merged</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">key</span>  <span class="n">val</span> <span class="n">vals_b</span>
<span class="mi">3</span>    <span class="mi">0</span> <span class="mf">10.0</span>
<span class="mi">0</span>    <span class="mi">1</span> <span class="mf">11.0</span>   <span class="mf">10.0</span>
<span class="mi">1</span>    <span class="mi">2</span> <span class="mf">12.0</span>   <span class="mf">11.0</span>
<span class="mi">4</span>    <span class="mi">3</span> <span class="mf">13.0</span>
<span class="mi">2</span>    <span class="mi">4</span> <span class="mf">14.0</span>   <span class="mf">12.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.nlargest">
<code class="descname">nlargest</code><span class="sig-paren">(</span><em>n</em>, <em>columns</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.nsmallest">
<code class="descname">nsmallest</code><span class="sig-paren">(</span><em>n</em>, <em>columns</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p>
<p>Difference from pandas:
* Only a single column is supported in <em>columns</em></p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.one_hot_encoding">
<code class="descname">one_hot_encoding</code><span class="sig-paren">(</span><em>column</em>, <em>prefix</em>, <em>cats</em>, <em>prefix_sep='_'</em>, <em>dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a column with one-hot-encoding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>column</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the new column name prefix.</p>
</dd>
<dt><strong>cats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ints</span></dt>
<dd><p class="first last">the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt>
<dd><p class="first last">the dtype for the outputs; defaults to float64.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a new dataframe with new columns append for each category.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span> <span class="k">as</span> <span class="n">gdf</span>

<span class="n">pet_owner</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">pet_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;dog&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">,</span> <span class="s1">&#39;bird&#39;</span><span class="p">,</span> <span class="s1">&#39;fish&#39;</span><span class="p">]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;pet_owner&#39;</span><span class="p">:</span> <span class="n">pet_owner</span><span class="p">,</span> <span class="s1">&#39;pet_type&#39;</span><span class="p">:</span> <span class="n">pet_type</span><span class="p">})</span>
<span class="n">df</span><span class="o">.</span><span class="n">pet_type</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>

<span class="c1"># Create a column with numerically encoded category values</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
<span class="n">my_gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Create the list of category codes to use in the encoding</span>
<span class="n">codes</span> <span class="o">=</span> <span class="n">my_gdf</span><span class="o">.</span><span class="n">pet_codes</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="n">enc_gdf</span> <span class="o">=</span> <span class="n">my_gdf</span><span class="o">.</span><span class="n">one_hot_encoding</span><span class="p">(</span><span class="s1">&#39;pet_codes&#39;</span><span class="p">,</span> <span class="s1">&#39;pet_dummy&#39;</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
<span class="n">enc_gdf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pet_owner</span> <span class="n">pet_type</span> <span class="n">pet_codes</span> <span class="n">pet_dummy_0</span> <span class="n">pet_dummy_1</span> <span class="n">pet_dummy_2</span>
<span class="mi">0</span>         <span class="mi">1</span>     <span class="n">fish</span>         <span class="mi">2</span>         <span class="mf">0.0</span>         <span class="mf">0.0</span>         <span class="mf">1.0</span>
<span class="mi">1</span>         <span class="mi">2</span>      <span class="n">dog</span>         <span class="mi">1</span>         <span class="mf">0.0</span>         <span class="mf">1.0</span>         <span class="mf">0.0</span>
<span class="mi">2</span>         <span class="mi">3</span>     <span class="n">fish</span>         <span class="mi">2</span>         <span class="mf">0.0</span>         <span class="mf">0.0</span>         <span class="mf">1.0</span>
<span class="mi">3</span>         <span class="mi">4</span>     <span class="n">bird</span>         <span class="mi">0</span>         <span class="mf">1.0</span>         <span class="mf">0.0</span>         <span class="mf">0.0</span>
<span class="mi">4</span>         <span class="mi">5</span>     <span class="n">fish</span>         <span class="mi">2</span>         <span class="mf">0.0</span>         <span class="mf">0.0</span>         <span class="mf">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.partition_by_hash">
<code class="descname">partition_by_hash</code><span class="sig-paren">(</span><em>columns</em>, <em>nparts</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.partition_by_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str</span></dt>
<dd><p class="first last">The names of the columns to be hashed.
Must have at least one name.</p>
</dd>
<dt><strong>nparts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of output partitions</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>partitioned: list of DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>q</em>, <em>interpolation='linear'</em>, <em>exact=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array-like</span></dt>
<dd><p class="first last">0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{<cite>linear</cite>, <cite>lower</cite>, <cite>higher</cite>, <cite>midpoint</cite>, <cite>nearest</cite>}</span></dt>
<dd><p class="first last">This  parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j.
Default ‘linear’.</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of column names to include.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether to use approximate or exact quantile algorithm.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.query">
<code class="descname">query</code><span class="sig-paren">(</span><em>expr</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Query with a boolean expression using Numba to compile a GPU kernel.</p>
<p>See pandas.DataFrame.query.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>expr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">A boolean expression. Names in expression refer to columns.</p>
<p class="last">Names starting with <cite>&#64;</cite> refer to Python variables</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filtered</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="n">expr</span> <span class="o">=</span> <span class="s2">&quot;(a == 2 and b == 4) or (b == 3)&quot;</span>
<span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>     <span class="n">a</span>    <span class="n">b</span>
<span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">3</span>
<span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">4</span>
</pre></div>
</div>
<p>DateTime conditionals:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;2018-10-07&#39;</span><span class="p">,</span> <span class="s1">&#39;2018-10-08&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetimes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="n">search_date</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;2018-10-08&#39;</span><span class="p">,</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;datetimes==@search_date&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>                <span class="n">datetimes</span>
<span class="mi">1</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">08</span><span class="n">T00</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mf">00.000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.set_index">
<code class="descname">set_index</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame with a new index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index, Series-convertible, or str</span></dt>
<dd><p class="first last">Index : the new index.
Series-convertible : values for the new index.
str : name of column to be used as series</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.DataFrame.shape">
<code class="descname">shape</code><a class="headerlink" href="#cudf.dataframe.DataFrame.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.sort_index">
<code class="descname">sort_index</code><span class="sig-paren">(</span><em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.sort_values">
<code class="descname">sort_values</code><span class="sig-paren">(</span><em>by</em>, <em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses parallel radixsort, which is a stable sort.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of Series to sort by</p>
</dd>
<dt><strong>ascending</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">Sort ascending vs. descending.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>sorted_obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">cuDF DataFrame</span></dt>
<dd></dd>
<dt><strong>Difference from pandas:</strong></dt>
<dd><ul class="first last simple">
<li><em>by</em> must be the name of a single column.</li>
<li>Support axis=’index’ only.          by : str</li>
<li>Not supporting: inplace, kind, na_position</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>     <span class="n">a</span>    <span class="n">b</span>
<span class="mi">0</span>    <span class="mi">0</span>   <span class="o">-</span><span class="mi">3</span>
<span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">1</span>    <span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_arrow">
<code class="descname">to_arrow</code><span class="sig-paren">(</span><em>index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a PyArrow Table.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">pyarrow</span><span class="o">.</span><span class="n">Table</span>
<span class="bp">None</span><span class="p">:</span> <span class="n">int64</span>
<span class="n">a</span><span class="p">:</span> <span class="n">int64</span>
<span class="n">b</span><span class="p">:</span> <span class="n">int64</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_pandas">
<code class="descname">to_pandas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas DataFrame.</p>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="nb">type</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_records">
<code class="descname">to_records</code><span class="sig-paren">(</span><em>index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numpy recarray</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to include the index in the output.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>numpy recarray</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.DataFrame.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>nrows=NOTSET</em>, <em>ncols=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.DataFrame.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nrows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of rows to show.
If it is None, all rows are shown.</p>
</dd>
<dt><strong>ncols</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of columns to show.
If it is None, all columns are shown.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf.dataframe</span> <span class="kn">import</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">&#39;val&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;   key  val</span><span class="se">\n</span><span class="s1">0    0 10.0</span><span class="se">\n</span><span class="s1">1    1 11.0</span><span class="se">\n</span><span class="s1">2    2 12.0&#39;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<span class="target" id="module-cudf.multi"></span><dl class="function">
<dt id="cudf.multi.concat">
<code class="descclassname">cudf.multi.</code><code class="descname">concat</code><span class="sig-paren">(</span><em>objs</em>, <em>ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.multi.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate DataFrames, Series, or Indices row-wise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>objs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of DataFrame, Series, or Index</span></dt>
<dd></dd>
<dt><strong>ignore_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set True to ignore the index of the <em>objs</em> and provide a
default range index instead.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A new object of like type with rows from each object in ``objs``.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.dataframe.Series">
<em class="property">class </em><code class="descclassname">cudf.dataframe.</code><code class="descname">Series</code><span class="sig-paren">(</span><em>data</em>, <em>index=None</em>, <em>name=None</em>, <em>nan_as_null=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series" title="Permalink to this definition">¶</a></dt>
<dd><p>Data and null-masks.</p>
<p><code class="docutils literal notranslate"><span class="pre">Series</span></code> objects are used as columns of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cat</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.data" title="cudf.dataframe.Series.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a></dt>
<dd><p class="first last">The gpu buffer for the data</p>
</dd>
<dt><strong>dt</strong></dt>
<dd></dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.dtype" title="cudf.dataframe.Series.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt>
<dd><p class="first last">dtype of the Series</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.has_null_mask" title="cudf.dataframe.Series.has_null_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_null_mask</span></code></a></dt>
<dd><p class="first last">A boolean indicating whether a null-mask is needed</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.index" title="cudf.dataframe.Series.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt>
<dd><p class="first last">The index object</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.null_count" title="cudf.dataframe.Series.null_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">null_count</span></code></a></dt>
<dd><p class="first last">Number of null values</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.nullmask" title="cudf.dataframe.Series.nullmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nullmask</span></code></a></dt>
<dd><p class="first last">The gpu buffer for the null-mask</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.shape" title="cudf.dataframe.Series.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt>
<dd><p class="first last">Returns a tuple representing the dimensionality of the Series.</p>
</dd>
<dt><a class="reference internal" href="#cudf.dataframe.Series.valid_count" title="cudf.dataframe.Series.valid_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">valid_count</span></code></a></dt>
<dd><p class="first last">Number of non-null values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.append" title="cudf.dataframe.Series.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(arbitrary)</td>
<td>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.applymap" title="cudf.dataframe.Series.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">applymap</span></code></a>(udf[,&nbsp;out_dtype])</td>
<td>Apply a elemenwise function to transform the values in the Column.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.argsort" title="cudf.dataframe.Series.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>([ascending])</td>
<td>Returns a Series of int64 index that will sort the series.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.as_mask" title="cudf.dataframe.Series.as_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_mask</span></code></a>()</td>
<td>Convert booleans to bitmask</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.astype" title="cudf.dataframe.Series.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(dtype)</td>
<td>Convert to the given <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.ceil" title="cudf.dataframe.Series.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>()</td>
<td>Rounds each value upward to the smallest integral value not less than the original.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.count" title="cudf.dataframe.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>([axis,&nbsp;skipna])</td>
<td>The number of non-null values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.factorize" title="cudf.dataframe.Series.factorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorize</span></code></a>([na_sentinel])</td>
<td>Encode the input values as integer labels</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.fillna" title="cudf.dataframe.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(value)</td>
<td>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.find_first_value" title="cudf.dataframe.Series.find_first_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_first_value</span></code></a>(value)</td>
<td>Returns offset of first value that matches</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.find_last_value" title="cudf.dataframe.Series.find_last_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_last_value</span></code></a>(value)</td>
<td>Returns offset of last value that matches</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.floor" title="cudf.dataframe.Series.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>()</td>
<td>Rounds each value downward to the largest integral value not greater than the original.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.from_categorical" title="cudf.dataframe.Series.from_categorical"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_categorical</span></code></a>(categorical[,&nbsp;codes])</td>
<td>Creates from a pandas.Categorical</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.from_masked_array" title="cudf.dataframe.Series.from_masked_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_masked_array</span></code></a>(data,&nbsp;mask[,&nbsp;null_count])</td>
<td>Create a Series with null-mask.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.hash_values" title="cudf.dataframe.Series.hash_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_values</span></code></a>()</td>
<td>Compute the hash of values in this column.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.label_encoding" title="cudf.dataframe.Series.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(cats[,&nbsp;dtype,&nbsp;na_sentinel])</td>
<td>Perform label encoding</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.max" title="cudf.dataframe.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the max of the series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.mean" title="cudf.dataframe.Series.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the mean of the series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.mean_var" title="cudf.dataframe.Series.mean_var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_var</span></code></a>([ddof])</td>
<td>Compute mean and variance at the same time.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.min" title="cudf.dataframe.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the min of the series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.nlargest" title="cudf.dataframe.Series.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>([n,&nbsp;keep])</td>
<td>Returns a new Series of the <em>n</em> largest element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.nsmallest" title="cudf.dataframe.Series.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>([n,&nbsp;keep])</td>
<td>Returns a new Series of the <em>n</em> smallest element.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.one_hot_encoding" title="cudf.dataframe.Series.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(cats[,&nbsp;dtype])</td>
<td>Perform one-hot-encoding</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.quantile" title="cudf.dataframe.Series.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(q[,&nbsp;interpolation,&nbsp;exact,&nbsp;quant_index])</td>
<td>Return values at the given quantile.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.reset_index" title="cudf.dataframe.Series.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_index</span></code></a>()</td>
<td>Reset index to RangeIndex</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.reverse" title="cudf.dataframe.Series.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>()</td>
<td>Reverse the Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.scale" title="cudf.dataframe.Series.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a>()</td>
<td>Scale values to [0, 1] in float64</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.set_index" title="cudf.dataframe.Series.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(index)</td>
<td>Returns a new Series with a different index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.set_mask" title="cudf.dataframe.Series.set_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_mask</span></code></a>(mask[,&nbsp;null_count])</td>
<td>Create new Series by setting a mask array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.sort_index" title="cudf.dataframe.Series.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>([ascending])</td>
<td>Sort by the index.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.sort_values" title="cudf.dataframe.Series.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>([ascending])</td>
<td>Sort by values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.std" title="cudf.dataframe.Series.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>([ddof,&nbsp;axis,&nbsp;skipna])</td>
<td>Compute the standard deviation of the series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.sum" title="cudf.dataframe.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>([axis,&nbsp;skipna])</td>
<td>Compute the sum of the series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.take" title="cudf.dataframe.Series.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(indices[,&nbsp;ignore_index])</td>
<td>Return Series by taking values from the corresponding <em>indices</em>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.to_array" title="cudf.dataframe.Series.to_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_array</span></code></a>([fillna])</td>
<td>Get a dense numpy array for the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.to_gpu_array" title="cudf.dataframe.Series.to_gpu_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_array</span></code></a>([fillna])</td>
<td>Get a dense numba device array for the data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.to_string" title="cudf.dataframe.Series.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>([nrows])</td>
<td>Convert to string</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.unique" title="cudf.dataframe.Series.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>([method,&nbsp;sort])</td>
<td>Returns unique values of this Series.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.unique_count" title="cudf.dataframe.Series.unique_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique_count</span></code></a>([method])</td>
<td>Returns the number of unique valies of the Series: approximate version, and exact version to be moved to libgdf</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.value_counts" title="cudf.dataframe.Series.value_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">value_counts</span></code></a>([method,&nbsp;sort])</td>
<td>Returns unique values of this Series.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#cudf.dataframe.Series.values_to_string" title="cudf.dataframe.Series.values_to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values_to_string</span></code></a>([nrows])</td>
<td>Returns a list of string for each element.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#cudf.dataframe.Series.var" title="cudf.dataframe.Series.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>([ddof,&nbsp;axis,&nbsp;skipna])</td>
<td>Compute the variance of the series</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="64%" />
<col width="36%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>as_index</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>deserialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>from_arrow</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>from_pandas</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>head</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>serialize</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>sum_of_squares</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>to_arrow</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>to_pandas</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>unique_k</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.dataframe.Series.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>arbitrary</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.
Returns a new copy with the index resetted.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.applymap">
<code class="descname">applymap</code><span class="sig-paren">(</span><em>udf</em>, <em>out_dtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.applymap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a elemenwise function to transform the values in the Column.</p>
<p>The user function is expected to take one argument and return the
result, which will be stored to the output Series.  The function
cannot reference globals except for other simple scalar objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>udf</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Wrapped by <code class="docutils literal notranslate"><span class="pre">numba.cuda.jit</span></code> for call on the GPU as a device
function.</p>
</dd>
<dt><strong>out_dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype; optional</span></dt>
<dd><p class="first last">The dtype for use in the output.
By default, the result will have the same dtype as the source.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series</span></dt>
<dd><p class="first last">The mask and index are preserved.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.argsort">
<code class="descname">argsort</code><span class="sig-paren">(</span><em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Series of int64 index that will sort the series.</p>
<p>Uses stable parallel radixsort.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: Series</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.as_mask">
<code class="descname">as_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.as_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert booleans to bitmask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>device array</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to the given <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>If the dtype changed, a new ``Series`` is returned by casting each</strong></dt>
<dd></dd>
<dt><strong>values to the given dtype.</strong></dt>
<dd></dd>
<dt><strong>If the dtype is not changed, ``self`` is returned.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.ceil">
<code class="descname">ceil</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value upward to the smallest integral value not less
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.count">
<code class="descname">count</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of non-null values</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.data">
<code class="descname">data</code><a class="headerlink" href="#cudf.dataframe.Series.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the data</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#cudf.dataframe.Series.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>dtype of the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.factorize">
<code class="descname">factorize</code><span class="sig-paren">(</span><em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.factorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the input values as integer labels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>na_sentinel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd><p class="first last">Value to indicate missing category.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>(labels, cats)</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(Series, Series)</span></dt>
<dd><ul class="first last simple">
<li><em>labels</em> contains the encoded values</li>
<li><em>cats</em> contains the categories in order that the N-th
item corresponds to the (N-1) code.</li>
</ul>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.fillna">
<code class="descname">fillna</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<p>Returns a copy with null filled.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.find_first_value">
<code class="descname">find_first_value</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.find_first_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of first value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.find_last_value">
<code class="descname">find_last_value</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.find_last_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns offset of last value that matches</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.floor">
<code class="descname">floor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value downward to the largest integral value not greater
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.Series.from_categorical">
<em class="property">classmethod </em><code class="descname">from_categorical</code><span class="sig-paren">(</span><em>categorical</em>, <em>codes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.from_categorical" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates from a pandas.Categorical</p>
<p>If <code class="docutils literal notranslate"><span class="pre">codes</span></code> is defined, use it instead of <code class="docutils literal notranslate"><span class="pre">categorical.codes</span></code></p>
</dd></dl>

<dl class="classmethod">
<dt id="cudf.dataframe.Series.from_masked_array">
<em class="property">classmethod </em><code class="descname">from_masked_array</code><span class="sig-paren">(</span><em>data</em>, <em>mask</em>, <em>null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.from_masked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Series with null-mask.
This is equivalent to:</p>
<blockquote>
<div>Series(data).set_mask(mask, null_count=null_count)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array-like</span></dt>
<dd><p class="first last">The values.  Null values must not be skipped.  They can appear
as garbage values.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array-like of numpy.uint8</span></dt>
<dd><p class="first">The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.has_null_mask">
<code class="descname">has_null_mask</code><a class="headerlink" href="#cudf.dataframe.Series.has_null_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean indicating whether a null-mask is needed</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.hash_values">
<code class="descname">hash_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.hash_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hash of values in this column.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.index">
<code class="descname">index</code><a class="headerlink" href="#cudf.dataframe.Series.index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index object</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.label_encoding">
<code class="descname">label_encoding</code><span class="sig-paren">(</span><em>cats</em>, <em>dtype=None</em>, <em>na_sentinel=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform label encoding</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of input values</span></dt>
<dd></dd>
<dt><strong>dtype: numpy.dtype; optional</strong></dt>
<dd><p class="first last">Specifies the output dtype.  If <cite>None</cite> is given, the
smallest possible integer dtype (starting with np.int32)
is used.</p>
</dd>
<dt><strong>na_sentinel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">number</span></dt>
<dd><p class="first last">Value to indicate missing category.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>A sequence of encoded labels with value between 0 and n-1 classes(cats)</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the max of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.mean">
<code class="descname">mean</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.mean_var">
<code class="descname">mean_var</code><span class="sig-paren">(</span><em>ddof=1</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.mean_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute mean and variance at the same time.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.min">
<code class="descname">min</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the min of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.nlargest">
<code class="descname">nlargest</code><span class="sig-paren">(</span><em>n=5</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> largest element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.nsmallest">
<code class="descname">nsmallest</code><span class="sig-paren">(</span><em>n=5</em>, <em>keep='first'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> smallest element.</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.null_count">
<code class="descname">null_count</code><a class="headerlink" href="#cudf.dataframe.Series.null_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of null values</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.nullmask">
<code class="descname">nullmask</code><a class="headerlink" href="#cudf.dataframe.Series.nullmask" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the null-mask</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.one_hot_encoding">
<code class="descname">one_hot_encoding</code><span class="sig-paren">(</span><em>cats</em>, <em>dtype='float64'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one-hot-encoding</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>cats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of values</span></dt>
<dd><p class="first last">values representing each category.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.dtype</span></dt>
<dd><p class="first last">specifies the output dtype.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>A sequence of new series for each category.  Its length is determined</strong></dt>
<dd></dd>
<dt><strong>by the length of ``cats``.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.quantile">
<code class="descname">quantile</code><span class="sig-paren">(</span><em>q</em>, <em>interpolation='midpoint'</em>, <em>exact=True</em>, <em>quant_index=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array-like, default 0.5 (50% quantile)</span></dt>
<dd><p class="first last">0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{’linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt>
<dd><p class="first last">This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j:</p>
</dd>
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">List of column names to include.</p>
</dd>
<dt><strong>exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether to use approximate or exact quantile algorithm.</p>
</dd>
<dt><strong>quant_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether to use the list of quantiles as index.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>DataFrame</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.reset_index">
<code class="descname">reset_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset index to RangeIndex</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the Series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale values to [0, 1] in float64</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.set_index">
<code class="descname">set_index</code><span class="sig-paren">(</span><em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series with a different index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Index, Series-convertible</span></dt>
<dd><p class="first last">the new index or values for the new index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.set_mask">
<code class="descname">set_mask</code><span class="sig-paren">(</span><em>mask</em>, <em>null_count=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new Series by setting a mask array.</p>
<p>This will override the existing mask.  The returned Series will
reference the same data buffer as this Series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array-like of numpy.uint8</span></dt>
<dd><p class="first">The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.shape">
<code class="descname">shape</code><a class="headerlink" href="#cudf.dataframe.Series.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.sort_index">
<code class="descname">sort_index</code><span class="sig-paren">(</span><em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.sort_values">
<code class="descname">sort_values</code><span class="sig-paren">(</span><em>ascending=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by values.</p>
<p>Difference from pandas:
* Support axis=’index’ only.
* Not supporting: inplace, kind, na_position</p>
<p>Details:
Uses parallel radixsort, which is a stable sort.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.std">
<code class="descname">std</code><span class="sig-paren">(</span><em>ddof=1</em>, <em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.sum">
<code class="descname">sum</code><span class="sig-paren">(</span><em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of the series</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.take">
<code class="descname">take</code><span class="sig-paren">(</span><em>indices</em>, <em>ignore_index=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series by taking values from the corresponding <em>indices</em>.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.to_array">
<code class="descname">to_array</code><span class="sig-paren">(</span><em>fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numpy array for the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fillna</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">Defaults to None, which will skip null values.
If it equals “pandas”, null values are filled with NaNs.
Non integral dtype is promoted to np.float64.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.to_gpu_array">
<code class="descname">to_gpu_array</code><span class="sig-paren">(</span><em>fillna=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.to_gpu_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numba device array for the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fillna</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">See <em>fillna</em> in <code class="docutils literal notranslate"><span class="pre">.to_array</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.to_string">
<code class="descname">to_string</code><span class="sig-paren">(</span><em>nrows=NOTSET</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nrows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of rows to show.
If it is None, all rows are shown.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.unique">
<code class="descname">unique</code><span class="sig-paren">(</span><em>method='sort'</em>, <em>sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.
default=’sort’ will be changed to ‘hash’ when implemented.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.unique_count">
<code class="descname">unique_count</code><span class="sig-paren">(</span><em>method='sort'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.unique_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of unique valies of the Series: approximate version,
and exact version to be moved to libgdf</p>
</dd></dl>

<dl class="attribute">
<dt id="cudf.dataframe.Series.valid_count">
<code class="descname">valid_count</code><a class="headerlink" href="#cudf.dataframe.Series.valid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-null values</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.value_counts">
<code class="descname">value_counts</code><span class="sig-paren">(</span><em>method='sort'</em>, <em>sort=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.value_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.values_to_string">
<code class="descname">values_to_string</code><span class="sig-paren">(</span><em>nrows=None</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.values_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of string for each element.</p>
</dd></dl>

<dl class="method">
<dt id="cudf.dataframe.Series.var">
<code class="descname">var</code><span class="sig-paren">(</span><em>ddof=1</em>, <em>axis=None</em>, <em>skipna=True</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.dataframe.Series.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance of the series</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="groupby">
<h2>Groupby<a class="headerlink" href="#groupby" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.groupby.groupby.Groupby">
<em class="property">class </em><code class="descclassname">cudf.groupby.groupby.</code><code class="descname">Groupby</code><span class="sig-paren">(</span><em>df</em>, <em>by</em>, <em>method='sort'</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.groupby.Groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Groupby object returned by cudf.DataFrame.groupby().</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.groupby.groupby.Groupby.agg" title="cudf.groupby.groupby.Groupby.agg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">agg</span></code></a>(args)</td>
<td>Invoke aggregation functions on the groups.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>count</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>max</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>mean</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>min</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>sum</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.groupby.groupby.Groupby.agg">
<code class="descname">agg</code><span class="sig-paren">(</span><em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.groupby.groupby.Groupby.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Invoke aggregation functions on the groups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, list, str, callable</span></dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>str</dt>
<dd>The aggregate function name.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>list</dt>
<dd>List of <em>str</em> of the aggregate function.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dict</dt>
<dd>key-value pairs of source column name and list of
aggregate functions as <em>str</em>.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Since multi-indexes aren’t supported aggregation results are returned
in columns using the naming scheme of <cite>aggregation_columnname</cite>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cudf.io.csv">
<span id="io"></span><h2>IO<a class="headerlink" href="#module-cudf.io.csv" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="cudf.io.csv.read_csv">
<code class="descclassname">cudf.io.csv.</code><code class="descname">read_csv</code><span class="sig-paren">(</span><em>filepath</em>, <em>lineterminator='\n'</em>, <em>quotechar='&quot;'</em>, <em>quoting=True</em>, <em>doublequote=True</em>, <em>delimiter='</em>, <em>'</em>, <em>sep=None</em>, <em>delim_whitespace=False</em>, <em>skipinitialspace=False</em>, <em>names=None</em>, <em>dtype=None</em>, <em>skipfooter=0</em>, <em>skiprows=0</em>, <em>dayfirst=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.read_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Load and parse a CSV file into a DataFrame</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filepath</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Path of file to be read.</p>
</dd>
<dt><strong>delimiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default ‘,’</span></dt>
<dd><p class="first last">Delimiter to be used.</p>
</dd>
<dt><strong>delim_whitespace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Determines whether to use whitespace as delimiter.</p>
</dd>
<dt><strong>lineterminator</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default ‘\n’</span></dt>
<dd><p class="first last">Character to indicate end of line.</p>
</dd>
<dt><strong>skipinitialspace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default False</span></dt>
<dd><p class="first last">Skip spaces after delimiter.</p>
</dd>
<dt><strong>names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str, default None</span></dt>
<dd><p class="first last">List of column names to be used.</p>
</dd>
<dt><strong>dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str or dict of {col: dtype}, default None</span></dt>
<dd><p class="first last">List of data types in the same order of the column names
or a dictionary with column_name:dtype (pandas style).</p>
</dd>
<dt><strong>quotechar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">char, default ‘”’</span></dt>
<dd><p class="first last">Character to indicate start and end of quote item.</p>
</dd>
<dt><strong>quoting</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">If True, start and end quotechar are removed from returned strings
If False, start and end quotechar are kept in returned strings</p>
</dd>
<dt><strong>doublequote</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, default True</span></dt>
<dd><p class="first last">When quotechar is specified and quoting is True, indicates whether to
interpret two consecutive quotechar inside fields as single quotechar</p>
</dd>
<dt><strong>skiprows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default 0</span></dt>
<dd><p class="first last">Number of rows to be skipped from the start of file.</p>
</dd>
<dt><strong>skipfooter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, default 0</span></dt>
<dd><p class="first last">Number of rows to be skipped at the bottom of file.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>GPU ``DataFrame`` object.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.csv.read_csv_strings" title="cudf.io.csv.read_csv_strings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_csv_strings</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>

<span class="c1"># Create a test csv file</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foo.csv&#39;</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s2">&quot;num1,datetime,text&quot;</span><span class="p">,</span>
  <span class="s2">&quot;123,2018-11-13T12:00:00,abc&quot;</span><span class="p">,</span>
  <span class="s2">&quot;456,2018-11-14T12:35:01,def&quot;</span><span class="p">,</span>
  <span class="s2">&quot;789,2018-11-15T18:02:59,ghi&quot;</span>
<span class="p">]</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Read the file with cudf</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;num1&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">]</span>
<span class="c1"># Note &#39;int&#39; for 3rd column- text will be hashed</span>
<span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
                   <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">,</span>
                   <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Display results</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>  <span class="n">num1</span>                <span class="n">datetime</span> <span class="n">text</span>
<span class="mi">0</span>  <span class="mi">123</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">13</span><span class="n">T12</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mf">00.000</span> <span class="mi">5451</span>
<span class="mi">1</span>  <span class="mi">456</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">14</span><span class="n">T12</span><span class="p">:</span><span class="mi">35</span><span class="p">:</span><span class="mf">01.000</span> <span class="mi">5784</span>
<span class="mi">2</span>  <span class="mi">789</span> <span class="mi">2018</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">15</span><span class="n">T18</span><span class="p">:</span><span class="mo">02</span><span class="p">:</span><span class="mf">59.000</span> <span class="mi">6117</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="cudf.io.csv.read_csv_strings">
<code class="descclassname">cudf.io.csv.</code><code class="descname">read_csv_strings</code><span class="sig-paren">(</span><em>filepath</em>, <em>lineterminator='\n'</em>, <em>quotechar='&quot;'</em>, <em>quoting=True</em>, <em>doublequote=True</em>, <em>delimiter='</em>, <em>'</em>, <em>sep=None</em>, <em>delim_whitespace=False</em>, <em>skipinitialspace=False</em>, <em>names=None</em>, <em>dtype=None</em>, <em>skipfooter=0</em>, <em>skiprows=0</em>, <em>dayfirst=False</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.read_csv_strings" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Experimental</strong>: This function exists only as a beta way to use
<a class="reference external" href="https://nvstrings.readthedocs.io/en/latest/">nvstrings</a>. with cudf.</p>
<p>Future versions of cuDF will provide cleaner integration.</p>
<p>Uses the same arguments as read_csv.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>columns</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ordered list of cudf.dataframe.Series and nvstrings objects</span></dt>
<dd><p class="first">numeric or date dtyped columns will be Series.</p>
<p class="last">‘str’ dtyped columns will be
<a class="reference external" href="https://nvstrings.readthedocs.io/en/latest/">nvstrings</a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#cudf.io.csv.read_csv" title="cudf.io.csv.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_csv</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>

<span class="c1"># Create a test csv file</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;foo.csv&#39;</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s2">&quot;num1,datetime,text&quot;</span><span class="p">,</span>
  <span class="s2">&quot;123,2018-11-13T12:00:00,abc&quot;</span><span class="p">,</span>
  <span class="s2">&quot;456,2018-11-14T12:35:01,def&quot;</span><span class="p">,</span>
  <span class="s2">&quot;789,2018-11-15T18:02:59,ghi&quot;</span>
<span class="p">]</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Read the file with cudf</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;num1&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">]</span>
<span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="s1">&#39;str&#39;</span><span class="p">]</span>
<span class="n">columns</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">csv</span><span class="o">.</span><span class="n">read_csv_strings</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
                        <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">,</span>
                        <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Display results</span>
<span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">.</span><span class="n">Series</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">3</span> <span class="o">&gt;</span>
<span class="mi">0</span>  <span class="mi">123</span>
<span class="mi">1</span>  <span class="mi">456</span>
<span class="mi">2</span>  <span class="mi">789</span>

<span class="o">&lt;</span><span class="n">nvstrings</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="o">&gt;</span>
<span class="p">[</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;def&#39;</span><span class="p">,</span> <span class="s1">&#39;ghi&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="gpuarrowreader">
<h2>GpuArrowReader<a class="headerlink" href="#gpuarrowreader" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cudf.comm.gpuarrow.GpuArrowReader">
<em class="property">class </em><code class="descclassname">cudf.comm.gpuarrow.</code><code class="descname">GpuArrowReader</code><span class="sig-paren">(</span><em>schema_data</em>, <em>gpu_data</em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="cudf.comm.gpuarrow.GpuArrowReader.to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code></a>()</td>
<td>Return a dictionary of Series object</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cudf.comm.gpuarrow.GpuArrowReader.to_dict">
<code class="descname">to_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of Series object</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="developer.html" class="btn btn-neutral float-right" title="Developer Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to cuDF’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, NVIDIA

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>